variables
{
	global:
		0: DEBUG_MODE
		1: ADJ_TANK_ULT_NEGATION_PERCENT
		2: enable_regeneration
		3: ADJ_REGEN_HPS
		4: ADJ_REGEN_TIMER
		5: ANTI_CRASH_ACTIVATE_PERCENT
		6: ANTI_CRASH_HOLD_TIME
		7: ANTI_CRASH_DEACTIVATE_PERCENT
		8: Spectator_padding
		9: AllTankHeroes
		10: AllDpsHeroes
		11: AllSupportHeroes
		12: AllRoles
		13: dpsTime
		14: bot
		15: NEGATIVE_STATUS_PREVENTS_REFUND
		16: STEALTH_REFUND_FRACTION
		17: MINIMUM_TRANSLOCATOR_COOLDOWN

	player:
		0: hero_setup
		1: hero_initialized
		2: within_shout_radius
		3: macro_pvar
		4: Echo_Copy
		5: Within_speed_radius
		6: custom_hp_pvar
		7: max_health_scaler
		8: hero_switch_pvar
		9: Hanzo_Marked_icon
		10: text
		11: Orisa_heat
		12: Orisa_Ammo
		13: Roadhog_vape_hud_icon
		14: Sombra_hack_icon
		15: AllowedHeroes
		16: regen_passive_id
		17: Bastion_healing_id
		18: self_heal_pvar
		19: ult_charge_pvar
		20: damage
		21: time
		22: healing
		23: textID
		24: position
		25: Roadhog_vape_confirmed
		26: Sombra_virus_confirmed
		27: hazard_bubble_confirmed
		28: Ana_Sleepdart_Target
		29: Ashe_dynamite_hit
		30: Ashe_Dynamite_Healing_ID
		31: baptiste_balance_change_check
		32: Baptiste_hud
		33: sentry_healing_id
		34: bash_cooldown
		35: punched_victims
		36: wall_impacted_victims
		37: self_destruct_charge
		38: EchoUltSeconds
		39: HanzoDrawAura
		40: Hazard_Downpour_Target
		41: Hazard_Downpour_effect
		42: hazard_bubble_target
		43: Hazard_Bubble_Allowed
		44: overhealth_check
		45: Junkerqueen_overhealth
		46: Junkrat_Trap_target
		47: Junkrat_Trap_effect
		48: orbital_ray_x
		49: orbital_ray_z
		50: orbital_ray_final_x
		51: orbital_ray_final_z
		52: remainingAntiDuration
		53: Lifeweaver_petal_charges
		54: Lifeweaver_dash_charges
		55: Lifeweaver_healing_cd
		56: balance_change_check
		57: Mauga_Overdrive_Health
		58: Cardiac_overdrive_active
		59: DoomPunchTrack
		60: ReinChargeTrack
		61: ImbueDuration
		62: ImbueTarget
		63: ImbueSecondary
		64: ImbueAOERing
		65: ImbueAOESound
		66: Mercy_Rez_charges
		67: RezHUD
		68: ImbueTargetIcon
		69: MercyUltTrack
		70: ImbueBeam
		71: ImbueSparkle
		72: terra_overhealth_id
		73: Orisa_fortified
		74: Orisa_ring_effect
		75: Nemesis_armor
		76: Roadhog_vape_target
		77: Roadhog_vape_effect
		78: hp_exiting_grasp
		79: Sombra_invisible
		80: Sombra_virus_target
		81: Sombra_healing_ring
		82: stealth_timer
		83: Sombra_invis_damage
		84: stealth_pvar
		85: overload_overhealth
		86: is_firing_excavator
		87: clobber_cooldown_accelerator
		88: WidowScopeGlint_effect
		89: adaptive_overhealth_id
		90: self_bubble_cooldown
		91: ally_bubble_cooldown
		92: Widowmaker_beam_effect
		93: Widow_maxscope_duration
		94: uppercut_victims
		95: is_using_uppercut
		96: number_of_victims_uppercut
		97: doom_uppercut_shields
		98: Orisa_Overheating
		99: RezTarget
		100: hazard_bubble_effect
		101: hazard_bubble_icon
		102: hazard_bubble_effect2
}

subroutines
{
	0: initHero
	1: clearCustomHp
	2: applyCustomHp
	3: resetHero
	4: enableAllAbilities
	5: disableAllAbilities
	6: resetStats
	7: resetStatuses
	8: resetUltCharge
	9: removeTankPassive
	10: initAna
	11: initAshe
	12: initBaptiste
	13: initBastion
	14: initBrigitte
	15: initDoomfist
	16: initDva
	17: initEcho
	18: EchoCopy
	19: initFreja
	20: initGenji
	21: initHanzo
	22: initHazard
	23: initIllari
	24: initJunkerQueen
	25: initJunkrat
	26: initJuno
	27: initKiriko
	28: initLifeweaver
	29: initLucio
	30: initMauga
	31: initMccree
	32: initMei
	33: initMercy
	34: initMoira
	35: initOrisa
	36: initPharah
	37: initRamattra
	38: initReaper
	39: initReinhardt
	40: initRoadhog
	41: initSigma
	42: initSojourn
	43: initSoldier
	44: initSombra
	45: initSymmetra
	46: initTorbjorn
	47: initTracer
	48: initVenture
	49: initWidowmaker
	50: initWinston
	51: initWreckingBall
	52: initZarya
	53: showSelfBubbleCD
	54: hideSelfBubbleCD
	55: showAllyBubbleCD
	56: hideAllyBubbleCD
	57: initZenyatta
	58: executeUppercut
}

rule("Copyright (c) 2024 Overwatch 1 Emulator & 6v6 Adjustments. See github.com/6v6-Adjustments/6v6-adjustments for license to use this code.")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		disabled Disable Inspector Recording;
	}
}

rule("[utilities/global.opy] Initialize player variables")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.within_shout_radius = False;
		Event Player.macro_pvar[3] = 100;
		Event Player.macro_pvar[2] = 100;
		Event Player.Echo_Copy = False;
		Event Player.Within_speed_radius = False;
	}
}

rule("[utilities/reset.opy]: resetStats()")
{
	event
	{
		Subroutine;
		resetStats;
	}

	actions
	{
		Event Player.macro_pvar[0] = 1;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Set Damage Received(Event Player, 100);
		Set Projectile Speed(Event Player, 100);
		Set Projectile Gravity(Event Player, 100);
		Event Player.macro_pvar[1] = 1;
		Set Healing Dealt(Event Player, 100 * Event Player.macro_pvar[1]);
		Set Healing Received(Event Player, 100);
		Set Knockback Received(Event Player, 100);
		Set Knockback Dealt(Event Player, 100);
		"eventPlayer.setGravity(100)\neventPlayer.setJumpVerticalSpeed(100) # might be responsible for jump bug"
		Event Player.macro_pvar[2] = 1;
		Set Move Speed(Event Player, 100 * Event Player.macro_pvar[2]);
		Stop Scaling Player(Event Player);
		Stop Scaling Barriers(Event Player);
		"prevent wholehog from keeping primary fire held"
		Stop Holding Button(Event Player, Button(Primary Fire));
		Event Player.max_health_scaler = 1;
		Stop All Damage Over Time(Event Player);
		Stop All Heal Over Time(Event Player);
		Event Player.macro_pvar[3] = 100;
		Event Player.macro_pvar[2] = 100;
	}
}

rule("player died")
{
	event
	{
		Player Died;
		All;
		All;
	}

	actions
	{
		Event Player.Hanzo_Marked_icon = Null;
		Destroy In-World Text(Event Player.text[19]);
		Event Player.text[19] = Null;
		If(Hero Of(Event Player) == Hero(Orisa));
			Event Player.Orisa_heat = 0;
			Event Player.Orisa_Ammo = 100;
	}
}

rule("[utilities/hud.opy]: Padding lines for HUD display Roadhog and Sombra (makes it visable to spectators)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.Spectator_padding == Null;
		Global.DEBUG_MODE == False;
	}

	actions
	{
		Create HUD Text(Local Player, Null, Null, Custom String(" \r\n\r\n\r\n\r"), Left, 1, Color(White), Color(White), Color(White),
			Visible To and String, Visible Never);
		Global.Spectator_padding = True;
	}
}

rule("[utilities/hud.opy]: Display buffs from Roadhog, Hanzo and Sombra")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DEBUG_MODE == False;
	}

	actions
	{
		Create HUD Text(Event Player, Null, Null, Custom String(
			" \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                                                         {0} {1} {2}",
			Event Player.Roadhog_vape_hud_icon == True ? Ability Icon String(Hero(Roadhog), Button(Secondary Fire)) : Custom String(" "),
			Event Player.Sombra_hack_icon == True ? Ability Icon String(Hero(Sombra), Button(Ultimate)) : Custom String(" "),
			Event Player.Hanzo_Marked_icon ? Icon String(Skull) : Custom String(" ")), Left, 2, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Event Player.text[0] = Last Text ID;
	}
}

rule("[utilities.opy]: destroy all huds and effects between rounds")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Between Rounds == True;
	}

	actions
	{
		Destroy All Progress Bar In-World Text;
		Destroy All In-World Text;
		Destroy All Effects;
		Destroy All Progress Bar HUD Text;
	}
}

rule("[role_lock.opy]: Global/set all Heroes")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.AllTankHeroes = Array(Hero(D.Va), Hero(Junker Queen), Hero(Mauga), Hero(Orisa), Hero(Ramattra), Hero(Reinhardt), Hero(
			Roadhog), Hero(Sigma), Hero(Venture), Hero(Winston), Hero(Wrecking Ball), Hero(Zarya), Hero(Hazard));
		Global.AllDpsHeroes = Array(Hero(Ashe), Hero(Bastion), Hero(Cassidy), Hero(Echo), Hero(Genji), Hero(Hanzo), Hero(Junkrat), Hero(
			Pharah), Hero(Reaper), Hero(Sojourn), Hero(Soldier: 76), Hero(Torbjörn), Hero(Tracer), Hero(Widowmaker), Hero(Symmetra), Hero(
			Freja), Hero(Doomfist), Hero(Mei));
		Global.AllSupportHeroes = Array(Hero(Ana), Hero(Baptiste), Hero(Brigitte), Hero(Illari), Hero(Juno), Hero(Kiriko), Hero(
			Lifeweaver), Hero(Lúcio), Hero(Mercy), Hero(Moira), Hero(Sombra), Hero(Zenyatta));
	}
}

rule("[role_lock.opy]: Role Limits")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.AllRoles = Array(Workshop Setting Integer(Custom String("Roles"), Custom String("Tank Role Cap"), 0, 0, 6, 0),
			Workshop Setting Integer(Custom String("Roles"), Custom String("Damage Role Cap"), 0, 0, 6, 1), Workshop Setting Integer(
			Custom String("Roles"), Custom String("Support Role Cap"), 0, 0, 6, 2));
	}
}

rule("[role_lock.opy]: Player Init")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.AllowedHeroes = All Heroes;
	}
}

rule("[role_lock.opy]: Tank")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllTankHeroes, Hero Of(
			Current Array Element))), Event Player)) >= Global.AllRoles[0];
		Global.AllRoles[0] > 0;
	}

	actions
	{
		If(Event Player.Echo_Copy == False);
			Modify Player Variable(Event Player, AllowedHeroes, Remove From Array By Value, Global.AllTankHeroes);
			Set Player Allowed Heroes(Event Player, Event Player.AllowedHeroes);
			Wait Until(Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllTankHeroes,
				Hero Of(Current Array Element))), Event Player)) < Global.AllRoles[0], 99999);
			Modify Player Variable(Event Player, AllowedHeroes, Append To Array, Global.AllTankHeroes);
			Set Player Allowed Heroes(Event Player, Event Player.AllowedHeroes);
	}
}

rule("[role_lock.opy]: Damage")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllDpsHeroes, Hero Of(
			Current Array Element))), Event Player)) >= Global.AllRoles[1];
		Global.AllRoles[1] > 0;
	}

	actions
	{
		If(Event Player.Echo_Copy == False);
			Modify Player Variable(Event Player, AllowedHeroes, Remove From Array By Value, Global.AllDpsHeroes);
			Set Player Allowed Heroes(Event Player, Event Player.AllowedHeroes);
			Wait Until(Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllDpsHeroes,
				Hero Of(Current Array Element))), Event Player)) < Global.AllRoles[1], 99999);
			Modify Player Variable(Event Player, AllowedHeroes, Append To Array, Global.AllDpsHeroes);
			Set Player Allowed Heroes(Event Player, Event Player.AllowedHeroes);
	}
}

rule("[role_lock.opy]: Support")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllSupportHeroes, Hero Of(
			Current Array Element))), Event Player)) >= Global.AllRoles[2];
		Global.AllRoles[2] > 0;
	}

	actions
	{
		If(Event Player.Echo_Copy == False);
			Modify Player Variable(Event Player, AllowedHeroes, Remove From Array By Value, Global.AllSupportHeroes);
			Set Player Allowed Heroes(Event Player, Event Player.AllowedHeroes);
			Wait Until(Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllSupportHeroes,
				Hero Of(Current Array Element))), Event Player)) < Global.AllRoles[2], 99999);
			Modify Player Variable(Event Player, AllowedHeroes, Append To Array, Global.AllSupportHeroes);
			Set Player Allowed Heroes(Event Player, Event Player.AllowedHeroes);
	}
}

rule("[role_lock.opy]: Skip Assemble Heroes")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Assembling Heroes == True;
	}

	actions
	{
		Wait(0.500, Ignore Condition);
		Set Match Time(1);
		Wait Until(Is Assembling Heroes == False, 99999);
		Set Match Time(60);
	}
}

rule("[passives/healing.opy]: Track Health != 100% stop healing then start healing after 5s")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	conditions
	{
		Global.enable_regeneration == True;
	}

	actions
	{
		Stop Heal Over Time(Event Player.regen_passive_id);
		If(Hero Of(Event Player) == Hero(Bastion));
			Stop Heal Over Time(Event Player.Bastion_healing_id);
		End;
		Event Player.self_heal_pvar = False;
		Wait(Global.ADJ_REGEN_TIMER, Restart When True);
		Event Player.self_heal_pvar = True;
	}
}

rule("[passives/healing.opy]: Healing passive amount and ID")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.self_heal_pvar != False;
		Global.enable_regeneration == True;
	}

	actions
	{
		Start Heal Over Time(Event Player, Null, 9999, Global.ADJ_REGEN_HPS);
		Event Player.regen_passive_id = Last Heal Over Time ID;
		If(Hero Of(Event Player) == Hero(Bastion));
			Start Heal Over Time(Event Player, Null, 9999, 15);
			Event Player.Bastion_healing_id = Last Heal Over Time ID;
		End;
	}
}

rule("[passives/healing.opy]: If health = max health stop healing")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Normalized Health(Event Player) >= 1;
		Global.enable_regeneration == True;
	}

	actions
	{
		Stop Heal Over Time(Event Player.regen_passive_id);
		If(Hero Of(Event Player) == Hero(Bastion));
			Stop Heal Over Time(Event Player.Bastion_healing_id);
		End;
	}
}

rule("[passives/tank/ult_charge.opy]: resetUltCharge()")
{
	event
	{
		Subroutine;
		resetUltCharge;
	}

	actions
	{
		Event Player.ult_charge_pvar[0] = 0;
		Event Player.ult_charge_pvar[1] = 0;
		Wait Until(Ultimate Charge Percent(Event Player) > 0, 1);
		Set Ultimate Charge(Event Player, 0);
	}
}

rule("[passives/tank/ult_charge.opy]: Remember missing ult charge from damaging tank")
{
	event
	{
		Player Dealt Damage;
		All;
		All;
	}

	conditions
	{
		Array Contains(All Tank Heroes, Hero Of(Victim)) == True;
		Is Using Ultimate(Event Player) == False;
		Victim != Event Player;
	}

	actions
	{
		Event Player.ult_charge_pvar[0] += (40 - Global.ADJ_TANK_ULT_NEGATION_PERCENT) / 100 * Event Damage;
	}
}

rule("[passives/tank/ult_charge.opy]: Remember missing ult charge from healing tank (+ workshop healing ultcharge)")
{
	event
	{
		Player Dealt Healing;
		All;
		All;
	}

	conditions
	{
		disabled Array Contains(All Tank Heroes, Hero Of(Healee)) == True;
		(Array Contains(All Tank Heroes, Hero Of(Healee)) || (Hero Of(Event Player) == Hero(Sombra) && !Event Was Health Pack) || (Hero Of(
			Event Player) == Hero(Mercy) && Event Ability != Button(Primary Fire)) || (Healee != Event Player && Hero Of(Event Player)
			== Hero(Roadhog)) || Hero Of(Event Player) == Hero(Mauga)) == True;
		Is Using Ultimate(Event Player) == False;
		Ultimate Charge Percent(Event Player) < 100;
	}

	actions
	{
		If((Hero Of(Event Player) == Hero(Sombra) && !Event Was Health Pack) || ((Hero Of(Event Player) == Hero(Mercy)
			&& Event Ability != Button(Primary Fire)) || (Healee != Event Player && Hero Of(Event Player) == Hero(Roadhog)) || Hero Of(
			Event Player) == Hero(Mauga)));
			Event Player.ult_charge_pvar[0] += Event Healing;
		Else If(Array Contains(All Tank Heroes, Hero Of(Healee)));
			Event Player.ult_charge_pvar[0] += (40 - Global.ADJ_TANK_ULT_NEGATION_PERCENT) / 100 * Event Healing;
		End;
	}
}

disabled rule("[passives/tank/ult_charge.opy]: Remember missing ult charge from healing tank")
{
	event
	{
		Player Dealt Healing;
		All;
		All;
	}

	conditions
	{
		Array Contains(All Tank Heroes, Hero Of(Healee)) == True;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Event Player.ult_charge_pvar[0] += (40 - Global.ADJ_TANK_ULT_NEGATION_PERCENT) / 100 * Event Healing;
	}
}

rule("[passives/tank/ult_charge.opy]: Compensate missing ultimate percentage")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		First Of(Event Player.ult_charge_pvar) > 0.010 * Event Player.ult_charge_pvar[1];
		"guard to protect ult resetting accidentally"
		Event Player.ult_charge_pvar[1] > 0;
	}

	actions
	{
		Event Player.ult_charge_pvar[2] = Round To Integer(100 * ((Ultimate Charge Percent(Event Player)
			/ 100 * Event Player.ult_charge_pvar[1] + First Of(Event Player.ult_charge_pvar)) / Event Player.ult_charge_pvar[1]), Up);
		Event Player.ult_charge_pvar[0] -= Event Player.ult_charge_pvar[2] / 100 * Event Player.ult_charge_pvar[1] - Ultimate Charge Percent(
			Event Player) / 100 * Event Player.ult_charge_pvar[1];
		Set Ultimate Charge(Event Player, Event Player.ult_charge_pvar[2]);
	}
}

rule("[passives/tank/ult_charge.opy]: Reset ult compensation after using ult")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Event Player.ult_charge_pvar[0] = 0;
	}
}

rule("[passives/tank/knockback.opy]: removeTankPassive()")
{
	event
	{
		Subroutine;
		removeTankPassive;
	}

	actions
	{
		Set Knockback Received(Event Player, 130);
	}
}

rule("[passives/damage/damage_passive.opy]: Remove DPS Passive")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	conditions
	{
		Array Contains(All Damage Heroes, Hero Of(Attacker)) == True;
		Attacker != Victim;
	}

	actions
	{
		If(Array Contains(All Tank Heroes, Hero Of(Victim)));
			Set Healing Received(Event Player, 112.500);
		Else;
			Set Healing Received(Event Player, 125);
		End;
		Wait(0.500, Ignore Condition);
		Wait(2.500, Restart When True);
		Set Healing Received(Event Player, 100);
	}
}

rule("[passives/damage/healthpack.opy] Healthpacks substitute healing")
{
	event
	{
		Player Received Healing;
		All;
		All;
	}

	conditions
	{
		Event Was Health Pack == True;
	}

	actions
	{
		If(Event Healing >= 250);
			If(Event Healing > 251);
				If(Array Contains(All Tank Heroes, Hero Of(Event Player)));
					Heal(Event Player, Null, 39);
				Else;
					Heal(Event Player, Null, 8);
				End;
			Else;
				Heal(Event Player, Null, 70);
			End;
		Else If(Event Healing >= 75);
			If(Event Healing > 76);
				If(Array Contains(All Tank Heroes, Hero Of(Event Player)));
					Heal(Event Player, Null, 16);
				Else;
					Heal(Event Player, Null, 6);
				End;
			Else;
				Heal(Event Player, Null, 25);
			End;
		End;
	}
}

rule("[debug_mode.opy]: Global init")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.DEBUG_MODE == True;
	}

	actions
	{
		"By Lotto"
		Global.dpsTime = Workshop Setting Integer(Custom String("Dev Tools"), Custom String("Calculate DPS over seconds"), 20, 1, 200, 1);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("[{0}] -- Start/reset the DPS calculation.",
			Input Binding String(Button(Interact))), Left, 0, Color(White), Color(Green), Color(Green), Visible To and String,
			Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("[Crouch] + [Jump] -- Spawn a bot."), Left, 1, Color(White),
			Color(Turquoise), Color(Turquoise), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("[Crouch] + [Melee] -- Remove all bots."), Left, 2, Color(White),
			Color(Orange), Color(Orange), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("Hold [Melee] -- Change Hero."), Left, 3, Color(White), Color(
			Orange), Color(Rose), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String(" "), Left, 4, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
	}
}

rule("[debug_mode.opy]: Player init")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.DEBUG_MODE == True;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, time, 0, 1, Destination and Rate);
		Create HUD Text(Event Player, Event Player.damage, Custom String("Total damage"), Null, Left, 5, Color(Yellow), Color(White),
			Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Event Player, Event Player.damage / (Global.dpsTime - Event Player.time), Custom String("DPS"), Null, Left, 6,
			Color(Red), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Event Player, Event Player.time, Custom String("Time"), Null, Left, 7, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Create HUD Text(Event Player, Event Player.healing, Custom String("Total healing"), Null, Left, 8, Color(Yellow), Color(White),
			Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Event Player, Event Player.healing / (Global.dpsTime - Event Player.time), Custom String("HPS"), Null, Left, 9,
			Color(Red), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Event Player, Custom String("{0}", Speed Of(Event Player)), Null, Null, Top, 0, Color(White), Color(White), Color(
			White), Visible To and String, Default Visibility);
	}
}

rule("[debug_mode.opy]: Player Dealt Damage")
{
	event
	{
		Player Dealt Damage;
		All;
		All;
	}

	conditions
	{
		Victim != Attacker;
		Global.DEBUG_MODE == True;
	}

	actions
	{
		"Inspired by a damage numbers mode by Darwin"
		Destroy In-World Text(Event Player.textID);
		Event Player.position = Eye Position(Victim);
		Create In-World Text(Event Player, Event Damage, Event Player.position, 0.850 + Event Damage / 30, Clip Against Surfaces,
			Visible To Position and String, Color(White), Default Visibility);
		Event Player.textID = Last Text ID;
		Chase Player Variable At Rate(Event Player, position, Eye Position(Victim) + Up, 0.900, None);
		Skip If(Event Player.time == 0, 1);
		Event Player.damage += Event Damage;
	}
}

rule("[debug_mode.opy]: Player Dealt Damage")
{
	event
	{
		Player Dealt Healing;
		All;
		All;
	}

	conditions
	{
		Healee != Healer;
		Global.DEBUG_MODE == True;
	}

	actions
	{
		"Inspired by a damage numbers mode by Darwin"
		Destroy In-World Text(Event Player.textID);
		Event Player.position = Eye Position(Healee);
		Create In-World Text(Event Player, Event Healing, Event Player.position, 0.850 + Event Damage / 30, Clip Against Surfaces,
			Visible To Position and String, Color(Yellow), Default Visibility);
		Event Player.textID = Last Text ID;
		Chase Player Variable At Rate(Event Player, position, Eye Position(Healee) + Up, 0.900, None);
		Skip If(Event Player.time == 0, 1);
		Event Player.healing += Event Healing;
	}
}

rule("[debug_mode.opy]: Start")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Global.DEBUG_MODE == True;
	}

	actions
	{
		Event Player.time = Global.dpsTime;
		Event Player.damage = 0;
		Event Player.healing = 0;
	}
}

rule("[debug_mode.opy]: Spawn bot")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Jump)) == True;
		Global.DEBUG_MODE == True;
	}

	actions
	{
		Create Dummy Bot(Hero(Ana), Opposite Team Of(Team Of(Event Player)), -1, Position Of(Event Player), Facing Direction Of(
			Event Player));
		Global.bot = Last Created Entity;
		Wait(0.100, Ignore Condition);
		Set Max Health(Global.bot, 1000);
		Start Heal Over Time(Global.bot, Null, 9999, 50);
	}
}

rule("[debug_mode.opy]: Remove all bots")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Melee)) == True;
		Global.DEBUG_MODE == True;
	}

	actions
	{
		Destroy All Dummy Bots;
		Destroy In-World Text(Event Player.textID);
	}
}

rule("[debug_mode.opy]: Change hero")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Melee)) == True;
		Global.DEBUG_MODE == True;
	}

	actions
	{
		Wait(1, Abort When False);
		Event Player.position = Position Of(Event Player);
		Set Player Allowed Heroes(Event Player, Filtered Array(All Heroes, Hero Of(Event Player) != Current Array Element));
		Wait(0.100, Ignore Condition);
		Set Player Allowed Heroes(Event Player, All Heroes);
		Destroy In-World Text(Event Player.textID);
		Wait Until(Has Spawned(Event Player), 99999);
		Teleport(Event Player, Event Player.position);
	}
}

rule("[debug_mode.opy]: Test Roadhog and Sombra new abilities")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Melee)) == True;
		Global.DEBUG_MODE == True;
	}

	actions
	{
		Event Player.Roadhog_vape_confirmed = True;
		Event Player.Sombra_virus_confirmed = True;
		Event Player.hazard_bubble_confirmed = True;
		Event Player.Hanzo_Marked_icon = True;
	}
}

rule("[ana/init.opy]: initAna()")
{
	event
	{
		Subroutine;
		initAna;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 200;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2300;
		Event Player.macro_pvar[0] = 0.667;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.macro_pvar[1] = 0.933;
		Set Healing Dealt(Event Player, 100 * Event Player.macro_pvar[1]);
		Event Player.hero_initialized = True;
	}
}

rule("[ana/sleep.opy]: Sleep tanks as long as other heroes")
{
	event
	{
		Player Dealt Damage;
		All;
		Ana;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
		Array Contains(All Tank Heroes, Hero Of(Victim)) == True;
	}

	actions
	{
		Wait Until(Has Status(Victim, Asleep) == True, 999999986991104.000);
		Wait(0.200, Ignore Condition);
		"Sleeping someone on top of sleep doesnt work anymore"
		Set Status(Victim, Attacker, Knocked Down, 4.800);
		Victim.Ana_Sleepdart_Target = True;
	}
}

rule("[ana/sleep.opy]: Cleanse the sleep on tanks on damage")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Knocked Down) == True;
		Event Player.Ana_Sleepdart_Target == True;
	}

	actions
	{
		If(Ability Cooldown(Players On Hero(Hero(Ana), Opposite Team Of(Team Of(Event Player))), Button(Ability 1)) != 0);
			Clear Status(Event Player, Knocked Down);
			Event Player.Ana_Sleepdart_Target = Null;
	}
}

rule("[ana/nade.opy]: Increase Biotic Grenade damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Ana;
	}

	conditions
	{
		Event Ability == Button(Ability 2);
	}

	actions
	{
		Damage(Victim, Attacker, (0.800 * (Event Damage / First Of(Event Player.macro_pvar)) - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[ana/nade.opy]: Increase Biotic Grenade healing")
{
	event
	{
		Player Dealt Healing;
		All;
		Ana;
	}

	conditions
	{
		Event Ability == Button(Ability 2);
	}

	actions
	{
		Heal(Healee, Healer, Event Healing * 1.334 / Event Player.macro_pvar[1] - Event Healing);
	}
}

rule("[ana/init.opy]: Correct Sleep Dart and Ana Melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Ana;
	}

	conditions
	{
		Array Contains(Array(Button(Ability 1), Button(Melee)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[ana/init.opy]: Correct Sleep Dart and Ana Melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Ana;
	}

	conditions
	{
		Event Ability == Button(Primary Fire);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) * 0.933 - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[ashe/init.opy]: initAshe()")
{
	event
	{
		Subroutine;
		initAshe;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 200;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2240;
		Event Player.macro_pvar[0] = 0.934;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.max_health_scaler = 0.800;
		Event Player.hero_initialized = True;
	}
}

rule("[ashe/dynamite.opy]: Decreased dynamite damage by healing until timeout or cleansed = 85 damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Ashe;
	}

	conditions
	{
		Event Ability == Button(Ability 2);
		Victim.Ashe_dynamite_hit == Null;
	}

	actions
	{
		Event Player.Ashe_dynamite_hit = True;
		Start Heal Over Time(Victim, Null, 5, 2);
		Victim.Ashe_Dynamite_Healing_ID = Last Healing Modification ID;
		Wait Until((Has Status(Victim, Phased Out) || Has Status(Victim, Invincible)) == True, 5);
		Stop Heal Over Time(Victim.Ashe_Dynamite_Healing_ID);
		Victim.Ashe_Dynamite_Healing_ID = Null;
		Event Player.Ashe_dynamite_hit = Null;
	}
}

rule("[ashe/viper.opy]: correct viper damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Ashe;
	}

	conditions
	{
		Event Ability == Button(Primary Fire);
		Is Button Held(Event Player, Button(Secondary Fire)) == False;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[ashe/init.opy]: Correct damage numbers")
{
	event
	{
		Player Dealt Damage;
		All;
		Ashe;
	}

	conditions
	{
		Array Contains(Array(Button(Ability 1), Button(Ability 2), Button(Melee)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[baptiste/init.opy]: initBaptiste()")
{
	event
	{
		Subroutine;
		initBaptiste;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 200;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2440;
		Event Player.macro_pvar[0] = 0.960;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.macro_pvar[1] = 0.584;
		Set Healing Dealt(Event Player, 100 * Event Player.macro_pvar[1]);
		Event Player.baptiste_balance_change_check = True;
		Event Player.max_health_scaler = 0.800;
		Event Player.hero_initialized = True;
	}
}

rule("[baptiste/init.opy]: Increase Baptiste melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Baptiste;
	}

	conditions
	{
		Array Contains(Array(Button(Melee)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[baptiste/init.opy]: Increase Biotic Launcher healing")
{
	event
	{
		Player Dealt Healing;
		All;
		Baptiste;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
		Event Healing < 35;
		Event Player.baptiste_balance_change_check != False;
	}

	actions
	{
		Event Player.baptiste_balance_change_check = False;
		Heal(Healee, Healer, Event Healing / Event Player.macro_pvar[1] * 1.167 - Event Healing);
		Wait(0.150, Ignore Condition);
		Event Player.baptiste_balance_change_check = True;
	}
}

rule("[baptiste/init.opy]: Healing indicator")
{
	event
	{
		Ongoing - Each Player;
		All;
		Baptiste;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Is Between Rounds == False;
	}

	actions
	{
		Create In-World Text(Event Player, Custom String("{0} {1}", Count Of(Filtered Array(All Living Players(Team Of(Event Player)),
			Distance Between(Event Player, Current Array Element) <= 12 && Is In Line of Sight(Event Player, Current Array Element,
			Enemy Barriers Block LOS) == True && Hero Of(Current Array Element) != Hero(Baptiste))), Ability Icon String(Hero(Baptiste),
			Button(Ability 1))), Update Every Frame(Eye Position(Event Player) + 100 * (0 * World Vector Of(Right, Event Player, Rotation)
			+ -0.350 * Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)),
			Vertical Angle From Direction(Facing Direction Of(Event Player)) - 90) + 3 * Facing Direction Of(Event Player))), 2,
			Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
		Event Player.Baptiste_hud = Last Text ID;
		Wait Until(Ability Cooldown(Event Player, Button(Ability 1)) != 0, 99999);
		Destroy In-World Text(Event Player.Baptiste_hud);
	}
}

rule("[baptiste/regen_burst.opy]: Correct regenerative burst hps")
{
	event
	{
		Player Dealt Healing;
		All;
		Baptiste;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
	}

	actions
	{
		"self healing"
		If(Healee == Healer);
			Heal(Healee, Healer, Event Healing / Event Player.macro_pvar[1] * 3.750 - Event Healing);
		"ally healing"
		Else;
			Heal(Healee, Healer, Event Healing / Event Player.macro_pvar[1] * 2.125 - Event Healing);
	}
}

rule("[baptiste/regen_burst.opy]: Remove initial burst healing from Regenerative Burst and set cooldown for duplicate")
{
	event
	{
		Ongoing - Each Player;
		All;
		Baptiste;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Set Healing Dealt(Event Player, 0);
		Wait Until(!Is Using Ability 1(Event Player), 999999986991104.000);
		Set Healing Dealt(Event Player, 100 * Event Player.macro_pvar[1]);
	}
}

rule("[baptiste/init.opy]: Clean up Baptiste")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hero_setup != Hero(Baptiste);
	}

	actions
	{
		Destroy In-World Text(Event Player.Baptiste_hud);
	}
}

rule("[bastion/init.opy]: initBastion()")
{
	event
	{
		Subroutine;
		initBastion;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 50;
		Event Player.custom_hp_pvar[1] = 5;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2300;
		Start Scaling Player(Event Player, 0.960, True);
		Event Player.hero_initialized = True;
	}
}

rule("[bastion/reconfigure.opy]: Reduce assault form damage and movement speed")
{
	event
	{
		Ongoing - Each Player;
		All;
		Bastion;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Set Damage Received(Event Player, 112.500);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 15;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Wait(0.950, Ignore Condition);
		Start Heal Over Time(Event Player, Event Player, 8, 15);
		Event Player.sentry_healing_id = Last Heal Over Time ID;
		Wait Until(!Is Using Ability 1(Event Player), 999999986991104.000);
		Set Damage Received(Event Player, 100);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 15;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Stop Heal Over Time(Event Player.sentry_healing_id);
		Event Player.sentry_healing_id = Null;
	}
}

rule("[bastion/reconfigure.opy]: Increase movement allowed by self-damage grenade")
{
	event
	{
		Player Dealt Damage;
		All;
		Bastion;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
		Attacker == Victim;
	}

	actions
	{
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 25;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		"Grace period to make sure the player receives this benefit"
		Wait(0.100, Ignore Condition);
		Wait Until(Is On Ground(Event Player), 999999986991104.000);
		disabled Abort If Condition Is False;
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 25;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
	}
}

rule("[bastion/init.opy]: Reduce grenade self-damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Bastion;
	}

	conditions
	{
		Attacker == Victim;
	}

	actions
	{
		Heal(Victim, Null, Event Damage - Event Damage * 0.500);
	}
}

rule("[bastion/init.opy]: Clean up Bastion")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hero_setup != Hero(Bastion);
	}

	actions
	{
		Stop Heal Over Time(Event Player.Bastion_healing_id);
		Stop Heal Over Time(Event Player.sentry_healing_id);
	}
}

rule("[brigitte/init.opy]: initBrigitte()")
{
	event
	{
		Subroutine;
		initBrigitte;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 15;
		Event Player.custom_hp_pvar[1] = 10;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2625;
		Event Player.macro_pvar[0] = 0.778;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.macro_pvar[1] = 0.800;
		Set Healing Dealt(Event Player, 100 * Event Player.macro_pvar[1]);
		Event Player.hero_initialized = True;
	}
}

rule("[brigitte/bash.opy]: Correct Shield Bash damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Brigitte;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
		Event Ability == Button(Primary Fire);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[brigitte/bash.opy]: Track Bash cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		Brigitte;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.bash_cooldown = 5.300;
		Chase Player Variable At Rate(Event Player, bash_cooldown, 0, 1, None);
	}
}

rule("[brigitte/bash.opy]: Force cooldown for Bash in Rally")
{
	event
	{
		Ongoing - Each Player;
		All;
		Brigitte;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Primary Fire), Event Player.bash_cooldown);
	}
}

rule("[brigitte/inspire.opy]: Increase Inspire self healing")
{
	event
	{
		Player Dealt Healing;
		All;
		Brigitte;
	}

	conditions
	{
		Healee == Healer;
	}

	actions
	{
		Heal(Healee, Null, Event Healing * 1.250 - Event Healing);
	}
}

rule("[brigitte/repair_pack.opy]: Increase Repair Pack healing")
{
	event
	{
		Player Dealt Healing;
		All;
		Brigitte;
	}

	conditions
	{
		Event Ability == Button(Ability 2);
	}

	actions
	{
		Heal(Healee, Healer, Event Healing * 1.250 - Event Healing);
	}
}

rule("[brigitte/repair_pack.opy]: Extra Repair Pack burst healing")
{
	event
	{
		Player Dealt Healing;
		All;
		Brigitte;
	}

	conditions
	{
		Event Ability == Button(Ability 2);
		Event Healing >= 19;
	}

	actions
	{
		Heal(Healee, Healer, 5);
	}
}

rule("[brigitte/init.opy]: Correct Whipshot damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Brigitte;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

disabled rule("[doomfist/init.opy]: initDoomfist()")
{
	event
	{
		Subroutine;
		initDoomfist;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 450;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1750;
		Call Subroutine(removeTankPassive);
		Event Player.macro_pvar[0] = 0.800;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.max_health_scaler = 0.625;
		Event Player.hero_initialized = True;
	}
}

rule("[doomfist/meteor_strike.opy]: Correct Meteor Strike and Doomfist melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Doomfist;
	}

	conditions
	{
		Array Contains(Array(Button(Melee), Button(Ultimate)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[doomfist/punch.opy]: Initialize rocket punch")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
	}

	actions
	{
		Event Player.macro_pvar[0] = 0.500;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.punched_victims = Empty Array;
		Event Player.wall_impacted_victims = Empty Array;
		Wait Until(!Is Firing Secondary(Event Player), 4);
		Wait(0.200, Ignore Condition);
		Event Player.macro_pvar[0] = 0.800;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("[doomfist/punch.opy]: Find wall impacted victims")
{
	event
	{
		Player Dealt Damage;
		All;
		Doomfist;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
		Array Contains(Attacker.punched_victims, Victim) == True;
		Array Contains(Attacker.wall_impacted_victims, Victim) == False;
	}

	actions
	{
		Modify Player Variable(Attacker, wall_impacted_victims, Append To Array, Victim);
		Clear Status(Victim, Stunned);
		"OW1 single punch victim"
		If(Count Of(Attacker.punched_victims) == 1);
			Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
		"OW2 multi-punch victim"
		Else;
	}
}

rule("[doomfist/punch.opy]: Find punched victims")
{
	event
	{
		Player Dealt Damage;
		All;
		Doomfist;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
		Array Contains(Attacker.punched_victims, Victim) == False;
	}

	actions
	{
		Modify Player Variable(Attacker, punched_victims, Append To Array, Victim);
		"OW1 single punch victim"
		If(Count Of(Attacker.punched_victims) == 1);
			Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
		"OW2 multi-punch victim"
		Else;
	}
}

rule("[doomfist/init.opy]: Correct Seismic Slam damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Doomfist;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) * 0.800 - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

disabled rule("[doomfist/powerblock.opy]: Reduce Power Block active duration")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(1.750, Ignore Condition);
		Press Button(Event Player, Button(Ability 2));
	}
}

rule("[doomfist/init.opy]: Correct Hand Cannon damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Doomfist;
	}

	conditions
	{
		Event Ability == Button(Primary Fire);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) * 0.910 - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[doomfist/meteorstrike.opy] Doomfist ult remove self healing")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Set Healing Dealt(Event Player, 0);
		Wait Until(!Is Using Ultimate(Event Player), 99999);
		Set Healing Dealt(Event Player, 100);
	}
}

rule("[dva/init.opy]: initDva()")
{
	event
	{
		Subroutine;
		initDva;
	}

	actions
	{
		"setCustomHp(\nADJ_DVA_HEALTH_DUPLICATE if eventPlayer.isDuplicatingAHero() or SETTING_ECHO_TANK_HP else ADJ_DVA_HEALTH,\nADJ_DVA_ARMOR_DUPLICATE if eventPlayer.isDuplicatingAHero() or SETTING_ECHO_TANK_HP else ADJ_DVA_ARMOR,\n0)"
		Event Player.ult_charge_pvar[1] = 1540;
		Call Subroutine(removeTankPassive);
		Event Player.macro_pvar[0] = 0.910;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.self_destruct_charge = 0;
		Event Player.max_health_scaler = 0.857;
		Wait Until(!Is In Alternate Form(Event Player), 999999986991104.000);
		Event Player.custom_hp_pvar[0] = 169;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.hero_initialized = True;
	}
}

rule("[dva/boosters.opy]: Reduce Boosters damage")
{
	event
	{
		Player Dealt Damage;
		All;
		D.Va;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
	}

	actions
	{
		Heal(Victim, Null, Event Damage - 0.800 * Event Damage / First Of(Event Player.macro_pvar));
	}
}

rule("[dva/defense_matrix.opy]: Increase Defense Matrix cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		D.Va;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		"Defense Matrix still goes on cooldown visually even when the ability is disabled, so a faux cooldown was not implemented"
		Wait Until(!Is Firing Secondary(Event Player), 999999986991104.000);
		Set Secondary Fire Enabled(Event Player, False);
		Wait(1.500, Ignore Condition);
		Set Secondary Fire Enabled(Event Player, True);
	}
}

rule("[dva/hp.opy]: Correct DVa mech health")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hero_setup == Hero(D.Va);
		Is In Alternate Form(Event Player) == False;
		Event Player.hero_initialized != False;
	}

	actions
	{
		Call Subroutine(clearCustomHp);
		Event Player.custom_hp_pvar[0] = 169;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
	}
}

rule("[dva/hp.opy]: Correct DVa pilot health")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hero_setup == Hero(D.Va);
		Is In Alternate Form(Event Player) == True;
		Max Health Of Type(Event Player, Health) != 150;
		Event Player.hero_initialized != False;
	}

	actions
	{
		Call Subroutine(clearCustomHp);
		Event Player.custom_hp_pvar[0] = 28;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
	}
}

rule("[dva/init.opy]: Reduce Micro Missiles damage")
{
	event
	{
		Player Dealt Damage;
		All;
		D.Va;
	}

	conditions
	{
		(Event Ability == Button(Ability 2)) == True;
	}

	actions
	{
		Heal(Victim, Null, Event Damage - 0.750 * Event Damage / First Of(Event Player.macro_pvar));
	}
}

rule("[dva/init.opy]: Increase D.va other forms of damage")
{
	event
	{
		Player Dealt Damage;
		All;
		D.Va;
	}

	conditions
	{
		Array Contains(Array(Button(Melee), Button(Ultimate)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[dva/init.opy]: Force reset ult charge when DVa exits Mech")
{
	event
	{
		Ongoing - Each Player;
		All;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == True;
	}

	actions
	{
		Abort If(Is Using Ultimate(Event Player));
		Set Ultimate Charge(Event Player, 0);
	}
}

rule("[echo/init.opy]: initEcho()")
{
	event
	{
		Subroutine;
		initEcho;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 125;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1880;
		Event Player.macro_pvar[0] = 0.833;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Start Scaling Player(Event Player, 0.940, True);
		Disallow Button(Event Player, Button(Ultimate));
		Event Player.macro_pvar[2] = 100;
		Set Move Speed(Event Player, 100);
		Event Player.hero_initialized = True;
	}
}

rule("[echo/init.opy]: Correct Echo Tri-Shot damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Echo;
	}

	conditions
	{
		Is Duplicating(Event Player) == False;
		Event Ability == Button(Primary Fire);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) * 0.971 - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[echo/init.opy]: Correct Echo other forms of damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Echo;
	}

	conditions
	{
		Array Contains(Array(Button(Melee), Button(Ability 2)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[echo/copy.opy] Echo new ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ultimate)) == True;
		Event Player.hero_setup == Hero(Echo);
	}

	actions
	{
		If(Is Alive(Event Player) == True && Ultimate Charge Percent(Event Player) == 100);
			All Players(Team Of(Event Player)).Echo_Copy = True;
			Start Forcing Player To Be Hero(Event Player, Hero Of(First Of(Sorted Array(Filtered Array(All Living Players(Opposite Team Of(
				Team Of(Event Player))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player),
				Current Array Element)) <= 19 && Has Spawned(Current Array Element) && Distance Between(Event Player, Current Array Element)
				<= 40 && Current Array Element != Players On Hero(Hero(Echo), All Teams) && Is In Line of Sight(Event Player,
				Current Array Element, Barriers Do Not Block LOS)), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(
				Eye Position(Event Player), Current Array Element))))));
			If(Hero Of(Event Player) != Hero(Echo));
				Set Status(Event Player, Null, Frozen, 1);
				Set Status(Event Player, Null, Phased Out, 1);
				Wait(1.100, Ignore Condition);
				Set Ultimate Charge(Event Player, 92);
				Call Subroutine(EchoCopy);
				Wait Until(!Is Alive(Event Player), 16);
				Destroy Progress Bar In-World Text(Event Player.text[17]);
				Stop Chasing Player Variable(Event Player, EchoUltSeconds);
				Start Forcing Player To Be Hero(Event Player, Hero(Echo));
				Stop Forcing Player To Be Hero(Event Player);
				All Players(Team Of(Event Player)).Echo_Copy = False;
				Event Player.hero_initialized = False;
				Set Status(Event Player, Null, Phased Out, 1);
	}
}

rule("[echo/ultimate.opy]: Sub for HUD")
{
	event
	{
		Subroutine;
		EchoCopy;
	}

	actions
	{
		Event Player.EchoUltSeconds = 100;
		Chase Player Variable At Rate(Event Player, EchoUltSeconds, 0, 6.250, Destination and Rate);
		Create Progress Bar In-World Text(Event Player, Event Player.EchoUltSeconds, Custom String("{0} {1}", Ability Icon String(Hero(
			Echo), Button(Ultimate)), Round To Integer(Event Player.EchoUltSeconds / 6.250, Up)), Update Every Frame(Eye Position(
			Event Player) + 100 * (-1 * World Vector Of(Right, Event Player, Rotation) + (-0.050 - 0.200) * Direction From Angles(
			Horizontal Angle From Direction(Facing Direction Of(Event Player)), Vertical Angle From Direction(Facing Direction Of(
			Event Player)) - 90) + 3 * Facing Direction Of(Event Player))), 0.750, Do Not Clip, Color(White), Color(White),
			Visible To Position Values and Color, Default Visibility);
		Event Player.text[17] = Last Text ID;
	}
}

rule("[echo/init.opy]: Clean up Echo")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hero_setup != Hero(Echo);
	}

	actions
	{
		Destroy Progress Bar In-World Text(Event Player.text[17]);
		Stop Chasing Player Variable(Event Player, EchoUltSeconds);
		All Players(Team Of(Event Player)).Echo_Copy = False;
		Event Player.text[17] = Null;
		Event Player.EchoUltSeconds = Null;
	}
}

rule("[freja/init.opy]: initFreja()")
{
	event
	{
		Subroutine;
		initFreja;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 200;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1750;
		Event Player.macro_pvar[0] = 0.667;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Start Scaling Player(Event Player, 0.960, True);
		Event Player.hero_initialized = True;
	}
}

rule("[freja/init.opy]: Correct Freja other forms of damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Freja;
	}

	conditions
	{
		Event Ability == Button(Melee);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[freja/init.opy]: Correct Freja secondary impact damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Freja;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
		Event Damage < 59;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[freja/init.opy]: Correct Freja ultimate impact damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Freja;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
		Wait(1.300, Ignore Condition);
	}
}

rule("[genji/init.opy]: initGenji()")
{
	event
	{
		Subroutine;
		initGenji;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 200;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1150;
		Event Player.hero_initialized = True;
	}
}

rule("[genji/dragonblade.opy]: Genji Damage in Ultimate 100 and reset deflect cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		Genji;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Set Damage Dealt(Event Player, 91);
		Wait Until(!Is Using Ultimate(Event Player), 6);
		Set Damage Dealt(Event Player, 100);
	}
}

rule("[genji/init.opy]: Reduce Deflect duration")
{
	event
	{
		Ongoing - Each Player;
		All;
		Genji;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(1.500, Ignore Condition);
		Press Button(Event Player, Button(Ability 2));
	}
}

rule("[hanzo/init.opy]: initHanzo()")
{
	event
	{
		Subroutine;
		initHanzo;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 200;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1680;
		Event Player.macro_pvar[0] = 0.600;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.hero_initialized = True;
	}
}

rule("[hanzo/weapon.opy]: Hanzo draw aura")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hanzo;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		"max draw time"
		disabled Wait(0.800, Abort When False);
		Create Effect(Filtered Array(All Players(Opposite Team Of(Team Of(Event Player))), Distance Between(Event Player,
			Current Array Element) >= 1 && Is In View Angle(Event Player, Eye Position(Current Array Element), 30)
			&& Current Array Element.Hanzo_Marked_icon == True), Good Aura, Custom Color(239, 47, 60, 125), Eye Position(Event Player),
			0.475, Visible To Position and Radius);
		Event Player.HanzoDrawAura = Last Created Entity;
		Wait Until(!Is Firing Primary(Event Player), 100000000);
		Destroy Effect(Event Player.HanzoDrawAura);
	}
}

rule("[hanzo/stormarrow.opy]: Correct Arrow speed Storm arrows (110ms)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hanzo;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Set Projectile Speed(Event Player, 200);
		Wait Until(!Is Using Ability 1(Event Player), 6);
		Set Projectile Speed(Event Player, 100);
	}
}

rule("[hanzo/init.opy]: Correct Hanzo other forms of damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Hanzo;
	}

	conditions
	{
		Array Contains(Array(Button(Melee), Button(Ultimate)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[hazard/init.opy]: initHazard()")
{
	event
	{
		Subroutine;
		initHazard;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 116;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2000;
		Event Player.macro_pvar[0] = 0.800;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Set Ability 2 Enabled(Event Player, False);
		Disallow Button(Event Player, Button(Ability 2));
		Event Player.hero_initialized = True;
	}
}

rule("[hazard/init.opy]: Increase Hazard melee, wall, ultimate damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Hazard;
	}

	conditions
	{
		Array Contains(Array(Button(Ability 2), Button(Ultimate), Button(Melee)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[hazard/spike_guard.opy] Increase damage on block to 230")
{
	event
	{
		Player Dealt Damage;
		All;
		Hazard;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
	}

	actions
	{
		Damage(Victim, Attacker, (0.940 * (Event Damage / First Of(Event Player.macro_pvar)) - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[hazard/violent_leap.opy] Increase damage violant leap to 70")
{
	event
	{
		Player Dealt Damage;
		All;
		Hazard;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
	}

	actions
	{
		Damage(Victim, Attacker, (0.813 * (Event Damage / First Of(Event Player.macro_pvar)) - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[hazard/downpour.opy]: hazard reveal enemies")
{
	event
	{
		Player Dealt Damage;
		All;
		Hazard;
	}

	conditions
	{
		Has Status(Victim, Rooted) == True;
		Event Ability == Button(Ultimate);
		Victim.Hazard_Downpour_Target == Null;
	}

	actions
	{
		Create In-World Text(Event Player, Custom String("{0} {1}m", Ability Icon String(Hero(Hazard), Button(Ultimate)), Round To Integer(
			Distance Between(Event Player, Victim), Up)), Victim + Vector(0, 2.500, 0), 1.500, Do Not Clip, Visible To Position and String,
			Color(White), Default Visibility);
		Victim.Hazard_Downpour_effect = Last Text ID;
		Victim.Hazard_Downpour_Target = True;
	}
}

rule("[hazard/downpour.opy]: hazard reset reveal enemies")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Hazard_Downpour_Target == True;
	}

	actions
	{
		Wait(2.500, Ignore Condition);
		Destroy In-World Text(Event Player.text[12]);
		Event Player.Hazard_Downpour_Target = Null;
		Event Player.text[12] = Null;
	}
}

rule("[hazard/init.opy]: Clean up Hazard")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hero_setup != Hero(Hazard);
	}

	actions
	{
		Event Player.hazard_bubble_target = Null;
		Destroy In-World Text(Event Player.text[16]);
		Event Player.Hazard_Bubble_Allowed = Null;
	}
}

rule("[illari/init.opy]: initIllari()")
{
	event
	{
		Subroutine;
		initIllari;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 0;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2450;
		Event Player.macro_pvar[0] = 0.750;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.macro_pvar[1] = 0.750;
		Set Healing Dealt(Event Player, 100 * Event Player.macro_pvar[1]);
		Event Player.max_health_scaler = 0.800;
		Event Player.hero_initialized = True;
	}
}

rule("[illari/solar_rifle.opy]: Correct Solar Rifle damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Illari;
	}

	conditions
	{
		Event Ability == Button(Primary Fire);
	}

	actions
	{
		If(Event Was Critical Hit);
			Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) * 1.143 - Event Damage) / First Of(
				Event Player.macro_pvar));
		Else;
			Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[illari/solar_rifle.opy]: Correct Solar Rifle healing")
{
	event
	{
		Ongoing - Each Player;
		All;
		Illari;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
	}

	actions
	{
		Set Healing Dealt(Event Player, 100);
		Wait Until(!Is Button Held(Event Player, Button(Secondary Fire)), 999999986991104.000);
		Set Healing Dealt(Event Player, 75);
	}
}

rule("[illari/init.opy]: Correct Outburst and melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Illari;
	}

	conditions
	{
		Array Contains(Array(Button(Melee), Button(Ability 1)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[illari/init.opy]: Correct Pylon self healing")
{
	event
	{
		Player Dealt Healing;
		All;
		Illari;
	}

	conditions
	{
		Healee == Healer;
	}

	actions
	{
		Heal(Healer, Null, Event Healing);
	}
}

rule("[junkerqueen/init.opy]: initJunkerQueen()")
{
	event
	{
		Subroutine;
		initJunkerQueen;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 157;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2300;
		Call Subroutine(removeTankPassive);
		Event Player.macro_pvar[0] = 0.875;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Set Healing Dealt(Event Player, 73.563);
		Set Knockback Dealt(Event Player, 64);
		Start Scaling Player(Event Player, 0.960, True);
		Set Max Ammo(Event Player, 0, 8);
		Set Ammo(Event Player, 0, 8);
		Event Player.overhealth_check = False;
		Event Player.max_health_scaler = 0.714;
		Event Player.hero_initialized = True;
	}
}

rule("[junkerqueen/carnage.opy]: Reduce Carnage damage")
{
	event
	{
		Ongoing - Each Player;
		All;
		Junker Queen;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Set Damage Dealt(Event Player, 85.714);
		Wait Until(!Is Using Ability 2(Event Player), 999999986991104.000);
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("[junkerqueen/commanding_shout.opy]: Prepare Commanding Shout ally tracking")
{
	event
	{
		Ongoing - Each Player;
		All;
		Junker Queen;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Remove From Array(Players Within Radius(Event Player, 15.500, Team Of(Event Player), Surfaces), Event Player)
			.within_shout_radius = True;
		disabled Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 3.800;
		disabled Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		disabled Wait(4.900, Ignore Condition);
		disabled Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 3.800;
		disabled Set Move Speed(Event Player, Event Player.macro_pvar[2]);
	}
}

rule("[junkerqueen/commanding_shout.opy]: increase overhealth for allies")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.within_shout_radius == True;
	}

	actions
	{
		disabled Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 3.800;
		disabled Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Add Health Pool To Player(Event Player, Health, 9.500, False, False);
		Event Player.Junkerqueen_overhealth = Last Created Health Pool;
		Wait(2.900, Ignore Condition);
		disabled Set Move Speed(Event Player, 100 * Event Player.macro_pvar[2] * 1.350);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 30;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Wait(1.900, Ignore Condition);
		disabled Set Move Speed(Event Player, 100 * Event Player.macro_pvar[2]);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 30;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Remove Health Pool From Player(Event Player.Junkerqueen_overhealth);
		Event Player.Junkerqueen_overhealth = Null;
		Event Player.within_shout_radius = False;
	}
}

rule("[junkerqueen/jagged_blade.opy]: Correct Jagged Blade impact damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Junker Queen;
	}

	conditions
	{
		Event Damage == 65 * First Of(Event Player.macro_pvar);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[junkerqueen/jagged_blade.opy]: Increase Jagged Blade pull distance on squishies")
{
	event
	{
		Player Dealt Knockback;
		All;
		Junker Queen;
	}

	conditions
	{
		Is Meleeing(Event Player) == False;
		Array Contains(All Tank Heroes, Hero Of(Victim)) == False;
	}

	actions
	{
		Apply Impulse(Victim, Vector(X Component Of(Normalize(Position Of(Event Player) - Position Of(Victim))), 0, Z Component Of(
			Normalize(Position Of(Event Player) - Victim))), 7.500, To World, Incorporate Contrary Motion);
	}
}

rule("[junkerqueen/rampage.opy]: Reduce Rampage damage")
{
	event
	{
		Ongoing - Each Player;
		All;
		Junker Queen;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Set Damage Dealt(Event Player, 83.333);
		Wait Until(!Is Using Ultimate(Event Player), 999999986991104.000);
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("[junkerqueen/init.opy]: Shout indicator")
{
	event
	{
		Ongoing - Each Player;
		All;
		Junker Queen;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Is Between Rounds == False;
	}

	actions
	{
		Create In-World Text(Event Player, Custom String("{0} {1}", Count Of(Filtered Array(All Living Players(Team Of(Event Player)),
			Distance Between(Event Player, Current Array Element) <= 15 && Is In Line of Sight(Event Player, Current Array Element,
			Barriers Do Not Block LOS) == True && Hero Of(Current Array Element) != Hero(Junker Queen))), Ability Icon String(Hero(
			Junker Queen), Button(Ability 1))), Update Every Frame(Eye Position(Event Player) + 100 * (0 * World Vector Of(Right,
			Event Player, Rotation) + -0.500 * Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)),
			Vertical Angle From Direction(Facing Direction Of(Event Player)) - 90) + 3 * Facing Direction Of(Event Player))), 2,
			Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
		Event Player.text[6] = Last Text ID;
		Wait Until(Is Using Ability 1(Event Player) == True, 99999);
		Destroy In-World Text(Event Player.text[6]);
		Event Player.text[6] = Null;
	}
}

rule("[junkerqueen/init.opy]: Clean up JQ")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hero_setup != Hero(Junker Queen);
	}

	actions
	{
		Destroy In-World Text(Event Player.text[6]);
	}
}

rule("[junkrat/init.opy]: initJunkrat()")
{
	event
	{
		Subroutine;
		initJunkrat;
	}

	actions
	{
		"Version or the \"resetHealth\" subroutine that keeps tire at 100 hp"
		disabled Remove All Health Pools From Player(Event Player);
		disabled Wait(0.016, Ignore Condition);
		"DO NOT REMOVE THIS LINE"
		disabled Set Max Health(Event Player, 100.001);
		"DO NOT REMOVE THIS LINE"
		disabled Wait(0.016, Ignore Condition);
		disabled Set Max Health(Event Player, 80);
		"eventPlayer.addHealthPool(Health.ARMOR, 1, true, true)\neventPlayer.addHealthPool(Health.SHIELDS, 1, true, true)\neventPlayer.removeAllHealthPools()\n#eventPlayer.addHealthPool(Health.NORMAL, 199, true, true)\nheal(eventPlayer, null, 1)"
		Call Subroutine(resetStats);
		Call Subroutine(resetStatuses);
		Call Subroutine(enableAllAbilities);
		Event Player.ult_charge_pvar[1] = 1925;
		Event Player.macro_pvar[0] = 0.875;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		"check mayhem.opy"
		Disallow Button(Event Player, Button(Ultimate));
		Event Player.hero_initialized = True;
	}
}

rule("[junkrat/mayhem.opy]: Correct Frag Launcher damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Junkrat;
	}

	conditions
	{
		Event Ability == Button(Primary Fire);
	}

	actions
	{
		"damage(victim, attacker, ((eventDamage/eventPlayer._base_damage_scalar)*(ADJ_JUNKRAT_FRAG_DAMAGE/OW2_JUNKRAT_FRAG_DAMAGE) - eventDamage)/eventPlayer._base_damage_scalar)"
		Heal(Victim, Null, (Event Damage / First Of(Event Player.macro_pvar) * 0.800 - Event Damage) * -1);
	}
}

rule("[junkrat/mayhem.opy]: Correct Junkrat Melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Junkrat;
	}

	conditions
	{
		Event Ability == Button(Melee);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[junkrat/mayhem.opy]: Correct Junkrat Trap damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Junkrat;
	}

	conditions
	{
		Event Ability == Button(Ability 2);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) * 0.900 - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[junkrat/mayhem.opy]: Reset damage for Rip-Tire")
{
	event
	{
		Ongoing - Each Player;
		All;
		Junkrat;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ultimate)) == True;
		Is On Ground(Event Player) == True;
		Ultimate Charge Percent(Event Player) >= 100;
	}

	actions
	{
		Set Damage Dealt(Event Player, 100);
		Allow Button(Event Player, Button(Ultimate));
		Press Button(Event Player, Button(Ultimate));
		Disallow Button(Event Player, Button(Ultimate));
		Wait(1, Ignore Condition);
		"revert damage back after Rip-Tire is deployed"
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("[junkrat/trap.opy]: junkrat reveal enemies")
{
	event
	{
		Player Dealt Damage;
		All;
		Junkrat;
	}

	conditions
	{
		Has Status(Victim, Rooted) == True;
		Event Ability == Button(Ability 2);
		Victim.Junkrat_Trap_target == Null;
	}

	actions
	{
		Create In-World Text(All Players(Team Of(Event Player)), Custom String("{0} {1}m", Ability Icon String(Hero(Junkrat), Button(
			Ability 2)), Round To Integer(Distance Between(Event Player, Victim), Up)), Victim + Vector(0, 2.500, 0), 1.500, Do Not Clip,
			Visible To Position and String, Color(White), Default Visibility);
		Victim.Junkrat_Trap_effect = Last Text ID;
		Victim.Junkrat_Trap_target = True;
	}
}

rule("[junkrat/trap.opy]: junkrat reset reveal enemies")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Junkrat_Trap_target == True;
	}

	actions
	{
		Wait(2.500, Ignore Condition);
		Destroy In-World Text(Event Player.Junkrat_Trap_effect);
		Event Player.Junkrat_Trap_target = Null;
		Event Player.Junkrat_Trap_effect = Null;
	}
}

rule("[juno/init.opy]: initJuno()")
{
	event
	{
		Subroutine;
		initJuno;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 87;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2850;
		Event Player.macro_pvar[0] = 0.867;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.macro_pvar[1] = 0.833;
		Set Healing Dealt(Event Player, 100 * Event Player.macro_pvar[1]);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 9.100;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Set Ammo(Event Player, 0, 120);
		Set Max Ammo(Event Player, 0, 120);
		Event Player.hero_initialized = True;
	}
}

rule("[juno/init.opy]: Correct Pulsar Torpedo healing and damage")
{
	event
	{
		Ongoing - Each Player;
		All;
		Juno;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Ability Cooldown(Event Player, Button(Secondary Fire)) < 0.100;
		Is Meleeing(Event Player) == False;
		Is Reloading(Event Player) == False;
	}

	actions
	{
		Set Healing Dealt(Event Player, 58.824);
		Set Damage Dealt(Event Player, 58.824);
		Wait Until(Ability Cooldown(Event Player, Button(Secondary Fire)) > 0, 4);
		Set Healing Dealt(Event Player, 100 * Event Player.macro_pvar[1]);
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("[juno/orbital_ray.opy]: Adjust Orbital Ray Healing")
{
	event
	{
		Ongoing - Each Player;
		All;
		Juno;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Asleep) == False;
		Has Status(Event Player, Frozen) == False;
		Has Status(Event Player, Knocked Down) == False;
		Has Status(Event Player, Stunned) == False;
	}

	actions
	{
		Wait(0.469, Ignore Condition);
		Event Player.orbital_ray_x = X Component Of(Position Of(Event Player) + 1.625 * Direction From Angles(Horizontal Facing Angle Of(
			Event Player), 0));
		Event Player.orbital_ray_z = Z Component Of(Position Of(Event Player) + 1.625 * Direction From Angles(Horizontal Facing Angle Of(
			Event Player), 0));
		Event Player.orbital_ray_final_x = X Component Of(Position Of(Event Player) + 24.125 * Direction From Angles(
			Horizontal Facing Angle Of(Event Player), 0));
		Event Player.orbital_ray_final_z = Z Component Of(Position Of(Event Player) + 24.125 * Direction From Angles(
			Horizontal Facing Angle Of(Event Player), 0));
		Chase Player Variable Over Time(Event Player, orbital_ray_x, Event Player.orbital_ray_final_x, 10, None);
		Chase Player Variable Over Time(Event Player, orbital_ray_z, Event Player.orbital_ray_final_z, 10, None);
		"createBeam(eventPlayer, Beam.GOOD, vect(eventPlayer.orbital_ray_x, 0.0, eventPlayer.orbital_ray_z), vect(eventPlayer.orbital_ray_x, 100.0, eventPlayer.orbital_ray_z), Color.WHITE, EffectReeval.POSITION_AND_RADIUS)"
		While(Is Using Ultimate(Event Player));
			Start Damage Over Time(Filtered Array(All Living Players(Team Of(Event Player)), Distance Between(Vector(
				Event Player.orbital_ray_x, 0, Event Player.orbital_ray_z), Vector(X Component Of(Position Of(Current Array Element)), 0,
				Z Component Of(Position Of(Current Array Element)))) < 8 && Health(Current Array Element) < Max Health(Current Array Element)
				&& Current Array Element.remainingAntiDuration <= 0), Null, 0.098, 19);
			Wait(0.098, Ignore Condition);
		End;
	}
}

rule("[juno/init.opy]: Correct Juno Melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Juno;
	}

	conditions
	{
		Event Ability == Button(Melee);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[juno/init.opy]: Correct Pulsar Torpedo healing over time")
{
	event
	{
		Player Dealt Healing;
		All;
		Juno;
	}

	conditions
	{
		Event Healing > 69;
	}

	actions
	{
		Start Damage Over Time(Healee, Null, 2.400, 10);
	}
}

rule("[kiriko/init.opy]: initKiriko()")
{
	event
	{
		Subroutine;
		initKiriko;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 0;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2100;
		Event Player.macro_pvar[0] = 0.867;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.macro_pvar[1] = 0.770;
		Set Healing Dealt(Event Player, 100 * Event Player.macro_pvar[1]);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 9.100;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Set Ability Cooldown(Event Player, Button(Ability 1), 5);
		Event Player.hero_initialized = True;
	}
}

rule("[kiriko/swift_step.opy]: Force swift step cooldown after spawning")
{
	event
	{
		Player Died;
		All;
		Kiriko;
	}

	actions
	{
		Wait Until(Is Alive(Event Player) && Is In Spawn Room(Event Player), 999999986991104.000);
		Set Ability Cooldown(Event Player, Button(Ability 1), 5);
	}
}

rule("[kiriko/swift_step.opy]: Heal when using Swift Step")
{
	event
	{
		Ongoing - Each Player;
		All;
		Kiriko;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		"grace period to allow SS to cleanse anti-heal effects"
		Wait(0.100, Ignore Condition);
		Start Heal Over Time(Event Player, Null, 0.250, 140 / Event Player.macro_pvar[1]);
	}
}

rule("[kiriko/init.opy]: Correct Kiriko melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Kiriko;
	}

	conditions
	{
		Event Ability == Button(Melee);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[lifeweaver/init.opy]: Initialize Lifeweaver")
{
	event
	{
		Subroutine;
		initLifeweaver;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 37.500;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 25;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2000;
		Event Player.macro_pvar[0] = 1.250;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Create In-World Text(Event Player, Custom String("{0}", Round To Integer(Event Player.Lifeweaver_petal_charges, Up)),
			Update Every Frame(Eye Position(Event Player) + 100 * (1.920 * World Vector Of(Right, Event Player, Rotation)
			+ -2.050 * Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)),
			Vertical Angle From Direction(Facing Direction Of(Event Player)) - 90) + 3 * Facing Direction Of(Event Player))), 3,
			Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
		Event Player.text[7] = Last Text ID;
		Create In-World Text(Event Player, Custom String("{0}", Round To Integer(Event Player.Lifeweaver_dash_charges, Up)),
			Update Every Frame(Eye Position(Event Player) + 100 * (2.535 * World Vector Of(Right, Event Player, Rotation)
			+ -2.050 * Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)),
			Vertical Angle From Direction(Facing Direction Of(Event Player)) - 90) + 3 * Facing Direction Of(Event Player))), 3,
			Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
		Event Player.text[8] = Last Text ID;
		Create In-World Text(Event Player, Custom String("{0} {1}", Round To Integer(Event Player.Lifeweaver_petal_charges, Up),
			Ability Icon String(Hero(Lifeweaver), Button(Ability 1))), Update Every Frame(Eye Position(Event Player) + 100 * (
			-0.220 * World Vector Of(Right, Event Player, Rotation) + -0.600 * Direction From Angles(Horizontal Angle From Direction(
			Facing Direction Of(Event Player)), Vertical Angle From Direction(Facing Direction Of(Event Player)) - 90)
			+ 3 * Facing Direction Of(Event Player))), 1.300, Do Not Clip, Visible To Position String and Color, Color(White),
			Default Visibility);
		Event Player.text[10] = Last Text ID;
		Create In-World Text(Event Player, Custom String("{0} {1}", Round To Integer(Event Player.Lifeweaver_dash_charges, Up),
			Ability Icon String(Hero(Lifeweaver), Button(Jump))), Update Every Frame(Eye Position(Event Player) + 100 * (
			0.220 * World Vector Of(Right, Event Player, Rotation) + -0.600 * Direction From Angles(Horizontal Angle From Direction(
			Facing Direction Of(Event Player)), Vertical Angle From Direction(Facing Direction Of(Event Player)) - 90)
			+ 3 * Facing Direction Of(Event Player))), 1.300, Do Not Clip, Visible To Position String and Color, Color(White),
			Default Visibility);
		Event Player.text[11] = Last Text ID;
		Event Player.Lifeweaver_petal_charges = 2;
		Event Player.Lifeweaver_dash_charges = 2;
		Set Max Ammo(Event Player, 0, 5);
		Set Ammo(Event Player, 0, 5);
		Event Player.hero_initialized = True;
	}
}

rule("[lifeweaver/init.opy]: Reduce Lifeweaver melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Lifeweaver;
	}

	conditions
	{
		Event Ability == Button(Melee);
	}

	actions
	{
		Heal(Victim, Null, Event Damage - Event Damage / First Of(Event Player.macro_pvar));
	}
}

rule("[lifeweaver/init.opy]: Reduce Tree of Life duration")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Wait(11, Ignore Condition);
		Press Button(Event Player, Button(Ultimate));
	}
}

rule("[lifeweaver/healing.opy]: Correct Healing ammount")
{
	event
	{
		Player Dealt Healing;
		All;
		Lifeweaver;
	}

	conditions
	{
		Event Ability != Button(Ultimate);
		Event Ability != Button(Ability 2);
		Event Player != Healee;
		Healee.Lifeweaver_healing_cd != True;
	}

	actions
	{
		Start Heal Over Time(Healee, Null, 4, 10);
		Healee.Lifeweaver_healing_cd = True;
		Wait(4, Ignore Condition);
		Healee.Lifeweaver_healing_cd = Null;
	}
}

rule("[lifeweaver/petalplatform.opy]: Lose charges and reset cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		Event Player.Lifeweaver_petal_charges != 0;
		Is Button Held(Event Player, Button(Ability 1)) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Event Player.Lifeweaver_petal_charges = Event Player.Lifeweaver_petal_charges - 1;
		If(Event Player.Lifeweaver_petal_charges != 0);
			disabled Wait Until(Is Using Ability 1(Event Player), 99999);
			Wait(0.250, Ignore Condition);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
	}
}

rule("[lifeweaver/petalplatform.opy]: recharge petal")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		Event Player.Lifeweaver_petal_charges != 2;
	}

	actions
	{
		Wait(12, Abort When False);
		Event Player.Lifeweaver_petal_charges = Event Player.Lifeweaver_petal_charges + 1;
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Loop If Condition Is True;
	}
}

rule("[lifeweaver/dash.opy]: Lose charges")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		(!Vertical Speed Of(Event Player) && !Is On Ground(Event Player)) == True;
	}

	actions
	{
		Wait(0.032, Abort When False);
		If(Distance Between(Event Player, Event Player + Velocity Of(Event Player)) >= 8);
			Event Player.Lifeweaver_dash_charges = Event Player.Lifeweaver_dash_charges - 1;
		Else;
			If(Distance Between(Event Player, Ray Cast Hit Position(Event Player, Event Player + Velocity Of(Event Player), Null, Null, True))
				<= 5);
				Event Player.Lifeweaver_dash_charges = Event Player.Lifeweaver_dash_charges - 1;
			End;
		End;
	}
}

rule("[lifeweaver/dash.opy]: Gain charges")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		Event Player.Lifeweaver_dash_charges != 2;
	}

	actions
	{
		Wait(6, Ignore Condition);
		Event Player.Lifeweaver_dash_charges = Event Player.Lifeweaver_dash_charges + 1;
		Loop If Condition Is True;
	}
}

rule("[lifeweaver/dash.opy]: Disable Dash")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		Event Player.Lifeweaver_dash_charges == 0;
		Is In Air(Event Player) == True;
	}

	actions
	{
		Disallow Button(Event Player, Button(Jump));
		Wait Until(Is On Ground(Event Player) == True || Event Player.Lifeweaver_dash_charges != 0, 99999);
		Allow Button(Event Player, Button(Jump));
	}
}

rule("[lifeweaver/dash.opy]: Silly charge Bug fix")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		Event Player.Lifeweaver_dash_charges > 2;
	}

	actions
	{
		Event Player.Lifeweaver_dash_charges = 2;
	}
}

rule("[lifeweaver/dash.opy]: Silly charge Bug fix 2")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		Event Player.Lifeweaver_dash_charges < 0;
	}

	actions
	{
		Event Player.Lifeweaver_dash_charges = 0;
	}
}

rule("[lifeweaver/grasp.opy] Set grasp cooldown to 10s when target is above 75%hp")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lifeweaver;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		If(Health(First Of(Sorted Array(Filtered Array(All Living Players(Team Of(Event Player)), Angle Between Vectors(
			Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)) <= 50 && Has Spawned(
			Current Array Element) && Distance Between(Event Player, Current Array Element)
			<= 30 && Current Array Element != Event Player && Is In Line of Sight(Event Player, Current Array Element,
			Barriers Do Not Block LOS)), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(
			Event Player), Current Array Element))))) >= Max Health(First Of(Sorted Array(Filtered Array(All Living Players(Team Of(
			Event Player)), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player),
			Current Array Element)) <= 50 && Has Spawned(Current Array Element) && Distance Between(Event Player, Current Array Element)
			<= 30 && Current Array Element != Event Player && Is In Line of Sight(Event Player, Current Array Element,
			Barriers Do Not Block LOS)), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(
			Event Player), Current Array Element))))) * 0.750);
			Wait Until(Is Using Ability 2(Event Player) == False, 99999);
			Set Ability Cooldown(Event Player, Button(Ability 2), 10);
		End;
	}
}

rule("[lifeweaver/init.opy]: Clean up lifeweaver")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hero_setup != Hero(Lifeweaver);
	}

	actions
	{
		Destroy In-World Text(Event Player.text[7]);
		Destroy In-World Text(Event Player.text[8]);
		Destroy In-World Text(Event Player.text[9]);
		Destroy In-World Text(Event Player.text[10]);
		Destroy In-World Text(Event Player.text[11]);
	}
}

rule("[lucio/init.opy]: initLucio()")
{
	event
	{
		Subroutine;
		initLucio;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 200;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2940;
		Event Player.macro_pvar[0] = 0.444;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Start Scaling Player(Event Player, 0.960, True);
		Event Player.hero_initialized = True;
	}
}

rule("[lucio/init.opy]: Correct Lucio melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Lúcio;
	}

	conditions
	{
		Event Ability == Button(Melee);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[lucio/init.opy]: Correct Sonic Amplifier damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Lúcio;
	}

	conditions
	{
		Event Ability == Button(Primary Fire);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) * 0.909 - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[mauga/init.opy]: initMauga()")
{
	event
	{
		Subroutine;
		initMauga;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 21;
		Event Player.custom_hp_pvar[1] = 50;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2650;
		Call Subroutine(removeTankPassive);
		Event Player.macro_pvar[0] = 0.750;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.balance_change_check = False;
		Event Player.hero_initialized = True;
	}
}

rule("[mauga/cardiac.opy]: Cardiac Use Ability")
{
	event
	{
		Ongoing - Each Player;
		All;
		Mauga;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Add Health Pool To Player(Event Player, Health, 150, False, True);
		Event Player.Mauga_Overdrive_Health = Last Created Health Pool;
		Event Player.macro_pvar[3] = Event Player.macro_pvar[3] + 40;
		Set Damage Received(Event Player, Event Player.macro_pvar[3]);
		Wait(3, Ignore Condition);
		Remove Health Pool From Player(Event Player.Mauga_Overdrive_Health);
		Event Player.macro_pvar[3] = Event Player.macro_pvar[3] - 40;
		Set Damage Received(Event Player, Event Player.macro_pvar[3]);
	}
}

rule("[mauga/cardiac.opy]: Mauga Heal Others")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 2(Players On Hero(Hero(Mauga), Team Of(Event Player))) == True;
		Distance Between(Event Player, Players On Hero(Hero(Mauga), Team Of(Event Player))) <= 10.500;
	}

	actions
	{
		Start Heal Over Time(Event Player, Players On Hero(Hero(Mauga), Team Of(Event Player)), 3, 40);
		Event Player.Cardiac_overdrive_active = Last Heal Over Time ID;
		Wait Until(Is Using Ability 2(Players On Hero(Hero(Mauga), Team Of(Event Player))) == False, 3);
		Stop Heal Over Time(Event Player.Cardiac_overdrive_active);
	}
}

rule("[mauga/cage.opy]: Reduce Cage Fight duration")
{
	event
	{
		Ongoing - Each Player;
		All;
		Mauga;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Wait(6, Ignore Condition);
		Press Button(Event Player, Button(Ultimate));
	}
}

rule("[mauga/init.opy]: Increase Mauga melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Mauga;
	}

	conditions
	{
		Array Contains(Array(Button(Melee)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[mauga/overrun.opy]: Reduce Mauga stomp damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Mauga;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
	}

	actions
	{
		Heal(Victim, Null, Event Damage - 0.667 * Event Damage / First Of(Event Player.macro_pvar));
	}
}

rule("[mauga/overrun.opy]: Overrun logic")
{
	event
	{
		Ongoing - Each Player;
		All;
		Mauga;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 10;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Event Player.macro_pvar[3] = Event Player.macro_pvar[3] + 50;
		Set Damage Received(Event Player, Event Player.macro_pvar[3]);
		Wait(0.320, Ignore Condition);
		Wait Until(!Is Using Ability 1(Event Player) || Is Button Held(Event Player, Button(Primary Fire)) == True || Is Button Held(
			Event Player, Button(Jump)) == True, 2.600);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 10;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Event Player.macro_pvar[3] = Event Player.macro_pvar[3] - 50;
		Set Damage Received(Event Player, Event Player.macro_pvar[3]);
	}
}

rule("[mauga/overrun.opy]: Doomfist punch track")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.DoomPunchTrack = False;
		Wait Until(!Is Button Held(Event Player, Button(Secondary Fire)) || !Is Firing Secondary(Event Player), 1.600);
		Event Player.DoomPunchTrack = True;
	}
}

rule("[mauga/overrun.opy]: Reinhardt charge track")
{
	event
	{
		Ongoing - Each Player;
		All;
		Reinhardt;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Event Player.ReinChargeTrack = True;
		Wait Until(!Is Using Ability 1(Event Player), 5);
		Event Player.ReinChargeTrack = False;
	}
}

rule("[mauga/overrun.opy]: Mauga overrun knockdown")
{
	event
	{
		Player Dealt Damage;
		All;
		Mauga;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
		((Hero Of(Victim) == Hero(Reinhardt) && Victim.ReinChargeTrack) || (Hero Of(Victim) == Hero(Doomfist) && Is Firing Secondary(
			Victim) && Victim.DoomPunchTrack) || (Hero Of(Victim) == Hero(Brigitte) && Is Firing Secondary(Victim) && Is Firing Primary(
			Victim))) == True;
		(Absolute Value(Angle Difference(Horizontal Facing Angle Of(Event Player), Horizontal Facing Angle Of(Victim) * -1)) <= 90)
			== True;
	}

	actions
	{
		Cancel Primary Action(Event Player);
		Set Status(Event Player, Victim, Knocked Down, 1.700);
		Set Status(Victim, Event Player, Knocked Down, 1.700);
		Wait(0.090, Ignore Condition);
		Apply Impulse(Victim, Velocity Of(Victim) * -1, 0.001, To World, Cancel Contrary Motion);
	}
}

rule("[mccree/init.opy]: initMccree()")
{
	event
	{
		Subroutine;
		initMccree;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 1;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1680;
		Event Player.macro_pvar[0] = 0.667;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.hero_initialized = True;
	}
}

rule("[mccree/deadeye.opy]: Set damage during deadeye")
{
	event
	{
		Ongoing - Each Player;
		All;
		Cassidy;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Set Damage Dealt(Event Player, 100);
		Wait Until(!Is Using Ultimate(Event Player), 999999986991104.000);
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("[mccree/init.opy]: Correct Cassidy melee damage and gun damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Cassidy;
	}

	conditions
	{
		Array Contains(Array(Button(Melee), Button(Primary Fire)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[mccree/fanthehammer.opy]: Increase Fan the hammer damage to 40")
{
	event
	{
		Player Dealt Damage;
		All;
		Cassidy;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
	}

	actions
	{
		Damage(Victim, Attacker, (0.800 * (Event Damage / First Of(Event Player.macro_pvar)) - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[mccree/flashbang.opy] Flashbang stun target for 0.4s")
{
	event
	{
		Player Dealt Damage;
		All;
		Cassidy;
	}

	conditions
	{
		Event Ability == Button(Ability 2);
	}

	actions
	{
		Set Status(Victim, Event Player, Stunned, 0.400);
	}
}

rule("[mei/init.opy]: initMei()")
{
	event
	{
		Subroutine;
		initMei;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 10;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1610;
		Event Player.macro_pvar[0] = 0.882;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.max_health_scaler = 0.800;
		Event Player.hero_initialized = True;
	}
}

disabled rule("[mei/init.opy]: Initialize Mei TANK")
{
	event
	{
		Subroutine;
		initMei;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 70;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2800;
		Event Player.macro_pvar[0] = 0.660;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Start Scaling Player(Event Player, 1.150, True);
		Event Player.hero_initialized = True;
		Event Player.max_health_scaler = 1.100;
	}
}

rule("[mei/init.opy]: Reduce Headshot damage taken Mei")
{
	event
	{
		Player Took Damage;
		All;
		Mei;
	}

	conditions
	{
		Event Was Critical Hit == True;
	}

	actions
	{
		Heal(Event Player, Null, Event Damage * 0.300);
	}
}

disabled rule("[mei/endothermic.opy]: AOE Damage Mei")
{
	event
	{
		Player Dealt Damage;
		All;
		Mei;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
	}

	actions
	{
		Play Effect(All Players(All Teams), Bad Explosion, Color(Sky Blue), Victim, 2);
		Play Effect(All Players(All Teams), Ring Explosion, Color(Aqua), Victim, 5);
		Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Sky Blue), Event Player, 40);
		Damage(Players Within Radius(Victim, 5, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers), Attacker, 25);
	}
}

rule("[mei/wall.opy]: Wall cooldown seconds Mei")
{
	event
	{
		Ongoing - Each Player;
		All;
		Mei;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait Until(Is Button Held(Event Player, Button(Primary Fire)) == True || Is Button Held(Event Player, Button(Secondary Fire))
			== True, 99999);
		If(Is Button Held(Event Player, Button(Primary Fire)) == True);
			Wait Until(Is Using Ability 2(Event Player) == False, 99999);
			Set Ability Cooldown(Event Player, Button(Ability 2), 10);
	}
}

rule("[mei/cryo_freeze.opy]: OW1 Cryo-Freeze healing set to 80 otherwise for tank mei set to 120")
{
	event
	{
		Ongoing - Each Player;
		All;
		Mei;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Set Healing Received(Event Player, 80);
		Wait Until(!Is Using Ability 1(Event Player), 999999986991104.000);
		Set Healing Received(Event Player, 100);
	}
}

rule("[mei/init.opy]: Increase Mei other forms of damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Mei;
	}

	conditions
	{
		Array Contains(Array(Button(Primary Fire), Button(Melee)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[mercy/init.opy]: initMercy()")
{
	event
	{
		Subroutine;
		initMercy;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 200;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2000;
		Event Player.macro_pvar[0] = 1.100;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.macro_pvar[1] = 0.917;
		Set Healing Dealt(Event Player, 100 * Event Player.macro_pvar[1]);
		Set Ammo(Event Player, 0, 20);
		Set Max Ammo(Event Player, 0, 20);
		Set Ability 2 Enabled(Event Player, False);
		Event Player.hero_initialized = True;
	}
}

rule("[mercy/imbue.opy]: Mercy imbue AOE")
{
	event
	{
		Ongoing - Each Player;
		All;
		Mercy;
	}

	conditions
	{
		(Event Player.ImbueDuration > 0 && Event Player.ImbueTarget != Null) == True;
	}

	actions
	{
		"Aura visuals"
		Create Effect(All Players(Event Player.ImbueSecondary ? All Teams : Team Of(Event Player)), Ring, Event Player.ImbueSecondary ? (
			Team Of(Event Player) == Team 1 ? Color(Team 1) : Color(Team 2)) : Color(Yellow), Event Player.ImbueTarget,
			Event Player.ImbueSecondary ? 8 : 10, Visible To Position and Radius);
		Event Player.ImbueAOERing = Last Created Entity;
		If(Event Player.ImbueSecondary);
			Create Effect(All Players(Team Of(Event Player)), Energy Sound, Color(White), Event Player.ImbueTarget, 80,
				Visible To Position and Radius);
		Else;
			Create Effect(All Players(Team Of(Event Player)), Sparkles Sound, Color(White), Event Player.ImbueTarget, 80,
				Visible To Position and Radius);
		End;
		Event Player.ImbueAOESound = Last Created Entity;
		"AoE"
		While(Is Alive(Event Player.ImbueTarget) == True && Event Player.ImbueDuration > 0);
			"30 dps for 3 seconds"
			If(Event Player.ImbueSecondary);
				If(Event Player.ImbueSecondary == 2 && !Is In Alternate Form(Event Player));
					Break;
				End;
				Start Damage Over Time(Players Within Radius(Event Player.ImbueTarget, 8, Opposite Team Of(Team Of(Event Player)),
					Surfaces And Enemy Barriers), Event Player, 0.500, 30 / First Of(Event Player.macro_pvar));
			"12 hps for 5 seconds"
			Else;
				Heal(Event Player.ImbueTarget, Event Player, 4 / Event Player.macro_pvar[1]);
				Heal(Remove From Array(Players Within Radius(Event Player.ImbueTarget, 10, Team Of(Event Player), Surfaces And Enemy Barriers),
					Event Player.ImbueTarget), Event Player, 6 / Event Player.macro_pvar[1]);
			End;
			Wait Until(Is Alive(Event Player.ImbueTarget) == False || Event Player.ImbueDuration == 0, 0.500);
		End;
		Destroy Effect(Event Player.ImbueAOERing);
		Destroy Effect(Event Player.ImbueAOESound);
		Stop Chasing Player Variable(Event Player, ImbueDuration);
		Event Player.ImbueTarget = Null;
	}
}

rule("[mercy/valkyrie]: Mercy give one rez charge")
{
	event
	{
		Ongoing - Each Player;
		All;
		Mercy;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Event Player.Mercy_Rez_charges = 1;
		Wait Until(Is Using Ultimate(Event Player) == False, 16);
		Event Player.Mercy_Rez_charges = Null;
	}
}

rule("[mercy/init.opy]: Reduce Valkyrie healing and force self-healing")
{
	event
	{
		Ongoing - Each Player;
		All;
		Mercy;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Stop All Heal Over Time(Event Player);
		Start Heal Over Time(Event Player, Null, 15, 20);
		Heal(Event Player, Null, 50);
		Set Healing Dealt(Event Player, 138.462);
		Wait(2, Ignore Condition);
		Set Healing Dealt(Event Player, 92.308);
		Wait Until(!Is Using Ultimate(Event Player), 999999986991104.000);
		Set Healing Dealt(Event Player, 100 * Event Player.macro_pvar[1]);
	}
}

rule("[mercy/init.opy]: Mercy swap hero")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Hero Of(Event Player) != Hero(Mercy) && Has Spawned(Event Player)) == True;
	}

	actions
	{
		Allow Button(Event Player, Button(Ultimate));
		Destroy HUD Text(Event Player.RezHUD);
		Destroy In-World Text(Event Player.ImbueTargetIcon);
		Event Player.MercyUltTrack = 0;
		Destroy Effect(Event Player.ImbueAOERing);
		Destroy Effect(Event Player.ImbueAOESound);
		Destroy Effect(Event Player.ImbueBeam);
		Destroy Effect(Event Player.ImbueSparkle);
		Event Player.ImbueTargetIcon = Null;
		Event Player.RezHUD = Null;
		Event Player.ImbueTarget = Null;
	}
}

rule("[moira/init.opy]: initMoira()")
{
	event
	{
		Subroutine;
		initMoira;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 200;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2800;
		Event Player.macro_pvar[0] = 0.923;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.hero_initialized = True;
	}
}

rule("[moira/coalescence.opy]: Prevent fading during Coalescence")
{
	event
	{
		Ongoing - Each Player;
		All;
		Moira;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Set Damage Dealt(Event Player, 82.353);
		Wait Until(!Is Using Ultimate(Event Player), 999999986991104.000);
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("[moira/init.opy]: Increase Moira other forms of damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Moira;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == False;
		Array Contains(Array(Button(Melee), Button(Ability 2)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[orisa/init.opy]: initOrisa()")
{
	event
	{
		Subroutine;
		initOrisa;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 121;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1814;
		Call Subroutine(removeTankPassive);
		Event Player.macro_pvar[0] = 0.858;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Set Knockback Dealt(Event Player, 82);
		Event Player.Orisa_Ammo = 100;
		Create Progress Bar In-World Text(Event Player, Event Player.Orisa_heat, Custom String("Heat"), Update Every Frame(Eye Position(
			Event Player) + 100 * (0 * World Vector Of(Right, Event Player, Rotation) + (-0.500 - 0.200) * Direction From Angles(
			Horizontal Angle From Direction(Facing Direction Of(Event Player)), Vertical Angle From Direction(Facing Direction Of(
			Event Player)) - 90) + 3 * Facing Direction Of(Event Player))), 0.700, Do Not Clip, Color(Orange), Color(Orange),
			Visible To Position Values and Color, Default Visibility);
		Event Player.text[21] = Last Text ID;
		Create In-World Text(Event Player, Custom String("{0}", Round To Integer(Event Player.Orisa_Ammo, Up)), Update Every Frame(
			Eye Position(Event Player) + 100 * (3.350 * World Vector Of(Right, Event Player, Rotation) + -1.500 * Direction From Angles(
			Horizontal Angle From Direction(Facing Direction Of(Event Player)), Vertical Angle From Direction(Facing Direction Of(
			Event Player)) - 90) + 3 * Facing Direction Of(Event Player))), 2, Do Not Clip, Visible To Position String and Color, Color(
			White), Default Visibility);
		Event Player.text[22] = Last Text ID;
		"if not eventPlayer.isDuplicatingAHero():\nsetBaseDamage(eventPlayer, ADJ_ORISA_JAVELIN_DIRECT_DAMAGE / OW2_ORISA_JAVELIN_DIRECT_DAMAGE)"
		Event Player.balance_change_check = True;
		Event Player.hero_initialized = True;
	}
}

rule("[orisa/init.opy]: Correct Orisa Spin, Melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Orisa;
	}

	conditions
	{
		Array Contains(Array(Button(Ability 1), Button(Ability 2), Button(Melee)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[orisa/init.opy]: Correct Orisa Javelin damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Orisa;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
	}

	actions
	{
		Damage(Victim, Attacker, (0.929 * (Event Damage / First Of(Event Player.macro_pvar)) - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("Orisa heat refresh")
{
	event
	{
		Ongoing - Each Player;
		All;
		Orisa;
	}

	conditions
	{
		Is Firing Primary(Event Player) == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Chase Player Variable At Rate(Event Player, Orisa_heat, 0, 25, Destination and Rate);
		Wait Until(Is Firing Primary(Event Player) == True, 99999);
		Stop Chasing Player Variable(Event Player, Orisa_heat);
	}
}

rule("[orisa/energy_javelin.opy]: Increase damage from 60 to 65")
{
	event
	{
		Player Dealt Damage;
		All;
		Orisa;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
	}

	actions
	{
		Damage(Victim, Event Player, 5);
	}
}

rule("[orisa/terra_surge.opy]: Reduce Terra Surge base damage and add bonus overhealth")
{
	event
	{
		Ongoing - Each Player;
		All;
		Orisa;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Add Health Pool To Player(Event Player, Health, 181, False, True);
		Event Player.terra_overhealth_id = Last Created Health Pool;
		Set Damage Dealt(Event Player, 80);
		Wait Until(!Is Using Ultimate(Event Player), 999999986991104.000);
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Remove Health Pool From Player(Event Player.terra_overhealth_id);
	}
}

rule("[orisa/terra_surge.opy]: Increase Terra Surge damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Orisa;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
		"do not include wind-up damage"
		Event Damage >= 50;
	}

	actions
	{
		Damage(Victim, Attacker, 100 - Event Damage);
	}
}

rule("[orisa/fortify.opy]: -10% damage reduction and shorter cooldown = 10s")
{
	event
	{
		Ongoing - Each Player;
		All;
		Orisa;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		"I don't know where this value comes from or how to calculate it"
		Damage(Event Player, Null, 125.700);
		Event Player.Orisa_fortified = True;
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 10;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Event Player.macro_pvar[3] = Event Player.macro_pvar[3] + 30;
		Set Damage Received(Event Player, Event Player.macro_pvar[3]);
		Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), Event Player, 8);
		Create Effect(All Players(All Teams), Ring, Color(Orange), Event Player, 8, Visible To Position and Radius);
		Event Player.Orisa_ring_effect = Last Created Entity;
		Wait Until(Is Using Ability 1(Event Player) == False, 99999);
		Set Ability Cooldown(Event Player, Button(Ability 1), 10);
		Event Player.macro_pvar[3] = Event Player.macro_pvar[3] - 30;
		Destroy Effect(Event Player.Orisa_ring_effect);
		Set Damage Received(Event Player, Event Player.macro_pvar[3]);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 10;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Event Player.Orisa_fortified = Null;
	}
}

rule("[orisa/fortify.opy]: Orisa Fortify others by 20%")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ability 1(Players On Hero(Hero(Orisa), Team Of(Event Player))) == True;
		Distance Between(Event Player, Players On Hero(Hero(Orisa), Team Of(Event Player))) < 8;
	}

	actions
	{
		Event Player.macro_pvar[3] = Event Player.macro_pvar[3] - 20;
		Set Damage Received(Event Player, Event Player.macro_pvar[3]);
		Wait Until(Distance Between(Event Player, Players On Hero(Hero(Orisa), Team Of(Event Player))) > 8 || Is Using Ability 1(
			Players On Hero(Hero(Orisa), Team Of(Event Player))) == False, 99999);
		Event Player.macro_pvar[3] = Event Player.macro_pvar[3] + 20;
		Set Damage Received(Event Player, Event Player.macro_pvar[3]);
	}
}

rule("[orisa/fortify.opy]: Orisa cancel fortify after 3s")
{
	event
	{
		Ongoing - Each Player;
		All;
		Orisa;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Wait(3, Ignore Condition);
		Press Button(Event Player, Button(Ability 1));
	}
}

rule("[orisa/fortify.opy]: Orisa cancel spin after 1s")
{
	event
	{
		Ongoing - Each Player;
		All;
		Orisa;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Set Damage Dealt(Event Player, 100);
		Wait Until(!Is Using Ability 2(Event Player), 1);
		Press Button(Event Player, Button(Ability 2));
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("[orisa/spin.opy]: Movementspeed increase during Spin")
{
	event
	{
		Ongoing - Each Player;
		All;
		Orisa;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait Until(Is Using Ability 2(Event Player) == False, 99999);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 35;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Wait(1, Ignore Condition);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 35;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
	}
}

rule("[orisa/init.opy]: Clean up Orisa")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hero_setup != Hero(Orisa);
	}

	actions
	{
		Destroy Effect(Event Player.Orisa_ring_effect);
		Event Player.Orisa_Ammo = Null;
		Destroy Progress Bar In-World Text(Event Player.text[21]);
		Destroy In-World Text(Event Player.text[22]);
	}
}

rule("[pharah/init.opy]: initPharah()")
{
	event
	{
		Subroutine;
		initPharah;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 0;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2100;
		Event Player.hero_initialized = True;
	}
}

rule("[ramattra/init.opy]: initRamattra()")
{
	event
	{
		Subroutine;
		initRamattra;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 166;
		Event Player.custom_hp_pvar[1] = 12;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2016;
		Call Subroutine(removeTankPassive);
		disabled Event Player.macro_pvar[0] = 1;
		disabled Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.max_health_scaler = 0.632;
		Event Player.hero_initialized = True;
	}
}

rule("[ramattra/nemesis_form.opy]: Correct Nemesis Form armor and movement speed")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ramattra;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Start Scaling Player(Event Player, 0.970, True);
		Set Damage Dealt(Event Player, 92.308);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 16.600;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		"for some reason the addHealthPool function doesn't read constants as usable numbers"
		Add Health Pool To Player(Event Player, Armor, 11, True, False);
		Event Player.Nemesis_armor = Last Created Health Pool;
		Wait Until(!Is Using Ability 1(Event Player), 999999986991104.000);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 16.600;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Stop Scaling Player(Event Player);
		Remove Health Pool From Player(Event Player.Nemesis_armor);
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("[ramattra/nemesis_form.opy]: Increase other forms of damage (in nemesis)")
{
	event
	{
		Player Dealt Damage;
		All;
		Ramattra;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		"This condition stops pummel from applying the damage increase"
		Event Damage < 60;
	}

	actions
	{
		Damage(Victim, Null, (Event Damage / 0.923 - Event Damage) / 0.923);
	}
}

rule("[reaper/init.opy]: initReaper()")
{
	event
	{
		Subroutine;
		initReaper;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 0;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1900;
		Event Player.macro_pvar[0] = 0.981;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.macro_pvar[1] = 1.200;
		Set Healing Dealt(Event Player, 100 * Event Player.macro_pvar[1]);
		Event Player.hero_initialized = True;
	}
}

rule("[reaper/init.opy]: Increase Reaper melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Reaper;
	}

	conditions
	{
		Event Ability == Button(Melee);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[reaper/init.opy]: Reduce Death Blossom damage")
{
	event
	{
		Ongoing - Each Player;
		All;
		Reaper;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Set Damage Dealt(Event Player, 91.892);
		Wait Until(!Is Using Ultimate(Event Player), 999999986991104.000);
		Set Damage Dealt(Event Player, 98.148);
	}
}

rule("[reinhardt/init.opy]: initReinhardt()")
{
	event
	{
		Subroutine;
		initReinhardt;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 0;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1460;
		Event Player.macro_pvar[0] = 0.850;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Set Knockback Received(Event Player, 93.333);
		Stop Forcing Throttle(Event Player);
		Event Player.hero_initialized = True;
	}
}

rule("[reinhardt/pin.opy]: Slow Reinhardt after pin")
{
	event
	{
		Ongoing - Each Player;
		All;
		Reinhardt;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Wait Until(Is Using Ability 1(Event Player) == False, 99999);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 50;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Wait(1, Ignore Condition);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 50;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
	}
}

rule("[reinhardt/firestrike.opy]: Force single firestrike")
{
	event
	{
		Ongoing - Each Player;
		All;
		Reinhardt;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait Until(!Is Using Ability 2(Event Player), 0.900);
		"Every time rein uses firestrike, reset the resource to 0"
		Set Ability Charge(Event Player, Button(Ability 2), 0);
		Wait(6, Ignore Condition);
		Set Ability Charge(Event Player, Button(Ability 2), 2);
	}
}

rule("[reinhardt/firestrike.opy]: decrease Firestrike damage (early animation)")
{
	event
	{
		Ongoing - Each Player;
		All;
		Reinhardt;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Set Damage Dealt(Event Player, 83.333);
		Wait(1, Ignore Condition);
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("[reinhardt/charge.opy]: Correct Charge damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Reinhardt;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
	}

	actions
	{
		"Checks for pin vs boop damage (+ 1 because apparently 50.0 > 50 == true for whatever reason)"
		If(Event Damage > 51);
			Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
		Else;
			Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[reinhardt/shatter.opy]: Correct Earthshatter damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Reinhardt;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
		Event Was Critical Hit == False;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[reinhardt/shatter.opy]: Correct Earthshatter critical damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Reinhardt;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
		Event Was Critical Hit == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[roadhog/init.opy]: initRoadhog()")
{
	event
	{
		Subroutine;
		initRoadhog;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 550;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2380;
		Call Subroutine(removeTankPassive);
		Event Player.macro_pvar[0] = 0.831;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Set Ammo(Event Player, 0, 6);
		Set Max Ammo(Event Player, 0, 6);
		Event Player.hero_initialized = True;
	}
}

rule("[roadhog/pigpen.opy]: Cancel Pigpen Animation")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(0.080, Ignore Condition);
		Cancel Primary Action(Event Player);
	}
}

rule("[roadhog/pigpen.opy]: Target Teammate")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Event Player.Roadhog_vape_target = First Of(Sorted Array(Filtered Array(All Living Players(Team Of(Event Player)),
			Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element))
			<= 30 && Has Spawned(Current Array Element) && Distance Between(Event Player, Current Array Element)
			<= 30 && Current Array Element != Event Player && Is In Line of Sight(Event Player, Current Array Element,
			Barriers Do Not Block LOS)), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(
			Event Player), Current Array Element))));
		Wait(0.160, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[roadhog/pigpen.opy]: Target Teammate HUD and allow Vape")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Event Player.Roadhog_vape_target != Null;
	}

	actions
	{
		"targeting hud"
		Create In-World Text(Event Player.Roadhog_vape_target != Null && Ability Cooldown(Event Player, Button(Ability 2))
			== 0 ? Event Player : Null, Custom String(" \n\n\n\n\n\n     ︿\n〈      〉\n     ﹀ "), Event Player.Roadhog_vape_target + Vector(
			0, 0.700, 0), 2, Do Not Clip, Visible To Position and String, Custom Color(55, 230, 255, 210), Default Visibility);
		Event Player.text[5] = Last Text ID;
		Allow Button(Event Player, Button(Ability 2));
	}
}

rule("[roadhog/pigpen.opy]: Disallow Vape")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Event Player.Roadhog_vape_target == Null;
	}

	actions
	{
		Disallow Button(Event Player, Button(Ability 2));
		Destroy In-World Text(Event Player.text[5]);
	}
}

rule("[roadhog/pigpen.opy]: Confirm Target")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Event Player.Roadhog_vape_target.Roadhog_vape_confirmed = True;
	}
}

rule("[roadhog/pigpen.opy]: Buff Teammate and play effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Roadhog_vape_confirmed == True;
	}

	actions
	{
		Event Player.Roadhog_vape_confirmed = False;
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element != Event Player), Cloud, Color(Yellow), Event Player,
			0.900, Visible To Position and Radius);
		Event Player.Roadhog_vape_effect = Last Created Entity;
		Players On Hero(Hero(Roadhog), Team Of(Event Player)).Roadhog_vape_target = Null;
		Event Player.Roadhog_vape_hud_icon = True;
		Big Message(Event Player, Custom String("VAPED"));
		Play Effect(All Players(All Teams), Explosion Sound, Color(White), Event Player, 80);
		Start Heal Over Time(Event Player, Players On Hero(Hero(Roadhog), Team Of(Event Player)), 3, 55);
		Event Player.macro_pvar[3] = Event Player.macro_pvar[3] - 40;
		Set Damage Received(Event Player, Event Player.macro_pvar[3]);
		Wait Until(!Is Alive(Event Player) || Event Player.hero_initialized == False, 3);
		Event Player.macro_pvar[3] = Event Player.macro_pvar[3] + 40;
		Set Damage Received(Event Player, Event Player.macro_pvar[3]);
		Destroy Effect(Event Player.Roadhog_vape_effect);
		Event Player.Roadhog_vape_hud_icon = Null;
	}
}

rule("[roadhog/breather.opy]: Adjust Breather efficacy")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Set Healing Dealt(Event Player, 222.222);
		Wait(0.800, Ignore Condition);
		Set Healing Dealt(Event Player, 48.387);
		Wait Until(!Is Firing Secondary(Event Player), 999999986991104.000);
		Set Healing Dealt(Event Player, 100);
	}
}

rule("[roadhog/wholehog.opy]: Disable abilities during wholehog")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Set Melee Enabled(Event Player, False);
		Set Secondary Fire Enabled(Event Player, False);
		Set Ability 1 Enabled(Event Player, False);
		Set Ability 2 Enabled(Event Player, False);
		Set Damage Dealt(Event Player, 100);
		Set Knockback Dealt(Event Player, 100);
	}
}

rule("[roadhog/wholehog.opy]: Enable abilities after wholehog")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Set Melee Enabled(Event Player, True);
		Set Secondary Fire Enabled(Event Player, True);
		Set Ability 1 Enabled(Event Player, True);
		Set Ability 2 Enabled(Event Player, True);
		Stop Holding Button(Event Player, Button(Primary Fire));
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Set Knockback Dealt(Event Player, 35);
	}
}

rule("[roadhog/wholehog.opy]: Force autofire while in wholehog")
{
	event
	{
		Ongoing - Each Player;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Is Button Held(Event Player, Button(Primary Fire)) == False;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("[roadhog/init.opy]: Correct other forms of damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Roadhog;
	}

	conditions
	{
		Array Contains(Array(Button(Melee), Button(Ability 1)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[roadhog/init.opy]: Clean up Roadhog")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hero_setup != Hero(Roadhog);
	}

	actions
	{
		Event Player.Roadhog_vape_target = Null;
		Destroy In-World Text(Event Player.text[5]);
	}
}

rule("[sigma/init.opy]: initSigma()")
{
	event
	{
		Subroutine;
		initSigma;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 3.600;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 14.325;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2275;
		Call Subroutine(removeTankPassive);
		Event Player.macro_pvar[0] = 0.750;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.balance_change_check = 0;
		Event Player.hero_initialized = True;
	}
}

rule("[sigma/init.opy]: Reduce Accretion stun duration")
{
	event
	{
		Player Dealt Damage;
		All;
		Sigma;
	}

	conditions
	{
		Has Status(Victim, Knocked Down) == True;
	}

	actions
	{
		Wait(0.500, Ignore Condition);
		Clear Status(Victim, Knocked Down);
	}
}

rule("[sigma/kinetic_grasp.opy]: Reduce Kinetic Grasp overhealth")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Wait(1.200, Abort When False);
		Event Player.hp_exiting_grasp = Health(Event Player);
		Wait Until(!Is Using Ability 1(Event Player), 999999986991104.000);
		Damage(Event Player, Null, 0.300 * (Health(Event Player) - Event Player.hp_exiting_grasp));
	}
}

rule("[sigma/init.opy]: Increase Sigma other forms of damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Sigma;
	}

	conditions
	{
		Array Contains(Array(Button(Melee), Button(Primary Fire)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[sigma/init.opy]: Increase Gravitic Flux damage")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Set Damage Dealt(Event Player, 100);
		disabled Wait Until(!Is Using Ultimate(Event Player), 999999986991104.000);
		Wait Until(Is Button Held(Event Player, Button(Primary Fire)) == True || !Is Using Ultimate(Event Player), 10);
		Wait(1.700, Ignore Condition);
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("[sojourn/init.opy]: initSojourn()")
{
	event
	{
		Subroutine;
		initSojourn;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 0;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2100;
		Event Player.macro_pvar[0] = 0.834;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.hero_initialized = True;
	}
}

rule("[sojourn/primary.opy] Increased primary damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Sojourn;
	}

	conditions
	{
		Event Ability == Button(Primary Fire);
	}

	actions
	{
		If(Event Was Critical Hit == True);
			Damage(Victim, Event Player, 3);
		Else;
			Damage(Victim, Event Player, 1.500);
		End;
	}
}

rule("[sojourn/orb.opy] Increased disruptor shot damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Sojourn;
	}

	conditions
	{
		Event Ability == Button(Ability 2);
	}

	actions
	{
		Damage(Victim, Event Player, 5.200);
	}
}

rule("[sojourn/ultimate.opy] 200 damage in ult")
{
	event
	{
		Player Dealt Damage;
		All;
		Sojourn;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Event Ability == Button(Ultimate);
	}

	actions
	{
		If(Event Was Critical Hit == True);
			Damage(Victim, Event Player, Event Damage * 0.400);
		End;
	}
}

rule("[soldier/init.opy]: initSoldier()")
{
	event
	{
		Subroutine;
		initSoldier;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 200;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2310;
		Event Player.macro_pvar[1] = 0.875;
		Set Healing Dealt(Event Player, 100 * Event Player.macro_pvar[1]);
		Set Ammo(Event Player, 0, 30);
		Set Max Ammo(Event Player, 0, 30);
		Event Player.hero_initialized = True;
	}
}

rule("[soldier/init.opy]: Increase Heavy Pulse Rifle damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Soldier: 76;
	}

	conditions
	{
		Event Ability == Button(Primary Fire);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) * 1.053 - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[sombra/init.opy]: initSombra()")
{
	event
	{
		Subroutine;
		initSombra;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 200;
		disabled Event Player.custom_hp_pvar[1] = Null;
		disabled Event Player.custom_hp_pvar[2] = Null;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2800;
		Event Player.macro_pvar[0] = 0.875;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.Sombra_invisible = False;
		Create In-World Text(Event Player, Custom String("{0} {1}", Count Of(Filtered Array(All Living Players(Team Of(Event Player)),
			Distance Between(Event Player, Current Array Element) <= 15 && Is In Line of Sight(Event Player, Current Array Element,
			Enemy Barriers Block LOS) == True && Hero Of(Current Array Element) != Hero(Sombra))), Icon String(Plus)), Update Every Frame(
			Eye Position(Event Player) + 100 * (0 * World Vector Of(Right, Event Player, Rotation) + -0.300 * Direction From Angles(
			Horizontal Angle From Direction(Facing Direction Of(Event Player)), Vertical Angle From Direction(Facing Direction Of(
			Event Player)) - 90) + 3 * Facing Direction Of(Event Player))), 1.800, Do Not Clip, Visible To Position String and Color,
			Color(White), Default Visibility);
		Event Player.text[13] = Last Text ID;
		Event Player.hero_initialized = True;
	}
}

rule("[sombra/init.opy]: Increase Sombra melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Sombra;
	}

	conditions
	{
		Event Ability == Button(Melee);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[sombra/hack.opy] Hacked healpack bonus speed")
{
	event
	{
		Player Received Healing;
		All;
		All;
	}

	conditions
	{
		Event Was Health Pack == True;
	}

	actions
	{
		If(Hero Of(Healer) == Hero(Sombra));
			Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 25;
			Set Move Speed(Event Player, Event Player.macro_pvar[2]);
			Wait(2, Ignore Condition);
			Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 25;
			Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		End;
	}
}

rule("[sombra/hack.opy] Hack target for 1.8s")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Status(Event Player, Hacked) == True;
		Ability Cooldown(Players On Hero(Hero(Sombra), Opposite Team Of(Team Of(Event Player))), Button(Secondary Fire)) != 0;
	}

	actions
	{
		Set Status(Event Player, Players On Hero(Hero(Sombra), Opposite Team Of(Team Of(Event Player))), Hacked, 1.800);
	}
}

rule("[sombra/virus.opy]: Sombra Virus Cancel")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sombra;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Wait(0.040, Ignore Condition);
		Cancel Primary Action(Event Player);
	}
}

rule("[sombra/virus.opy]: Target Teammate")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sombra;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
	}

	actions
	{
		Event Player.Sombra_virus_target = First Of(Sorted Array(Filtered Array(All Living Players(Team Of(Event Player)),
			Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element))
			<= 30 && Has Spawned(Current Array Element) && Distance Between(Event Player, Current Array Element)
			<= 20 && Current Array Element != Event Player && Is In Line of Sight(Event Player, Current Array Element,
			Barriers Do Not Block LOS)), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(
			Event Player), Current Array Element))));
		Wait(0.160, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[sombra/virus.opy]: Target Teammate HUD and allow Virus")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sombra;
	}

	conditions
	{
		Event Player.Sombra_virus_target != Null;
	}

	actions
	{
		"targeting hud"
		Create In-World Text(Event Player.Sombra_virus_target != Null && Ability Cooldown(Event Player, Button(Ability 1))
			== 0 ? Event Player : Null, Custom String(" \n\n\n\n\n\n     ︿\n〈      〉\n     ﹀ "), Event Player.Sombra_virus_target + Vector(
			0, 0.700, 0), 2, Do Not Clip, Visible To Position and String, Custom Color(55, 230, 255, 210), Default Visibility);
		Event Player.text[14] = Last Text ID;
		Allow Button(Event Player, Button(Ability 1));
	}
}

rule("[sombra/virus.opy]: Disallow Virus")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sombra;
	}

	conditions
	{
		Event Player.Sombra_virus_target == Null;
	}

	actions
	{
		Disallow Button(Event Player, Button(Ability 1));
		Destroy In-World Text(Event Player.text[14]);
	}
}

rule("[sombra/virus.opy]: Confirm Target")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sombra;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Event Player.Sombra_virus_target.Sombra_virus_confirmed = True;
	}
}

rule("[sombra/virus.opy]: Buff Teammate and play effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Sombra_virus_confirmed == True;
	}

	actions
	{
		Event Player.Sombra_virus_confirmed = False;
		Big Message(Event Player, Custom String("HACKED"));
		Players On Hero(Hero(Sombra), Team Of(Event Player)).Sombra_virus_target = Null;
		Create In-World Text(All Players(All Teams), Ability Icon String(Hero(Sombra), Button(Ultimate)), Event Player + Vector(0, 2.500,
			0), 2, Clip Against Surfaces, Visible To Position and String, Color(Purple), Default Visibility);
		Event Player.text[15] = Last Text ID;
		Event Player.Sombra_hack_icon = True;
		Start Heal Over Time(Event Player, Players On Hero(Hero(Sombra), Team Of(Event Player)), 5, 30);
		Play Effect(All Players(All Teams), Good Pickup Effect, Color(Purple), Event Player, 90);
		Play Effect(All Players(All Teams), Ring Explosion, Color(Purple), Event Player + Up, 4);
		Play Effect(All Players(All Teams), Buff Explosion Sound, Color(White), Event Player, 80);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 30;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Wait Until(!Is Alive(Event Player) || Event Player.hero_initialized == False, 5);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 30;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Destroy In-World Text(Event Player.text[15]);
		Event Player.Sombra_hack_icon = Null;
	}
}

rule("[sombra/heal.opy]: Healing Ring sombra")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sombra;
	}

	conditions
	{
		Event Player.Sombra_invisible == False;
	}

	actions
	{
		Create Effect(All Players(Team Of(Event Player)), Ring, Color(Purple), Event Player, 15, Visible To Position and Radius);
		Event Player.Sombra_healing_ring = Last Created Entity;
		Wait Until(Event Player.Sombra_invisible == True || Hero Of(Event Player) != Hero(Sombra), 99999);
		Destroy Effect(Event Player.Sombra_healing_ring);
	}
}

rule("[sombra/heal.opy]: If visiable heal 15m 32 - players *5 self for 12 - amount of players x 2")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sombra;
	}

	conditions
	{
		Event Player.Sombra_invisible == False;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Start Heal Over Time(Filtered Array(All Living Players(Team Of(Event Player)), Distance Between(Event Player,
			Current Array Element) <= 15 && Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS)
			== True && Current Array Element != Event Player), Event Player, 1, 32 - Count Of(Filtered Array(All Living Players(Team Of(
			Event Player)), Distance Between(Event Player, Current Array Element) <= 15 && Is In Line of Sight(Event Player,
			Current Array Element, Enemy Barriers Block LOS) == True && Current Array Element != Event Player)) * 5);
		Start Heal Over Time(Event Player, Null, 1, 12 - Count Of(Filtered Array(All Living Players(Team Of(Event Player)),
			Distance Between(Event Player, Current Array Element) <= 15 && Is In Line of Sight(Event Player, Current Array Element,
			Enemy Barriers Block LOS) == True && Current Array Element != Event Player)) * 2);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[sombra/translocator.opy]: Sombra Invis Increase move Speed")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sombra;
	}

	conditions
	{
		Event Player.Sombra_invisible == True;
	}

	actions
	{
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 10;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Wait Until(Event Player.Sombra_invisible == False, 99999);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 10;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
	}
}

disabled rule("[sombra/translocator.opy] Sombra stealth damage cancel count damage")
{
	event
	{
		Player Took Damage;
		All;
		Sombra;
	}

	conditions
	{
		Event Player.stealth_timer > 0;
		Event Player.stealth_timer <= 5;
	}

	actions
	{
		disabled Event Player.Sombra_invis_damage += Event Damage;
		disabled If(Event Player.Sombra_invis_damage >= 40);
		Set Status(Event Player, Null, Rooted, 0.001);
		Event Player.stealth_timer = 0;
		Event Player.Sombra_invisible = False;
		disabled Event Player.Sombra_invis_damage = 0;
		disabled Else;
		disabled Wait(1, Restart When True);
		disabled Event Player.Sombra_invis_damage = 0;
		disabled End;
	}
}

disabled rule("[sombra/translocator_cooldown_reset.opy]: When Translocator is used, begin tracking how long Sombra is in stealth")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Hero Of(Event Player) == Hero(Sombra);
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		disabled Event Player.Sombra_invis_damage = 0;
		Event Player.stealth_timer = 5.500;
		Wait Until(!Is Using Ability 2(Event Player), 999999986991104.000);
		Event Player.Sombra_invisible = True;
		Chase Player Variable At Rate(Event Player, stealth_timer, 0, 1, None);
		"Sombra can't break stealth during the cast time of stealth"
		Wait(0.500, Restart When True);
		"Wait until Sombra exits Stealth"
		Wait Until(Is True For Any(Array(Has Status(Event Player, Asleep), Has Status(Event Player, Frozen), Has Status(Event Player,
			Hacked), Has Status(Event Player, Knocked Down), Has Status(Event Player, Stunned), Has Status(Event Player, Rooted)),
			Current Array Element) || Event Player.Sombra_invisible == False || Is Firing Primary(Event Player) || (Is Button Held(
			Event Player, Button(Primary Fire)) && !Is Firing Secondary(Event Player)) || (Ability Cooldown(Event Player, Button(
			Ability 1)) == 0 && Is Button Held(Event Player, Button(Ability 1))) || Is Button Held(Event Player, Button(Melee))
			|| Is Meleeing(Event Player) || Is Using Ultimate(Event Player) || (Event Player.stealth_pvar[1] == 100 && Is Button Held(
			Event Player, Button(Ultimate))), 5);
		Event Player.Sombra_invisible = False;
		Stop Chasing Player Variable(Event Player, stealth_timer);
		Abort If(Event Player.stealth_timer <= 0);
		If(Global.NEGATIVE_STATUS_PREVENTS_REFUND);
			Abort If(Is True For Any(Array(Has Status(Event Player, Asleep), Has Status(Event Player, Frozen), Has Status(Event Player,
				Hacked), Has Status(Event Player, Knocked Down), Has Status(Event Player, Stunned), Has Status(Event Player, Rooted)),
				Current Array Element));
		End;
		Wait Until(Ability Cooldown(Event Player, Button(Ability 2)) > 0, 1);
		"printLog(\"Current Translocator Cooldown: {0} | Target Translocator Cooldown: {1}\".format(eventPlayer.getAbilityCooldown(Button.ABILITY_2), eventPlayer._stealth_max_cooldown - 5 + (eventPlayer.stealth_timer * (1 - STEALTH_REFUND_FRACTION))))"
		Set Ability Cooldown(Event Player, Button(Ability 2), First Of(Event Player.stealth_pvar) - 5 + Event Player.stealth_timer * (
			1 - Global.STEALTH_REFUND_FRACTION));
	}
}

rule("[sombra/translocator_cooldown_reset.opy]: Sombra stealth refund variables")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.STEALTH_REFUND_FRACTION = Workshop Setting Integer(Custom String("Gameplay Settings"), Custom String(
			"Percent of Stealth Timer Remaining Refunded Towards Translocator Cooldown"), 40, 0, 100, 0) / 100;
		Global.NEGATIVE_STATUS_PREVENTS_REFUND = Workshop Setting Toggle(Custom String("Gameplay Settings"), Custom String(
			"Negative Status Effects Cancelling Stealth Prevents Translocator Cooldown Refund"), True, 1);
		Global.MINIMUM_TRANSLOCATOR_COOLDOWN = 4;
	}
}

rule("[sombra/translocator_cooldown_reset.opy]: When Translocator is used, begin tracking how long Sombra is in stealth")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Hero Of(Event Player) == Hero(Sombra);
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		disabled Event Player.Sombra_invis_damage = 0;
		Event Player.stealth_timer = 4.820;
		Wait Until(!Is Using Ability 2(Event Player), 999999986991104.000);
		Event Player.Sombra_invisible = True;
		Chase Player Variable At Rate(Event Player, stealth_timer, 0, 1, None);
		"Sombra can't break stealth during the cast time of stealth"
		disabled Wait(0.500, Restart When True);
		"Wait until Sombra exits Stealth"
		Wait Until(Is True For Any(Array(Has Status(Event Player, Asleep), Has Status(Event Player, Frozen), Has Status(Event Player,
			Hacked), Has Status(Event Player, Knocked Down), Has Status(Event Player, Stunned), Has Status(Event Player, Rooted)),
			Current Array Element) || Event Player.Sombra_invisible == False || Is Firing Primary(Event Player) || (Is Button Held(
			Event Player, Button(Primary Fire)) && !Is Firing Secondary(Event Player)) || (Ability Cooldown(Event Player, Button(
			Ability 1)) == 0 && Is Button Held(Event Player, Button(Ability 1))) || Is Button Held(Event Player, Button(Melee))
			|| Is Meleeing(Event Player) || Is Using Ultimate(Event Player) || (Event Player.stealth_pvar[1] == 100 && Is Button Held(
			Event Player, Button(Ultimate))), 4.820);
		Event Player.Sombra_invisible = False;
		Stop Chasing Player Variable(Event Player, stealth_timer);
		Abort If(Event Player.stealth_timer <= 0);
		If(Global.NEGATIVE_STATUS_PREVENTS_REFUND);
			Abort If(Is True For Any(Array(Has Status(Event Player, Asleep), Has Status(Event Player, Frozen), Has Status(Event Player,
				Hacked), Has Status(Event Player, Knocked Down), Has Status(Event Player, Stunned), Has Status(Event Player, Rooted)),
				Current Array Element));
		End;
		Wait Until(Ability Cooldown(Event Player, Button(Ability 2)) > 0, 1);
		"printLog(\"Current Translocator Cooldown: {0} | Target Translocator Cooldown: {1}\".format(eventPlayer.getAbilityCooldown(Button.ABILITY_2), eventPlayer._stealth_max_cooldown - 5 + (eventPlayer.stealth_timer * (1 - STEALTH_REFUND_FRACTION))))"
		Set Ability Cooldown(Event Player, Button(Ability 2), First Of(Event Player.stealth_pvar) - 5 + Event Player.stealth_timer * (
			1 - Global.STEALTH_REFUND_FRACTION));
	}
}

rule("[sombra/translocator.opy] Sombra stealth self cancel")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sombra;
	}

	conditions
	{
		(Event Player.stealth_timer <= 5 && Event Player.stealth_timer > 0 && Is Button Held(Event Player, Button(Ability 2))) == True;
		Event Player.Sombra_invisible == True;
	}

	actions
	{
		Set Status(Event Player, Null, Rooted, 0.001);
		Event Player.Sombra_invisible = False;
		"printLog(\"Current Translocator Cooldown: {0} | Target Translocator Cooldown: {1}\".format(eventPlayer.getAbilityCooldown(Button.ABILITY_2), eventPlayer._stealth_max_cooldown - 5 + (eventPlayer.stealth_timer * (1 - STEALTH_REFUND_FRACTION))))"
		Set Ability Cooldown(Event Player, Button(Ability 2), First Of(Event Player.stealth_pvar) - 5 + Event Player.stealth_timer * (
			1 - Global.STEALTH_REFUND_FRACTION));
		Event Player.stealth_timer = 0;
	}
}

rule("[sombra/stealth.opy]: Sombra stealth took damage")
{
	event
	{
		Player Took Damage;
		All;
		Sombra;
	}

	conditions
	{
		Event Player.Sombra_invisible == True;
	}

	actions
	{
		Event Player.Sombra_invis_damage = True;
		Wait(1.300, Restart When True);
		Event Player.Sombra_invis_damage = False;
	}
}

rule("[sombra/stealth.opy]: Sombra stealth reveal slow")
{
	event
	{
		Player Took Damage;
		All;
		Sombra;
	}

	conditions
	{
		Event Player.Sombra_invis_damage == True;
		Event Player.Sombra_invisible == True;
	}

	actions
	{
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 47.500;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Wait Until(!Event Player.Sombra_invisible || !Event Player.Sombra_invis_damage, 100000000);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 47.500;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
	}
}

rule("[sombra/translocator_cooldown_reset.opy]: Set max stealth cooldown observed")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Hero Of(Event Player) == Hero(Sombra);
		Ability Cooldown(Event Player, Button(Ability 2)) > First Of(Event Player.stealth_pvar);
	}

	actions
	{
		Event Player.stealth_pvar[0] = Round To Integer(Ability Cooldown(Event Player, Button(Ability 2)), To Nearest);
	}
}

rule("[sombra/opportunist.opy] Remove 20% damage increase")
{
	event
	{
		Player Dealt Damage;
		All;
		Sombra;
	}

	conditions
	{
		Has Status(Victim, Hacked) == True;
	}

	actions
	{
		Heal(Victim, Null, Event Damage / 6);
	}
}

rule("[sombra/emp.opy]: Heal damage EMP does and prevent extra hack time from triggering")
{
	event
	{
		Player Dealt Damage;
		All;
		Sombra;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
	}

	actions
	{
		Heal(Victim, Null, Event Damage);
		Wait(3, Ignore Condition);
		Clear Status(Victim, Hacked);
	}
}

rule("[sombra/init.opy]: Clean up Sombra")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hero_setup != Hero(Sombra);
	}

	actions
	{
		Event Player.Sombra_virus_target = Null;
		Destroy In-World Text(Event Player.text[14]);
		Destroy Effect(Event Player.Sombra_healing_ring);
		Destroy In-World Text(Event Player.text[13]);
	}
}

rule("[symmetra/init.opy]: initSymmetra()")
{
	event
	{
		Subroutine;
		initSymmetra;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 5.250;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 12.500;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1680;
		Event Player.max_health_scaler = 0.750;
		Event Player.hero_initialized = True;
	}
}

rule("[symmetra/init.opy]: Correct Photon projector damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Symmetra;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
	}

	actions
	{
		Damage(Victim, Attacker, Event Damage * 1.050 - Event Damage);
	}
}

rule("[torbjorn/init.opy]: initTorbjorn()")
{
	event
	{
		Subroutine;
		initTorbjorn;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 0;
		Event Player.custom_hp_pvar[1] = 16.725;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2142;
		Set Ammo(Event Player, 0, 18);
		Set Max Ammo(Event Player, 0, 18);
		Event Player.overhealth_check = False;
		Event Player.hero_initialized = True;
	}
}

rule("[torbjorn/init.opy]: Increase Rivet Gun alternate fire ammo cost")
{
	event
	{
		Ongoing - Each Player;
		All;
		Torbjörn;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Set Ammo(Event Player, 0, Ammo(Event Player, 0) - 1);
	}
}

rule("[torbjorn/init.opy]: Increase Overload overhealth")
{
	event
	{
		Ongoing - Each Player;
		All;
		Torbjörn;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Add Health Pool To Player(Event Player, Health, 22.300, False, True);
		Event Player.overload_overhealth = Last Created Health Pool;
		Wait Until(!Is Using Ability 2(Event Player), 999999986991104.000);
		Remove Health Pool From Player(Event Player.overload_overhealth);
	}
}

rule("Torbjörn turret damage increase")
{
	event
	{
		Player Dealt Damage;
		All;
		Torbjörn;
	}

	conditions
	{
		Button(Ability 1) == Event Ability;
	}

	actions
	{
		Damage(Victim, Event Player, 1 / First Of(Event Player.macro_pvar));
	}
}

rule("[tracer/init.opy]: initTracer()")
{
	event
	{
		Subroutine;
		initTracer;
	}

	actions
	{
		disabled If(Is Duplicating(Event Player));
		disabled Remove All Health Pools From Player(Event Player);
		disabled Wait(0.150, Ignore Condition);
		"DO NOT REMOVE THIS LINE"
		disabled Set Max Health(Event Player, 100.001);
		"DO NOT REMOVE THIS LINE"
		disabled Wait(0.150, Ignore Condition);
		disabled Set Max Health(Event Player, 100);
		disabled Set Healing Received(Event Player, 0);
		disabled Add Health Pool To Player(Event Player, Health, 1, True, True);
		disabled Add Health Pool To Player(Event Player, Armor, 1, True, True);
		disabled Add Health Pool To Player(Event Player, Shields, 1, True, True);
		disabled Remove All Health Pools From Player(Event Player);
		disabled End;
		Event Player.ult_charge_pvar[1] = 1250;
		Event Player.macro_pvar[0] = 0.964;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Start Scaling Player(Event Player, 0.960, True);
		Event Player.max_health_scaler = 0.857;
		Event Player.hero_initialized = True;
	}
}

rule("[tracer/init.opy]: Correct melee and Pulse Bomb damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Tracer;
	}

	conditions
	{
		Array Contains(Array(Button(Melee), Button(Ultimate)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[venture/init.opy]: initVenture()")
{
	event
	{
		Subroutine;
		initVenture;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 100;
		Event Player.custom_hp_pvar[1] = 50;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1550;
		Event Player.macro_pvar[0] = 0.429;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Set Knockback Dealt(Event Player, 80);
		Set Ammo(Event Player, 0, 6);
		Set Max Ammo(Event Player, 0, 6);
		Event Player.max_health_scaler = 0.833;
		Start Scaling Player(Event Player, 1.180, True);
		Event Player.hero_initialized = True;
	}
}

rule("[venture/init.opy]: Reduce Headshot damage taken Venture")
{
	event
	{
		Player Took Damage;
		All;
		Venture;
	}

	conditions
	{
		Event Was Critical Hit == True;
	}

	actions
	{
		Heal(Event Player, Null, Event Damage * 0.300);
	}
}

rule("[venture/excavator.opy]: Prepare Smart Excavator damage increase")
{
	event
	{
		Ongoing - Each Player;
		All;
		Venture;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		Event Player.is_firing_excavator = True;
		Wait(0.300, Ignore Condition);
		Event Player.is_firing_excavator = False;
	}
}

rule("[venture/excavator.opy]: Correct Smart Excavator damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Venture;
	}

	conditions
	{
		Event Player.is_firing_excavator != False;
		Is Using Ability 1(Event Player) == False;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) * 0.800 - Event Damage) / First Of(
			Event Player.macro_pvar));
		Event Player.is_firing_excavator = False;
	}
}

rule("[venture/drill_dash.opy]: Correct Drill Dash damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Venture;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) * 0.444 - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[venture/clobber.opy]: Correct Venture melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Venture;
	}

	conditions
	{
		Event Ability == Button(Melee);
	}

	actions
	{
		"damage(victim, attacker, ((eventDamage/eventPlayer._base_damage_scalar) * (ADJ_VENTURE_CLOBBER_DAMAGE / OW2_VENTURE_CLOBBER_DAMAGE) - eventDamage)/eventPlayer._base_damage_scalar)"
		Event Player.clobber_cooldown_accelerator = Ability Cooldown(Event Player, Button(Ability 1));
		Set Ability Cooldown(Event Player, Button(Ability 1), Event Player.clobber_cooldown_accelerator - 0.500);
	}
}

rule("[venture/burrow.opy]: Burrow speed decrease and dash cooldown 0")
{
	event
	{
		Ongoing - Each Player;
		All;
		Venture;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Wait Until(Is On Ground(Event Player) == True, 7);
		Wait(0.600, Abort When False);
		If(Ability Cooldown(Event Player, Button(Secondary Fire)) != 0 && !Is Firing Secondary(Event Player));
			Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		End;
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 70;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Wait Until(Is Using Ability 1(Event Player) == False, 99999);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 70;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		If(Ability Cooldown(Event Player, Button(Secondary Fire)) != 0 && !Is Firing Secondary(Event Player));
			Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		End;
	}
}

rule("[venture/burrow.opy]: Burrow speed increase when dashing")
{
	event
	{
		Ongoing - Each Player;
		All;
		Venture;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 110;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Wait Until(Is Firing Secondary(Event Player) == False, 99999);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 110;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
	}
}

rule("[venture/burrow.opy]: Correct Burrow damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Venture;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) * 0.550 - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[venture/burrow.opy]: Burrow Knockup")
{
	event
	{
		Player Dealt Damage;
		All;
		Venture;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
	}

	actions
	{
		Apply Impulse(Victim, Up, 10, To World, Cancel Contrary Motion);
		Set Status(Event Player, Null, Rooted, 0.300);
	}
}

rule("[venture/tectonic_shock.opy]: Tectonic Shock logic")
{
	event
	{
		Player Dealt Damage;
		All;
		Venture;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) * 0.730 - Event Damage) / First Of(
			Event Player.macro_pvar));
		Apply Impulse(Victim, Up, 8, To World, Cancel Contrary Motion);
		Set Status(Event Player, Null, Rooted, 0.300);
	}
}

rule("[widowmaker/init.opy]: initWidowmaker()")
{
	event
	{
		Subroutine;
		initWidowmaker;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 200;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 0;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1540;
		Event Player.hero_initialized = True;
	}
}

disabled rule("[widowmaker/init.opy]: Reduce Scoped Shot damage")
{
	event
	{
		Ongoing - Each Player;
		All;
		Widowmaker;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Set Damage Dealt(Event Player, 87.500);
		Wait Until(!Is Firing Secondary(Event Player), 999999986991104.000);
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("[widowmaker/weapon.opy] Widowmaker scope glint")
{
	event
	{
		Ongoing - Each Player;
		All;
		Widowmaker;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		"Without aiming at widow check"
		Create Effect(Filtered Array(All Players(Opposite Team Of(Team Of(Event Player))), Distance Between(Event Player,
			Current Array Element) >= 3 && Is In View Angle(Event Player, Eye Position(Current Array Element), 15)), Good Aura, Color(
			White), Eye Position(Event Player), 0.450, Visible To Position and Radius);
		Event Player.WidowScopeGlint_effect = Last Created Entity;
		Wait Until(!Is Firing Secondary(Event Player), 100000000);
		Destroy Effect(Event Player.WidowScopeGlint_effect);
	}
}

rule("[winston/init.opy]: initWinston()")
{
	event
	{
		Subroutine;
		initWinston;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 46.175;
		Event Player.custom_hp_pvar[1] = 15.400;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1650;
		Call Subroutine(removeTankPassive);
		Event Player.macro_pvar[0] = 0.821;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.max_health_scaler = 0.923;
		Set Max Ammo(Event Player, 0, 100);
		Set Ammo(Event Player, 0, 100);
		Event Player.hero_initialized = True;
	}
}

rule("[winston/primal.opy]: Remove bonus Primal Rage health")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Call Subroutine(clearCustomHp);
		Add Health Pool To Player(Event Player, Armor, 15, True, False);
		Wait Until(!Is Using Ultimate(Event Player), 999999986991104.000);
		Call Subroutine(clearCustomHp);
		Call Subroutine(applyCustomHp);
	}
}

rule("[winston/primal.opy]: Reduce Primal Rage damage")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Set Damage Dealt(Event Player, 80);
		Wait Until(!Is Using Ultimate(Event Player), 999999986991104.000);
		"revert damage back after Primal Rage concludes"
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("[winston/primal.opy]: Correct Jump Pack damage during Primal Rage")
{
	event
	{
		Player Dealt Damage;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Event Ability == Button(Ability 1);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / 0.800 - Event Damage) / 0.800);
	}
}

rule("[winston/init.opy]: Correct Jump Pack, Melee, Primal Rage damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == False;
		Array Contains(Array(Button(Ability 1), Button(Melee), Button(Secondary Fire)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[wreckingball/init.opy]: initWreckingBall()")
{
	event
	{
		Subroutine;
		initWreckingBall;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 175;
		Event Player.custom_hp_pvar[1] = 12.500;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1540;
		Call Subroutine(removeTankPassive);
		Event Player.macro_pvar[0] = 0.788;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Set Ammo(Event Player, 0, 80);
		Set Max Ammo(Event Player, 0, 80);
		Event Player.max_health_scaler = 0.500;
		Event Player.hero_initialized = True;
	}
}

rule("[wreckingball/grapple.opy]: Force Grappling Hook cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		Wrecking Ball;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Wait Until(Ability Cooldown(Event Player, Button(Secondary Fire)) > 0, 999999986991104.000);
		If(Ability Cooldown(Event Player, Button(Secondary Fire)) <= 1);
			Set Ability Cooldown(Event Player, Button(Secondary Fire), 1.920);
	}
}

rule("[wreckingball/grapple.opy]: Increase Fireball impact damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Wrecking Ball;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
	}

	actions
	{
		Damage(Victim, Attacker, (0.833 * (Event Damage / First Of(Event Player.macro_pvar)) - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[wreckingball/shields.opy]: Remove Adaptive Shields overhealth transfer")
{
	event
	{
		Ongoing - Each Player;
		All;
		Wrecking Ball;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Disallow Button(Event Player, Button(Ability 2));
		Set Ability 2 Enabled(Event Player, False);
		Wait Until(!Is Using Ability 2(Event Player), 999999986991104.000);
		Call Subroutine(enableAllAbilities);
		Allow Button(Event Player, Button(Ability 2));
	}
}

rule("[wreckingball/shields.opy]: Increase Adaptive Shield base overhealth gain")
{
	event
	{
		Ongoing - Each Player;
		All;
		Wrecking Ball;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Add Health Pool To Player(Event Player, Health, 100, False, True);
		Event Player.adaptive_overhealth_id = Last Created Health Pool;
		Wait Until(!Is Using Ability 2(Event Player), 999999986991104.000);
		Remove Health Pool From Player(Event Player.adaptive_overhealth_id);
		Event Player.adaptive_overhealth_id = Null;
	}
}

rule("[wreckingball/piledriver.opy]: Increase Piledriver / Quadcannon damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Wrecking Ball;
	}

	conditions
	{
		Array Contains(Array(Button(Primary Fire), Button(Crouch)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (0.800 * (Event Damage / First Of(Event Player.macro_pvar)) - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[wreckingball/init.opy]: Correct fireball, melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Wrecking Ball;
	}

	conditions
	{
		Array Contains(Array(Button(Ability 1), Button(Melee)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[zarya/init.opy]: initZarya()")
{
	event
	{
		Subroutine;
		initZarya;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[0] = 200;
		disabled Event Player.custom_hp_pvar[1] = 0;
		disabled Event Player.custom_hp_pvar[2] = 200;
		disabled Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2100;
		Call Subroutine(removeTankPassive);
		Event Player.self_bubble_cooldown = 0;
		Event Player.ally_bubble_cooldown = 0;
		Event Player.macro_pvar[0] = 0.895;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.max_health_scaler = 1;
		Event Player.hero_initialized = True;
	}
}

rule("[zarya/self_bubble.opy]: showSelfBubbleCD()")
{
	event
	{
		Subroutine;
		showSelfBubbleCD;
	}

	actions
	{
		If(Event Player.text[3] == Null);
			Create In-World Text(Event Player, Custom String("{0}", Round To Integer(Event Player.self_bubble_cooldown, Up)),
				Update Every Frame(Eye Position(Event Player) + 100 * (1.990 * World Vector Of(Right, Event Player, Rotation)
				+ -1.900 * Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)),
				Vertical Angle From Direction(Facing Direction Of(Event Player)) - 90) + 3 * Facing Direction Of(Event Player))), 3,
				Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
			Event Player.text[3] = Last Text ID;
			Create In-World Text(Event Player, Custom String("{0} {1}", Round To Integer(Event Player.self_bubble_cooldown, Up),
				Ability Icon String(Hero(Zarya), Button(Ability 1))), Update Every Frame(Eye Position(Event Player) + 100 * (
				0.200 * World Vector Of(Right, Event Player, Rotation) + -0.360 * Direction From Angles(Horizontal Angle From Direction(
				Facing Direction Of(Event Player)), Vertical Angle From Direction(Facing Direction Of(Event Player)) - 90)
				+ 3 * Facing Direction Of(Event Player))), 1.300, Do Not Clip, Visible To Position String and Color, Color(White),
				Default Visibility);
			Event Player.text[1] = Last Text ID;
		End;
	}
}

rule("[zarya/self_bubble.opy]: hideSelfBubbleCD()")
{
	event
	{
		Subroutine;
		hideSelfBubbleCD;
	}

	actions
	{
		Destroy In-World Text(Event Player.text[3]);
		Event Player.text[3] = Null;
		Destroy In-World Text(Event Player.text[1]);
		Event Player.text[1] = Null;
	}
}

rule("[zarya/self_bubble.opy]: OW1 zarya self bubble cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		Zarya;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Disallow Button(Event Player, Button(Ability 1));
		Set Ability Charge(Event Player, Button(Ability 1), 2);
		"wait bubble duration"
		Wait Until(!Is Using Ability 1(Event Player), 2);
		Set Ability 1 Enabled(Event Player, False);
		Event Player.self_bubble_cooldown = 9;
		Allow Button(Event Player, Button(Ability 1));
		Chase Player Variable At Rate(Event Player, self_bubble_cooldown, 0, 1, None);
	}
}

rule("[zarya/self_bubble.opy]: Disable self bubble if on cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		Zarya;
	}

	conditions
	{
		Event Player.self_bubble_cooldown > 0;
	}

	actions
	{
		Set Ability 1 Enabled(Event Player, False);
		Call Subroutine(showSelfBubbleCD);
	}
}

rule("[zarya/self_bubble.opy]: Enable self bubble if not on cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		Zarya;
	}

	conditions
	{
		Event Player.hero_setup == Hero(Zarya);
		Event Player.self_bubble_cooldown <= 0;
	}

	actions
	{
		Set Ability 1 Enabled(Event Player, True);
		Call Subroutine(hideSelfBubbleCD);
	}
}

rule("Hanzo mark enemy play effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Hanzo_Marked_icon == True;
	}

	actions
	{
		Destroy In-World Text(Event Player.text[19]);
		Event Player.text[19] = Null;
		Create In-World Text(Players On Hero(Hero(Hanzo), Opposite Team Of(Team Of(Event Player))), Icon String(Skull),
			Event Player + Vector(0, 2.500, 0), 1.200, Do Not Clip, Visible To Position and String, Color(Red), Default Visibility);
		Event Player.text[19] = Last Text ID;
	}
}

rule("[zarya/ally_bubble.opy]: showAllyBubbleCD()")
{
	event
	{
		Subroutine;
		showAllyBubbleCD;
	}

	actions
	{
		If(Event Player.text[4] == Null);
			Create In-World Text(Event Player, Custom String("{0}", Round To Integer(Event Player.ally_bubble_cooldown, Up)),
				Update Every Frame(Eye Position(Event Player) + 100 * (2.300 * World Vector Of(Right, Event Player, Rotation)
				+ -1.900 * Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)),
				Vertical Angle From Direction(Facing Direction Of(Event Player)) - 90) + 3 * Facing Direction Of(Event Player))), 3,
				Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
			Event Player.text[4] = Last Text ID;
			Create In-World Text(Event Player, Custom String("{0} {1}", Round To Integer(Event Player.ally_bubble_cooldown, Up),
				Ability Icon String(Hero(Zarya), Button(Ability 2))), Update Every Frame(Eye Position(Event Player) + 100 * (
				0.200 * World Vector Of(Right, Event Player, Rotation) + -0.480 * Direction From Angles(Horizontal Angle From Direction(
				Facing Direction Of(Event Player)), Vertical Angle From Direction(Facing Direction Of(Event Player)) - 90)
				+ 3 * Facing Direction Of(Event Player))), 1.300, Do Not Clip, Visible To Position String and Color, Color(White),
				Default Visibility);
			Event Player.text[2] = Last Text ID;
		End;
	}
}

rule("[zarya/ally_bubble.opy]: hideAllyBubbleCD()")
{
	event
	{
		Subroutine;
		hideAllyBubbleCD;
	}

	actions
	{
		Destroy In-World Text(Event Player.text[4]);
		Event Player.text[4] = Null;
		Destroy In-World Text(Event Player.text[2]);
		Event Player.text[2] = Null;
	}
}

rule("[zarya/ally_bubble.opy]: OW1 zarya ally bubble cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		Zarya;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Set Ability Charge(Event Player, Button(Ability 2), 2);
		Set Ability 2 Enabled(Event Player, False);
		"waitUntil(not eventPlayer.isUsingAbility2(), ADJ_ZARYA_BUBBLE_DURATION) # wait bubble duration\nwait bubble duration"
		Wait(2, Ignore Condition);
		Event Player.ally_bubble_cooldown = 8;
		Chase Player Variable At Rate(Event Player, ally_bubble_cooldown, 0, 1, None);
	}
}

rule("[zarya/ally_bubble.opy]: Disable ally bubble if on cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		Zarya;
	}

	conditions
	{
		Event Player.ally_bubble_cooldown > 0;
	}

	actions
	{
		Set Ability 2 Enabled(Event Player, False);
		Call Subroutine(showAllyBubbleCD);
	}
}

rule("[zarya/ally_bubble.opy]: Enable ally bubble if not on cooldown")
{
	event
	{
		Ongoing - Each Player;
		All;
		Zarya;
	}

	conditions
	{
		Event Player.ally_bubble_cooldown <= 0;
	}

	actions
	{
		Set Ability 2 Enabled(Event Player, True);
		Call Subroutine(hideAllyBubbleCD);
	}
}

rule("[zarya/init.opy]: Clean up Zarya")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hero_setup != Hero(Zarya);
	}

	actions
	{
		Call Subroutine(hideSelfBubbleCD);
		Call Subroutine(hideAllyBubbleCD);
	}
}

rule("[zarya/init.opy]: Increase Particle Cannon alternate fire damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Zarya;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) * 0.909 - Event Damage) / First Of(
			Event Player.macro_pvar));
	}
}

rule("[zarya/init.opy]: Correct Zarya Melee damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Zarya;
	}

	conditions
	{
		Event Ability == Button(Melee);
	}

	actions
	{
		Damage(Victim, Attacker, (Event Damage / First Of(Event Player.macro_pvar) - Event Damage) / First Of(Event Player.macro_pvar));
	}
}

rule("[zenyatta/init.opy]: initZenyatta()")
{
	event
	{
		Subroutine;
		initZenyatta;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 0;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 33.450;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 2200;
		Set Ammo(Event Player, 0, 20);
		Set Max Ammo(Event Player, 0, 20);
		Set Knockback Dealt(Event Player, 4);
		Event Player.hero_initialized = True;
	}
}

rule("Hanzo mark enemy on damage")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	conditions
	{
		Array Contains(Array(Button(Ability 1), Button(Primary Fire), Button(Ability 2)), Event Ability) == True;
		Hero Of(Attacker) == Hero(Hanzo);
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		Event Player.Hanzo_Marked_icon = True;
		Wait(8, Restart When True);
		Event Player.Hanzo_Marked_icon = Null;
		Destroy In-World Text(Event Player.text[19]);
		Event Player.text[19] = Null;
	}
}

rule("Hanzo extra damage on marked enemy")
{
	event
	{
		Player Dealt Damage;
		All;
		Hanzo;
	}

	conditions
	{
		Victim.Hanzo_Marked_icon == True;
		Array Contains(Array(Button(Primary Fire), Button(Ability 1), Button(Ultimate)), Event Ability) == True;
	}

	actions
	{
		Damage(Victim, Event Player, Event Damage / First Of(Event Player.macro_pvar));
	}
}

rule("Widow beam")
{
	event
	{
		Ongoing - Each Player;
		All;
		Widowmaker;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Wait(0.900, Abort When False);
		Create Beam Effect(All Players(Opposite Team Of(Team Of(Event Player))), Bad Beam, Eye Position(Event Player) + World Vector Of(
			Vector(0, -0.140, 0), Event Player, Rotation), Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 70, All Players(All Teams), Event Player, True), Color(Red),
			Visible To Position and Radius);
		Event Player.Widowmaker_beam_effect = Last Created Entity;
		Wait Until(!Is Firing Secondary(Event Player), 99999);
		Destroy Effect(Event Player.Widowmaker_beam_effect);
		Event Player.Widowmaker_beam_effect = Null;
	}
}

rule("Widow force fire after 5s")
{
	event
	{
		Ongoing - Each Player;
		All;
		Widowmaker;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Set Damage Dealt(Event Player, 87.500);
		Event Player.Widow_maxscope_duration = 100;
		Create Progress Bar In-World Text(Event Player, Event Player.Widow_maxscope_duration, Custom String("Focus"), Update Every Frame(
			Eye Position(Event Player) + 100 * (0 * World Vector Of(Right, Event Player, Rotation) + (0.500 - 0.200)
			* Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Vertical Angle From Direction(
			Facing Direction Of(Event Player)) - 90) + 3 * Facing Direction Of(Event Player))), 0.700, Do Not Clip, Color(White), Color(
			White), Visible To Position Values and Color, Default Visibility);
		Event Player.text[20] = Last Text ID;
		Chase Player Variable At Rate(Event Player, Widow_maxscope_duration, 0, 25, Destination and Rate);
		Wait Until(!Is Firing Secondary(Event Player) || Is Button Held(Event Player, Button(Primary Fire)) == True, 4);
		If(Is Button Held(Event Player, Button(Primary Fire)) == True);
			Press Button(Event Player, Button(Secondary Fire));
		Else If(Is Firing Secondary(Event Player) == True);
			Press Button(Event Player, Button(Primary Fire));
			Press Button(Event Player, Button(Secondary Fire));
		End;
		Stop Chasing Player Variable(Event Player, Widow_maxscope_duration);
		Destroy Progress Bar In-World Text(Event Player.text[20]);
		Set Secondary Fire Enabled(Event Player, False);
		Wait(0.340, Ignore Condition);
		Set Secondary Fire Enabled(Event Player, True);
	}
}

rule("Widow unscope / reset")
{
	event
	{
		Ongoing - Each Player;
		All;
		Widowmaker;
	}

	conditions
	{
		Is Firing Secondary(Event Player) == True;
	}

	actions
	{
		Wait Until(!Is Firing Secondary(Event Player), 99999);
		Stop Chasing Player Variable(Event Player, Widow_maxscope_duration);
		Destroy Progress Bar In-World Text(Event Player.text[20]);
		Event Player.text[20] = Null;
		Event Player.Widow_maxscope_duration = Null;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
	}
}

rule("Widow kick grapple")
{
	event
	{
		Ongoing - Each Player;
		All;
		Widowmaker;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Wait(0.200, Ignore Condition);
		Wait Until(!Is Using Ability 1(Event Player) || Is Button Held(Event Player, Button(Ability 1)) == True, 6);
		If(Is Button Held(Event Player, Button(Ability 1)) == True);
			Start Holding Button(Event Player, Button(Jump));
			Wait(0.100, Ignore Condition);
			Press Button(Event Player, Button(Melee));
			Play Effect(All Players(All Teams), Ring Explosion, Color(White), Event Player, 3);
			Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Event Player, 50);
			Apply Impulse(Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))), Distance Between(Event Player,
				Current Array Element) <= 3 && Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS)
				== True && Current Array Element != Event Player), Vector(0, 10, 0), 5, To World, Incorporate Contrary Motion);
			Apply Impulse(Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))), Distance Between(Event Player,
				Current Array Element) <= 3 && Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS)
				== True && Current Array Element != Event Player), Direction Towards(Event Player, Eye Position(Event Player)
				+ Facing Direction Of(Event Player) * 30), 20, To World, Incorporate Contrary Motion);
			Damage(Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))), Is In Line of Sight(Event Player,
				Current Array Element, Barriers Do Not Block LOS) == True && Distance Between(Event Player, Current Array Element) <= 3),
				Event Player, 25);
		End;
		Stop Holding Button(Event Player, Button(Jump));
	}
}

rule("[doomfist/init.opy]: initDoomfistDPS()")
{
	event
	{
		Subroutine;
		initDoomfist;
	}

	actions
	{
		Event Player.custom_hp_pvar[0] = 15;
		Event Player.custom_hp_pvar[1] = 0;
		Event Player.custom_hp_pvar[2] = 0;
		Call Subroutine(applyCustomHp);
		Event Player.ult_charge_pvar[1] = 1750;
		Call Subroutine(removeTankPassive);
		Start Scaling Player(Event Player, 0.920, True);
		Event Player.macro_pvar[0] = 0.820;
		Set Damage Dealt(Event Player, 100 * First Of(Event Player.macro_pvar));
		Event Player.max_health_scaler = 0.625;
		Event Player.hero_initialized = True;
	}
}

rule("Control flow for Uppercut")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Call Subroutine(executeUppercut);
	}
}

rule("Execute main logic for Rising Uppercut ability")
{
	event
	{
		Subroutine;
		executeUppercut;
	}

	actions
	{
		"Clear uppercut victims"
		Event Player.uppercut_victims = Empty Array;
		"Start of uppercut"
		Event Player.is_using_uppercut = True;
		"Doomfist phases through enemies during uppercut"
		Disable Movement Collision With Players(Event Player);
		"Doomfist cannot melee during uppercut"
		Disallow Button(Event Player, Button(Melee));
		"Doomfist cannot shoot during uppercut"
		Disallow Button(Event Player, Button(Primary Fire));
		"Doomfist cannot punch during uppercut"
		Set Secondary Fire Enabled(Event Player, False);
		"Uppercut physics\r\n Cancel current momentum"
		Apply Impulse(Event Player, Velocity Of(Event Player), -1 * Speed Of(Event Player), To World, Incorporate Contrary Motion);
		"Move laterally in the facing direction"
		Apply Impulse(Event Player, Vector(X Component Of(Facing Direction Of(Event Player)), 0, Z Component Of(Facing Direction Of(
			Event Player))), 5, To World, Incorporate Contrary Motion);
		"Override gravity during uppercut"
		Set Gravity(Event Player, 0);
		"Deny player from inputting movement commands"
		Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
		Communicate(Event Player, Goodbye);
		Wait(0.150, Ignore Condition);
		Apply Impulse(Event Player, Up, 40, To World, Incorporate Contrary Motion);
		Wait(0.100, Ignore Condition);
		Apply Impulse(Event Player, Down, Max(0, Speed Of In Direction(Event Player, Up)), To World, Incorporate Contrary Motion);
		"End of uppercut"
		Event Player.is_using_uppercut = False;
		Wait(0.016, Ignore Condition);
		Apply Impulse(Event Player, Up, 2.500, To World, Incorporate Contrary Motion);
		Set Gravity(Event Player, 0);
		Enable Movement Collision With Players(Event Player);
		Allow Button(Event Player, Button(Melee));
		Allow Button(Event Player, Button(Primary Fire));
		Set Secondary Fire Enabled(Event Player, True);
		Wait(0.350, Ignore Condition);
		Set Ability 2 Enabled(Event Player, True);
		Stop Forcing Throttle(Event Player);
		Wait(0.150, Ignore Condition);
		Set Gravity(Event Player, 50);
		Wait(0.250, Ignore Condition);
		Set Gravity(Event Player, 100);
	}
}

rule("Detect Uppercut Victims")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is True For Any(Filtered Array(Players Within Radius(Event Player, 7, Opposite Team Of(Team Of(Event Player)), Surfaces), Hero Of(
			Current Array Element) == Hero(Doomfist)), Current Array Element.is_using_uppercut == True) == True;
		Angle Between Vectors(Normalize(Vector(X Component Of(Facing Direction Of(First Of(Filtered Array(Players On Hero(Hero(Doomfist),
			Opposite Team Of(Team Of(Event Player))), Current Array Element.is_using_uppercut == True)))), 0, Z Component Of(
			Facing Direction Of(First Of(Filtered Array(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player))),
			Current Array Element.is_using_uppercut == True)))))), Direction Towards(First Of(Filtered Array(Players On Hero(Hero(
			Doomfist), Opposite Team Of(Team Of(Event Player))), Current Array Element.is_using_uppercut == True)), Event Player)) <= 90;
		Array Contains(First Of(Filtered Array(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player))),
			Current Array Element.is_using_uppercut == True)).uppercut_victims, Event Player) == False;
		Event Player.Orisa_fortified == Null;
	}

	actions
	{
		Modify Player Variable(First Of(Filtered Array(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player))),
			Current Array Element.is_using_uppercut == True)), uppercut_victims, Append To Array, Event Player);
		Damage(Event Player, First Of(Filtered Array(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player))),
			Current Array Element.is_using_uppercut == True)), 60 / First Of(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(
			Event Player))).macro_pvar));
		Play Effect(All Players(All Teams), Bad Explosion, Color(White), Event Player, 1);
		Play Effect(All Players(All Teams), Explosion Sound, Color(White), Event Player, 80);
		disabled Apply Impulse(Event Player, Up, 13, To Player, Cancel Contrary Motion XYZ);
		"Uppercut physics\r\n Cancel current momentum"
		Apply Impulse(Event Player, Velocity Of(Event Player), -1 * Speed Of(Event Player), To World, Incorporate Contrary Motion);
		Apply Impulse(Event Player, Vector(X Component Of(Facing Direction Of(First Of(Filtered Array(Players On Hero(Hero(Doomfist),
			Opposite Team Of(Team Of(Event Player))), Current Array Element.is_using_uppercut == True)))), 0, Z Component Of(
			Facing Direction Of(First Of(Filtered Array(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player))),
			Current Array Element.is_using_uppercut == True))))), 5, To World, Cancel Contrary Motion XYZ);
		"Override gravity during uppercut"
		Set Gravity(Event Player, 0);
		Wait(0.150, Ignore Condition);
		Apply Impulse(Event Player, Up, 40, To World, Incorporate Contrary Motion);
		Wait(0.100, Ignore Condition);
		Apply Impulse(Event Player, Down, Max(0, Speed Of In Direction(Event Player, Up)), To World, Incorporate Contrary Motion);
		Wait(0.016, Ignore Condition);
		Apply Impulse(Event Player, Up, 2.500, To World, Incorporate Contrary Motion);
		Set Gravity(Event Player, 0);
		Wait(0.350, Ignore Condition);
		Stop Forcing Throttle(Event Player);
		Wait(0.150, Ignore Condition);
		Set Gravity(Event Player, 50);
		Wait(0.250, Ignore Condition);
		Set Gravity(Event Player, 100);
	}
}

rule("Shields for Uppercut")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Event Player.is_using_uppercut == True;
	}

	actions
	{
		Wait Until(Event Player.is_using_uppercut == False, 99999);
		Event Player.number_of_victims_uppercut = Count Of(Event Player.uppercut_victims);
		Add Health Pool To Player(Event Player, Health, Event Player.number_of_victims_uppercut * 25, False, True);
		Event Player.doom_uppercut_shields = Last Created Health Pool;
	}
}

rule("Cancel Powerblock animation")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Wait(0.150, Ignore Condition);
		Set Ability 2 Enabled(Event Player, False);
	}
}

rule("doom cap health at 400")
{
	event
	{
		Ongoing - Each Player;
		All;
		Doomfist;
	}

	conditions
	{
		Health(Event Player) > 400;
	}

	actions
	{
		Set Player Health(Event Player, 400);
	}
}

rule("[doomfist/init.opy]: Increase headshot damage taken")
{
	event
	{
		Player Took Damage;
		All;
		Doomfist;
	}

	conditions
	{
		Event Was Critical Hit == True;
	}

	actions
	{
		Damage(Event Player, Attacker, Event Damage * 0.250);
	}
}

rule("[kiriko/protection_suzu.opy]: correct suzu healing")
{
	event
	{
		Player Dealt Healing;
		All;
		Kiriko;
	}

	conditions
	{
		Event Ability == Button(Ability 2);
	}

	actions
	{
		Heal(Healee, Event Player, Event Healing / Event Player.macro_pvar[1] - Event Healing);
	}
}

rule("Roadhog true damage")
{
	event
	{
		Player Dealt Damage;
		All;
		Roadhog;
	}

	conditions
	{
		Button(Primary Fire) == Event Ability;
	}

	actions
	{
		Damage(Victim, Event Player, 10 / First Of(Event Player.macro_pvar));
		Wait(0.625, Ignore Condition);
	}
}

rule("Orisa subtract ammo generate heat")
{
	event
	{
		Ongoing - Each Player;
		All;
		Orisa;
	}

	conditions
	{
		Update Every Frame(Is Firing Primary(Event Player)) == True;
	}

	actions
	{
		Event Player.Orisa_Ammo = Event Player.Orisa_Ammo - 1;
		Event Player.Orisa_heat = Event Player.Orisa_heat + 4;
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Orisa ammo refresh")
{
	event
	{
		Ongoing - Each Player;
		All;
		Orisa;
	}

	conditions
	{
		Event Player.Orisa_Ammo <= 0;
	}

	actions
	{
		Set Ammo(Event Player, 0, 0);
		Chase Player Variable At Rate(Event Player, Orisa_Ammo, 100, 33, Destination and Rate);
		Set Primary Fire Enabled(Event Player, False);
		disabled Damage(Players Within Radius(Event Player + Up, 6, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers),
			Event Player, Event Player.Orisa_heat / First Of(Event Player.macro_pvar));
		Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), Event Player, 8);
		Start Damage Over Time(Players Within Radius(Event Player + Up, 8, Opposite Team Of(Team Of(Event Player)),
			Surfaces And Enemy Barriers), Event Player, 3, Event Player.Orisa_heat / 2.500 / First Of(Event Player.macro_pvar));
		Set Status(Players Within Radius(Event Player, 8, Opposite Team Of(Team Of(Event Player)), Surfaces), Event Player, Burning, 3);
		Wait(1, Ignore Condition);
		Wait Until(Event Player.Orisa_Ammo >= 100, 99999);
		Event Player.Orisa_heat = 0;
		Set Primary Fire Enabled(Event Player, True);
		Stop Chasing Player Variable(Event Player, Orisa_Ammo);
	}
}

rule("Orisa reload")
{
	event
	{
		Ongoing - Each Player;
		All;
		Orisa;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		Event Player.Orisa_Ammo = 0;
	}
}

rule("Orisa lock heat at 100")
{
	event
	{
		Ongoing - Each Player;
		All;
		Orisa;
	}

	conditions
	{
		Event Player.Orisa_heat > 100;
	}

	actions
	{
		Event Player.Orisa_heat = 100;
	}
}

rule("Heat animation 100")
{
	event
	{
		Ongoing - Each Player;
		All;
		Orisa;
	}

	conditions
	{
		Event Player.Orisa_heat > 90;
	}

	actions
	{
		Set Status(Event Player, Null, Burning, 9999);
		Start Damage Over Time(Event Player, Event Player, 9999, 20);
		Event Player.Orisa_Overheating = Last Damage Over Time ID;
		Wait Until(Event Player.Orisa_heat <= 89, 99999);
		Clear Status(Event Player, Burning);
		Stop Damage Over Time(Event Player.Orisa_Overheating);
		Event Player.Orisa_Overheating = Null;
	}
}

disabled rule("Orisa burn during fortify")
{
	event
	{
		Ongoing - Each Player;
		All;
		Orisa;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Start Damage Over Time(Players Within Radius(Event Player + Up, 8, Opposite Team Of(Team Of(Event Player)),
			Surfaces And Enemy Barriers), Event Player, 1, Event Player.Orisa_heat / 2.500 / First Of(Event Player.macro_pvar));
		Set Status(Players Within Radius(Event Player, 8, Opposite Team Of(Team Of(Event Player)), Surfaces), Event Player, Burning, 1);
		Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), Event Player, 8);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[lucio/ampitup.opy]: begin ally tracking")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lúcio;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Remove From Array(Players Within Radius(Event Player, 12, Team Of(Event Player), Surfaces), Event Player)
			.Within_speed_radius = True;
		Wait(0.125, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[lucio/ampitup.opy]: decrease speed for allies")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.Within_speed_radius == True;
	}

	actions
	{
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 6.250;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Wait(0.125, Ignore Condition);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 6.250;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Event Player.Within_speed_radius = False;
	}
}

rule("[lucio/ampitup.opy]: decrease speed for Lucio")
{
	event
	{
		Ongoing - Each Player;
		All;
		Lúcio;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] - 6.250;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
		Wait(3, Ignore Condition);
		Event Player.macro_pvar[2] = Event Player.macro_pvar[2] + 6.250;
		Set Move Speed(Event Player, Event Player.macro_pvar[2]);
	}
}

rule("[mercy/ressurect.opy]: Mercy rez")
{
	event
	{
		Ongoing - Each Player;
		All;
		Mercy;
	}

	conditions
	{
		(Is Using Ultimate(Event Player) == True && Is Button Held(Event Player, Button(Ultimate)) == True && Is Alive(Event Player)
			== True && Count Of(Remove From Array(Players Within Radius(Event Player, 5.500, Team Of(Event Player), Surfaces),
			All Living Players(All Teams))) > 0) == True;
		Event Player.Mercy_Rez_charges == 1;
	}

	actions
	{
		Event Player.MercyUltTrack = 0;
		Set Ultimate Charge(Event Player, 0);
		Destroy HUD Text(Event Player.RezHUD);
		Event Player.RezHUD = Null;
		Communicate(Event Player, Hello);
		"Set rez target"
		Event Player.RezTarget = First Of(Sorted Array(Remove From Array(Players Within Radius(Event Player, 5.500, Team Of(Event Player),
			Surfaces), All Living Players(Team Of(Event Player))), Angle Between Vectors(Facing Direction Of(Event Player),
			Direction Towards(Event Player, Current Array Element))));
		"Show rez in killfeed (skews mercy's elims and target's deaths by 1, but whatever)"
		Resurrect(Event Player.RezTarget);
		Set Status(Event Player.RezTarget, Null, Phased Out, 0.100);
		Set Player Health(Event Player.RezTarget, 0.010);
		Kill(Event Player.RezTarget, Event Player);
		Wait(0.016, Ignore Condition);
		"Real rez"
		Resurrect(Event Player.RezTarget);
		Set Status(Event Player.RezTarget, Null, Phased Out, 2.250);
		Set Status(Event Player.RezTarget, Null, Frozen, 1.500);
		Set Player Health(Event Player.RezTarget, Max Health(Event Player.RezTarget));
		Play Effect(All Players(All Teams), Good Pickup Effect, Color(Yellow), Event Player.RezTarget, 5);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), Event Player.RezTarget, 110);
		Set Ammo(Event Player.RezTarget, 0, Max Ammo(Event Player.RezTarget, 0));
		Set Ammo(Event Player.RezTarget, 1, Max Ammo(Event Player.RezTarget, 1));
		"0.75s recovery"
		Disallow Button(Event Player, Button(Primary Fire));
		Disallow Button(Event Player, Button(Secondary Fire));
		Disallow Button(Event Player, Button(Melee));
		Disallow Button(Event Player, Button(Ability 2));
		"Disable target abilities for 0.75s movement window in invuln"
		Disallow Button(Event Player.RezTarget, Button(Ability 1));
		Disallow Button(Event Player.RezTarget, Button(Ability 2));
		Disallow Button(Event Player.RezTarget, Button(Primary Fire));
		Disallow Button(Event Player.RezTarget, Button(Secondary Fire));
		Disallow Button(Event Player.RezTarget, Button(Ultimate));
		Disallow Button(Event Player.RezTarget, Button(Melee));
		"End recovery"
		Wait(0.500, Ignore Condition);
		Allow Button(Event Player, Button(Primary Fire));
		Allow Button(Event Player, Button(Secondary Fire));
		Allow Button(Event Player, Button(Melee));
		Allow Button(Event Player, Button(Ability 2));
		"End of target invuln, enable abilities"
		Wait(1.750, Ignore Condition);
		Allow Button(Event Player.RezTarget, Button(Ability 1));
		Allow Button(Event Player.RezTarget, Button(Ability 2));
		Allow Button(Event Player.RezTarget, Button(Primary Fire));
		Allow Button(Event Player.RezTarget, Button(Secondary Fire));
		Allow Button(Event Player.RezTarget, Button(Ultimate));
		Allow Button(Event Player.RezTarget, Button(Melee));
		Event Player.RezTarget = Null;
		Event Player.Mercy_Rez_charges = Null;
	}
}

rule("[mercy/imbue.opy]: Mercy imbue target icon")
{
	event
	{
		Ongoing - Each Player;
		All;
		Mercy;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Event Player.ImbueTargetIcon == Null;
	}

	actions
	{
		Create In-World Text(First Of(Sorted Array(Filtered Array(Players Within Radius(Event Player, 20.500, Team Of(Event Player),
			Surfaces And Enemy Barriers), Is In View Angle(Event Player, Position Of(Current Array Element),
			2.500 + 120 / Distance Between(Event Player, Current Array Element))
			== True && Current Array Element != Event Player && Is Alive(Current Array Element) == True), Angle Between Vectors(
			Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element)))))
			!= Null && !Is In Alternate Form(Event Player) ? Event Player : Null, Custom String("+"), Eye Position(First Of(Sorted Array(
			Filtered Array(Players Within Radius(Event Player, 20.500, Team Of(Event Player), Surfaces And Enemy Barriers),
			Is In View Angle(Event Player, Position Of(Current Array Element), 2.500 + 120 / Distance Between(Event Player,
			Current Array Element)) == True && Current Array Element != Event Player && Is Alive(Current Array Element) == True),
			Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(
			Current Array Element)))))) + Vector(0, 1, 0), 2, Do Not Clip, Visible To Position String and Color, Is Firing Secondary(
			Event Player) ? Color(Blue) : Color(Yellow), Default Visibility);
		Event Player.ImbueTargetIcon = Last Text ID;
	}
}

rule("[mercy/ressurect.opy]: Mercy rez HUD")
{
	event
	{
		Ongoing - Each Player;
		All;
		Mercy;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Event Player.RezHUD == Null;
		Is Using Ultimate(Event Player) == True;
		Event Player.Mercy_Rez_charges == 1;
	}

	actions
	{
		Create HUD Text(Is Alive(Event Player) && Count Of(Remove From Array(Players Within Radius(Event Player, 5.500, Team Of(
			Event Player), Surfaces), All Living Players(All Teams))) > 0 ? Event Player : Null, Custom String("Resurrect {0}",
			Hero Icon String(Hero Of(First Of(Sorted Array(Remove From Array(Players Within Radius(Event Player, 5.500, Team Of(
			Event Player), Surfaces), All Living Players(Team Of(Event Player))), Angle Between Vectors(Facing Direction Of(Event Player),
			Direction Towards(Event Player, Current Array Element))))))), Null, Null, Top, 0, Color(Yellow), Color(Yellow), Color(White),
			Visible To and String, Default Visibility);
		Event Player.RezHUD = Last Text ID;
	}
}

rule("[mercy/imbue.opy]: Mercy imbue")
{
	event
	{
		Ongoing - Each Player;
		All;
		Mercy;
	}

	conditions
	{
		"Staff equipped, cooldown ready, E pressed, target within range"
		disabled (Is In Alternate Form(Event Player) == False && Is Button Held(Event Player, Button(Ability 2)) == True && Ability Cooldown(
			Event Player, Button(Ability 2)) == 0 && First Of(Sorted Array(Filtered Array(Remove From Array(Remove From Array(
			Players Within Radius(Event Player, 20.500, Team Of(Event Player), Surfaces And Enemy Barriers), Event Player),
			All Dead Players(Team Of(Event Player))), Is In View Angle(Event Player, Position Of(Current Array Element),
			2.500 + 120 / Distance Between(Event Player, Current Array Element)) == True), Angle Between Vectors(Facing Direction Of(
			Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element))))) != Null) == True;
		"Enable pistol imbue"
		(Is Button Held(Event Player, Button(Ability 2)) == True && Ability Cooldown(Event Player, Button(Ability 2)) == 0) == True;
		(First Of(Sorted Array(Filtered Array(Remove From Array(Remove From Array(Players Within Radius(Event Player, 20.500, Team Of(
			Event Player), Surfaces And Enemy Barriers), Event Player), All Dead Players(Team Of(Event Player))), Is In View Angle(
			Event Player, Position Of(Current Array Element), 2.500 + 120 / Distance Between(Event Player, Current Array Element))
			== True), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(
			Current Array Element))))) != Null || Is In Alternate Form(Event Player)) == True;
	}

	actions
	{
		"Vanilla rez cd hero setting needs to be changed if cooldown is changed so icon matches"
		Set Ability Cooldown(Event Player, Button(Ability 2), 15);
		Set Ability 2 Enabled(Event Player, True);
		Destroy In-World Text(Event Player.ImbueTargetIcon);
		Event Player.ImbueTargetIcon = Null;
		disabled Event Player.ImbueSecondary = Is Firing Secondary(Event Player) ? True : False;
		Event Player.ImbueSecondary = Is Firing Secondary(Event Player) || Is In Alternate Form(Event Player) ? 1 : Null;
		If(Is In Alternate Form(Event Player));
			Event Player.ImbueTarget = Event Player;
			Event Player.ImbueSecondary = 2;
		Else;
			"Set target"
			Event Player.ImbueTarget = First Of(Sorted Array(Filtered Array(Players Within Radius(Event Player, 20.500, Team Of(Event Player),
				Surfaces And Enemy Barriers), Is In View Angle(Event Player, Position Of(Current Array Element),
				2.500 + 120 / Distance Between(Event Player, Current Array Element))
				== True && Current Array Element != Event Player && Is Alive(Current Array Element) == True), Angle Between Vectors(
				Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element)))));
			Big Message(Event Player.ImbueTarget, Event Player.ImbueSecondary ? Custom String("Damage Imbued") : Custom String("Heal Imbued"));
		End;
		"Duration"
		Event Player.ImbueDuration = 5;
		Chase Player Variable At Rate(Event Player, ImbueDuration, 0, 1, Destination and Rate);
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Event Player, 80);
		Create Beam Effect(Event Player.ImbueTarget != Null ? All Players(All Teams) : Null, Bad Beam, Event Player,
			Event Player.ImbueTarget, Is Firing Secondary(Event Player) ? Color(Blue) : Color(Yellow), Visible To Position and Radius);
		Event Player.ImbueBeam = Last Created Entity;
		Play Effect(All Players(All Teams), Ring Explosion, Event Player.ImbueSecondary ? (Team Of(Event Player) == Team 1 ? Color(Team 1)
			: Color(Team 2)) : Color(Yellow), Event Player.ImbueTarget, 8);
		"Destroy beam and sparkle"
		Wait(0.200, Ignore Condition);
		Destroy Effect(Event Player.ImbueBeam);
		"Wait = cooldown - 0.3 (stops vanilla rez being usable the frame cooldown ends); rez cooldown needs to be changed in hero \r\nsettings if cooldown is changed so icon matches"
		Wait Until(Is Alive(Event Player) == False || Ability Cooldown(Event Player, Button(Ability 2)) <= 0.300 || Hero Of(Event Player)
			!= Hero(Mercy), 14.700);
		Abort If(Hero Of(Event Player) != Hero(Mercy));
		Set Ability 2 Enabled(Event Player, False);
	}
}

rule("Hazard Lifesteal heal 2 per spike")
{
	event
	{
		Player Dealt Damage;
		All;
		Hazard;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
	}

	actions
	{
		Heal(Event Player, Null, 2);
	}
}

rule("[hazard/thorn_wall.opy]: Target Teammate")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hazard;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
	}

	actions
	{
		Event Player.hazard_bubble_target = First Of(Sorted Array(Filtered Array(All Living Players(Team Of(Event Player)),
			Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element))
			<= 30 && Has Spawned(Current Array Element) && Distance Between(Event Player, Current Array Element)
			<= 25 && Current Array Element != Event Player && Is In Line of Sight(Event Player, Current Array Element,
			Barriers Do Not Block LOS)), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(
			Event Player), Current Array Element))));
		Wait(0.160, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[hazard/thorn_wall.opy]: Target Teammate HUD and allow bubble")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hazard;
	}

	conditions
	{
		Event Player.hazard_bubble_target != Null;
	}

	actions
	{
		"targeting hud"
		Create In-World Text(Event Player.hazard_bubble_target != Null && Ability Cooldown(Event Player, Button(Ability 2))
			== 0 ? Event Player : Null, Custom String(" \n\n\n\n\n\n     ︿\n〈      〉\n     ﹀ "),
			Event Player.hazard_bubble_target + Vector(0, 0.700, 0), 2, Do Not Clip, Visible To Position and String, Custom Color(55, 230,
			255, 210), Default Visibility);
		Event Player.text[16] = Last Text ID;
		Set Ability 2 Enabled(Event Player, True);
		Event Player.Hazard_Bubble_Allowed = True;
	}
}

rule("[hazard/thorn_wall.opy]: Disallow bubble")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hazard;
	}

	conditions
	{
		Event Player.hazard_bubble_target == Null;
	}

	actions
	{
		Set Ability 2 Enabled(Event Player, False);
		Destroy In-World Text(Event Player.text[16]);
		Event Player.Hazard_Bubble_Allowed = False;
	}
}

rule("[hazard/thorn_wall.opy]: Confirm Target")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hazard;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ability 2)) == True;
	}

	actions
	{
		If(Is Alive(Event Player) == True);
			If(Event Player.Hazard_Bubble_Allowed == True);
				Set Ability Cooldown(Event Player, Button(Ability 2), 10);
				Event Player.hazard_bubble_target.hazard_bubble_confirmed = True;
			End;
		End;
	}
}

rule("[hazard/thorn_wall.opy]: Return Damage to attacker and heal hazard")
{
	event
	{
		Player Took Damage;
		All;
		All;
	}

	conditions
	{
		Event Player.hazard_bubble_icon == True;
	}

	actions
	{
		Damage(Attacker, Players On Hero(Hero(Hazard), Team Of(Event Player)), Event Damage / 2);
		Play Effect(Event Player, Debuff Impact Sound, Color(White), Event Player, 80);
		Heal(Players On Hero(Hero(Hazard), Team Of(Event Player)), Null, Event Damage / 4);
	}
}

rule("[hazard/thorn_wall.opy]: Make immune to CC after 0.1s")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Has Status(Event Player, Stunned) || Has Status(Event Player, Rooted) || Has Status(Event Player, Frozen) || Has Status(
			Event Player, Asleep) || Has Status(Event Player, Knocked Down)) == True;
		Event Player.hazard_bubble_icon == True;
	}

	actions
	{
		If(Event Player.hazard_bubble_icon == True);
			Wait(0.100, Ignore Condition);
			Clear Status(Event Player, Knocked Down);
			Clear Status(Event Player, Asleep);
			Clear Status(Event Player, Frozen);
			Clear Status(Event Player, Rooted);
			Clear Status(Event Player, Stunned);
	}
}

rule("[hazard/thorn_wall.opy]: Buff Teammate and play effects")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hazard_bubble_confirmed == True;
	}

	actions
	{
		Event Player.hazard_bubble_confirmed = False;
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element != Event Player), Bad Aura, Color(Purple), Event Player,
			0.500, Visible To Position and Radius);
		Event Player.hazard_bubble_effect = Last Created Entity;
		Create Effect(Filtered Array(All Players(All Teams), Current Array Element != Event Player), Sphere, Color(Purple), Event Player,
			1.200, Visible To Position and Radius);
		Event Player.hazard_bubble_effect2 = Last Created Entity;
		Players On Hero(Hero(Hazard), Team Of(Event Player)).hazard_bubble_target = Null;
		Event Player.hazard_bubble_icon = True;
		Big Message(Event Player, Custom String("{0} Bubbled", Hero Icon String(Hero(Hazard))));
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), Event Player, 80);
		Event Player.macro_pvar[3] = Event Player.macro_pvar[3] - 50;
		Set Damage Received(Event Player, Event Player.macro_pvar[3]);
		Wait Until(!Is Alive(Event Player) || Event Player.hero_initialized == False, 2.250);
		Event Player.macro_pvar[3] = Event Player.macro_pvar[3] + 50;
		Set Damage Received(Event Player, Event Player.macro_pvar[3]);
		Destroy Effect(Event Player.hazard_bubble_effect);
		Destroy Effect(Event Player.hazard_bubble_effect2);
		Event Player.hazard_bubble_icon = Null;
		Event Player.hazard_bubble_effect = Null;
		Event Player.hazard_bubble_effect2 = Null;
	}
}

rule("[utilities/hero_init.opy]: initHero()")
{
	event
	{
		Subroutine;
		initHero;
	}

	actions
	{
		If(True);
			Skip(Array(84, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
				60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82)[1 + Index Of Array Value(Array(Hero(Ana), Hero(Ashe), Hero(Baptiste), Hero(
				Bastion), Hero(Brigitte), Hero(Doomfist), Hero(D.Va), Hero(Echo), Hero(Genji), Hero(Hanzo), Hero(Illari), Hero(Junker Queen),
				Hero(Junkrat), Hero(Juno), Hero(Kiriko), Hero(Lifeweaver), Hero(Lúcio), Hero(Mauga), Hero(Cassidy), Hero(Mei), Hero(Mercy),
				Hero(Moira), Hero(Orisa), Hero(Pharah), Hero(Ramattra), Hero(Reaper), Hero(Reinhardt), Hero(Roadhog), Hero(Sigma), Hero(
				Sojourn), Hero(Soldier: 76), Hero(Sombra), Hero(Symmetra), Hero(Torbjörn), Hero(Tracer), Hero(Venture), Hero(Widowmaker), Hero(
				Winston), Hero(Wrecking Ball), Hero(Zarya), Hero(Zenyatta), Hero(Hazard), Hero(Freja)), Event Player.hero_setup)]);
			Call Subroutine(initAna);
		Else;
			Call Subroutine(initAshe);
		Else;
			Call Subroutine(initBaptiste);
		Else;
			Call Subroutine(initBastion);
		Else;
			Call Subroutine(initBrigitte);
		Else;
			Call Subroutine(initDoomfist);
		Else;
			Call Subroutine(initDva);
		Else;
			Call Subroutine(initEcho);
		Else;
			Call Subroutine(initGenji);
		Else;
			Call Subroutine(initHanzo);
		Else;
			Call Subroutine(initIllari);
		Else;
			Call Subroutine(initJunkerQueen);
		Else;
			Call Subroutine(initJunkrat);
		Else;
			Call Subroutine(initJuno);
		Else;
			Call Subroutine(initKiriko);
		Else;
			Call Subroutine(initLifeweaver);
		Else;
			Call Subroutine(initLucio);
		Else;
			Call Subroutine(initMauga);
		Else;
			Call Subroutine(initMccree);
		Else;
			Call Subroutine(initMei);
		Else;
			Call Subroutine(initMercy);
		Else;
			Call Subroutine(initMoira);
		Else;
			Call Subroutine(initOrisa);
		Else;
			Call Subroutine(initPharah);
		Else;
			Call Subroutine(initRamattra);
		Else;
			Call Subroutine(initReaper);
		Else;
			Call Subroutine(initReinhardt);
		Else;
			Call Subroutine(initRoadhog);
		Else;
			Call Subroutine(initSigma);
		Else;
			Call Subroutine(initSojourn);
		Else;
			Call Subroutine(initSoldier);
		Else;
			Call Subroutine(initSombra);
		Else;
			Call Subroutine(initSymmetra);
		Else;
			Call Subroutine(initTorbjorn);
		Else;
			Call Subroutine(initTracer);
		Else;
			Call Subroutine(initVenture);
		Else;
			Call Subroutine(initWidowmaker);
		Else;
			Call Subroutine(initWinston);
		Else;
			Call Subroutine(initWreckingBall);
		Else;
			Call Subroutine(initZarya);
		Else;
			Call Subroutine(initZenyatta);
		Else;
			Call Subroutine(initHazard);
		Else;
			Call Subroutine(initFreja);
		Else;
		Else;
		End;
		If(!Event Player.hero_initialized);
			Big Message(Event Player, Custom String("warning: {0} not initialized properly!", Event Player.hero_setup));
		End;
	}
}

rule("[utilities/global.opy] Initialize global variables")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.DEBUG_MODE = Workshop Setting Toggle(Custom String("Dev Tools"), Custom String("debug mode"), True, 0);
		Global.ADJ_TANK_ULT_NEGATION_PERCENT = Workshop Setting Integer(Custom String("Passive"), Custom String(
			"Tank - Ultimate Charge Negation Percent"), 0, 0, 40, 0);
		Global.enable_regeneration = Workshop Setting Toggle(Custom String("Passive"), Custom String("Global - Regeneration"), True, 0);
		Global.ADJ_REGEN_HPS = Workshop Setting Integer(Custom String("Passive"), Custom String(
			"Global - Regeneration Healing per Second"), 25, 1, 100, 0);
		Global.ADJ_REGEN_TIMER = Workshop Setting Integer(Custom String("Passive"), Custom String("Global - Regeneration Activation Time"),
			5, 1, 30, 0);
		Global.ANTI_CRASH_ACTIVATE_PERCENT = Workshop Setting Integer(Custom String("Anti Crash"), Custom String("Activation Percent"),
			200, 0, 250, 0);
		Global.ANTI_CRASH_HOLD_TIME = Workshop Setting Real(Custom String("Anti Crash"), Custom String("Activation Hold Time"), 5.500, 0,
			20, 0);
		Global.ANTI_CRASH_DEACTIVATE_PERCENT = Workshop Setting Integer(Custom String("Anti Crash"), Custom String("Deactivation Percent"),
			110, 0, 250, 0);
	}
}

rule("[utilities/custom_hp.opy]: clearCustomHp()")
{
	event
	{
		Subroutine;
		clearCustomHp;
	}

	actions
	{
		Remove All Health Pools From Player(Event Player);
		disabled Wait(0.016, Ignore Condition);
		"DO NOT REMOVE THIS LINE"
		disabled Set Max Health(Event Player, 99.999);
		"DO NOT REMOVE THIS LINE"
		disabled Wait(0.016, Ignore Condition);
		disabled Set Max Health(Event Player, 100);
	}
}

rule("[utilities/custom_hp.opy]: applyCustomHp()")
{
	event
	{
		Subroutine;
		applyCustomHp;
	}

	actions
	{
		disabled Event Player.custom_hp_pvar[3] = 0;
		"loop MAX_HP_ITER_COUNT times if hp is incorrect"
		disabled While((Absolute Value(Max Health Of Type(Event Player, Health) - First Of(Event Player.custom_hp_pvar)) > 0.010 || Absolute Value(
			Max Health Of Type(Event Player, Armor) - Event Player.custom_hp_pvar[1]) > 0.010 || Absolute Value(Max Health Of Type(
			Event Player, Shields) - Event Player.custom_hp_pvar[2]) > 0.010) && Event Player.custom_hp_pvar[3] < 10);
		disabled Set Healing Received(Event Player, 0);
		disabled Set Player Health(Event Player, 1);
		disabled Add Health Pool To Player(Event Player, Health, 1, True, True);
		disabled Add Health Pool To Player(Event Player, Armor, 1, True, True);
		disabled Add Health Pool To Player(Event Player, Shields, 1, True, True);
		Set Status(Event Player, Null, Invincible, 999999986991104.000);
		disabled Remove All Health Pools From Player(Event Player);
		"wait(0.064)"
		Wait(0.016, Ignore Condition);
		disabled Wait Until(Max Health(Event Player) <= 1, 1);
		"Apply custom health pool to player"
		If(First Of(Event Player.custom_hp_pvar) > 0);
			Add Health Pool To Player(Event Player, Health, Max(1, First Of(Event Player.custom_hp_pvar)), True, True);
		End;
		If(Event Player.custom_hp_pvar[1] > 0);
			Add Health Pool To Player(Event Player, Armor, Max(1, Event Player.custom_hp_pvar[1]), True, True);
		End;
		If(Event Player.custom_hp_pvar[2] > 0);
			Add Health Pool To Player(Event Player, Shields, Max(1, Event Player.custom_hp_pvar[2]), True, True);
		End;
		disabled Set Healing Received(Event Player, 100);
		Heal(Event Player, Null, 999999986991104.000);
		Clear Status(Event Player, Invincible);
		disabled Wait(0.016, Ignore Condition);
		disabled Event Player.custom_hp_pvar[3] += 1;
		disabled End;
	}
}

rule("[utilities/reset.opy]: resetHero()")
{
	event
	{
		Subroutine;
		resetHero;
	}

	actions
	{
		Call Subroutine(clearCustomHp);
		Call Subroutine(disableAllAbilities);
		Call Subroutine(resetStats);
		Call Subroutine(resetUltCharge);
		Call Subroutine(enableAllAbilities);
		Event Player.hero_initialized = False;
	}
}

rule("[utilities/reset.opy]: enableAllAbilities()")
{
	event
	{
		Subroutine;
		enableAllAbilities;
	}

	actions
	{
		Allow Button(Event Player, Button(Primary Fire));
		Allow Button(Event Player, Button(Secondary Fire));
		Allow Button(Event Player, Button(Ability 1));
		Allow Button(Event Player, Button(Ability 2));
		Allow Button(Event Player, Button(Ultimate));
		Allow Button(Event Player, Button(Melee));
		Allow Button(Event Player, Button(Jump));
		Allow Button(Event Player, Button(Crouch));
		Allow Button(Event Player, Button(Reload));
		Allow Button(Event Player, Button(Interact));
		Set Primary Fire Enabled(Event Player, True);
		Set Secondary Fire Enabled(Event Player, True);
		Set Ability 1 Enabled(Event Player, True);
		Set Ability 2 Enabled(Event Player, True);
		Set Ultimate Ability Enabled(Event Player, True);
		Set Melee Enabled(Event Player, True);
		Set Jump Enabled(Event Player, True);
		Set Crouch Enabled(Event Player, True);
		Set Reload Enabled(Event Player, True);
	}
}

rule("[utilities/reset.opy]: disableAllAbilities()")
{
	event
	{
		Subroutine;
		disableAllAbilities;
	}

	actions
	{
		Disallow Button(Event Player, Button(Primary Fire));
		Disallow Button(Event Player, Button(Secondary Fire));
		Disallow Button(Event Player, Button(Ability 1));
		Disallow Button(Event Player, Button(Ability 2));
		Disallow Button(Event Player, Button(Ultimate));
		Disallow Button(Event Player, Button(Melee));
		Disallow Button(Event Player, Button(Jump));
		Disallow Button(Event Player, Button(Crouch));
		Disallow Button(Event Player, Button(Reload));
		Disallow Button(Event Player, Button(Interact));
		Set Primary Fire Enabled(Event Player, False);
		Set Secondary Fire Enabled(Event Player, False);
		Set Ability 1 Enabled(Event Player, False);
		Set Ability 2 Enabled(Event Player, False);
		Set Ultimate Ability Enabled(Event Player, False);
		Set Melee Enabled(Event Player, False);
		Set Jump Enabled(Event Player, False);
		Set Crouch Enabled(Event Player, False);
		Set Reload Enabled(Event Player, False);
	}
}

rule("[utilities/reset.opy]: resetStatuses()")
{
	event
	{
		Subroutine;
		resetStatuses;
	}

	actions
	{
		Clear Status(Event Player, Asleep);
		Clear Status(Event Player, Burning);
		Clear Status(Event Player, Frozen);
		Clear Status(Event Player, Hacked);
		Clear Status(Event Player, Invincible);
		Clear Status(Event Player, Knocked Down);
		Clear Status(Event Player, Phased Out);
		Clear Status(Event Player, Rooted);
		Clear Status(Event Player, Stunned);
		Clear Status(Event Player, Unkillable);
	}
}

rule("[utilities/reset.opy]: Stop DoT/HoT on death")
{
	event
	{
		Player Died;
		All;
		All;
	}

	actions
	{
		Stop All Damage Over Time(Event Player);
		Stop All Heal Over Time(Event Player);
	}
}

rule("[utilities/hero_switch.opy]: detect hero switch")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		First Of(Event Player.hero_switch_pvar) != Hero Of(Event Player);
	}

	actions
	{
		Event Player.hero_switch_pvar[1] = True;
		Wait(0.016, Ignore Condition);
		Event Player.hero_switch_pvar[0] = Hero Of(Event Player);
		"eventPlayer._hero_id = heroID(eventPlayer._last_hero_played)"
		Event Player.hero_switch_pvar[1] = False;
	}
}

rule("[utilities/hero_switch.opy]: Initialize hero on hero switch")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.hero_switch_pvar[1] != False;
	}

	actions
	{
		Wait Until(Has Spawned(Event Player), 999999986991104.000);
		Wait Until(!Event Player.hero_switch_pvar[1], 999999986991104.000);
		Event Player.hero_setup = Hero Of(Event Player);
		Call Subroutine(resetHero);
		Call Subroutine(initHero);
	}
}

rule("[utilities/hero_switch.opy]: Reinitialize hero on new round")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Between Rounds == True;
	}

	actions
	{
		Wait Until(!Is Between Rounds, 999999986991104.000);
		Call Subroutine(resetHero);
		Call Subroutine(initHero);
	}
}

rule("[utilities/anti_crash.opy]: Activate anti crash")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Server Load > Global.ANTI_CRASH_ACTIVATE_PERCENT;
	}

	actions
	{
		Wait(Global.ANTI_CRASH_HOLD_TIME, Abort When False);
		Small Message(All Players(All Teams), Custom String("Crash protection in progress..."));
		Set Slow Motion(1);
		Wait Until(Server Load < Global.ANTI_CRASH_DEACTIVATE_PERCENT, 999999986991104.000);
		Set Slow Motion(100);
	}
}