settings
{
	main
	{
		Mode Name: "6v6 Adjustments + Realth 1.16.9"
	}
	lobby
	{
		Map Rotation: After A Game
		Max Spectators: 12
		Max Team 1 Players: 6
		Max Team 2 Players: 6
		Pause Game On Player Disconnect: Yes
		Return To Lobby: After A Game
	}
	modes
	{
		Assault
		{
			enabled maps
			{
			}
			Capture Speed Modifier: 120%
			Competitive Rules: On
			Enable Perks: Off
		}
		disabled Clash
		{
			Capture Speed Modifier: 45%
		}
		Control
		{
			enabled maps
			{
			}
			Competitive Rules: On
			Enable Perks: Off
		}
		Escort
		{
			enabled maps
			{
			}
			Competitive Rules: On
			Enable Perks: Off
		}
		Flashpoint
		{
			enabled maps
			{
			}
			Competitive Rules: On
			Enable Perks: Off
			Scoring Speed Modifier: 85%
		}
		Hybrid
		{
			enabled maps
			{
			}
			Competitive Rules: On
			Enable Perks: Off
		}
		Push
		{
			enabled maps
			{
			}
			Competitive Rules: On
			Enable Perks: Off
			TS-1 Push Speed Modifier: 100%
		}
		General
		{
			Game Mode Start: Immediately
			Health Pack Respawn Time Scalar: 120%
			Random Hero Role Limit Per Team: 2
			Spawn Health Packs: Enabled
			Tank Role Passive Health Bonus: Disabled
		}
	}
	heroes
	{
		General
		{
			Passive Health Regeneration: Off
			Ana
			{
				Ammunition Clip Size Scalar: 80%
				Biotic Grenade Cooldown Time: 86%
				Health: 80%
				Sleep Dart Cooldown Time: 86%
				Ultimate Generation Nano Boost: 100%
			}
			Ashe
			{
				Health: 80%
				Ultimate Generation B.O.B.: 109%
			}
			Baptiste
			{
				Ammunition Clip Size Scalar: 130%
				Health: 80%
				Ultimate Generation Amplification Matrix: 105%
			}
			Bastion
			{
				Health: 70%
				Reconfigure Cooldown Time: 100%
				Ultimate Generation Configuration: Artillery: 96%
			}
			Brigitte
			{
				Health: 80%
				Repair Pack Cooldown Time: 100%
				Ultimate Generation Rally: 103%
			}
			Cassidy
			{
				Health: 72%
				Ultimate Generation Deadeye: 107%
			}
			D.Va
			{
				Boosters Cooldown Time: 114%
				Defense Matrix Maximum Time: 67%
				Defense Matrix Recharge Rate: 90%
				Health: 69%
				Ultimate Generation Self-Destruct: 110%
			}
			Doomfist
			{
				Health: 63%
				Seismic Slam Cooldown Time: 100%
				Ultimate Generation Meteor Strike: 113%
			}
			Echo
			{
				Focusing Beam Cooldown Time: 125%
				Health: 33%
				Ultimate Generation Duplicate: 98%
			}
			Freja
			{
				Health: 89%
			}
			Genji
			{
				Ammunition Clip Size Scalar: 125%
				Health: 80%
				Ultimate Duration: 50%
				Ultimate Generation Dragonblade: 145%
			}
			Hanzo
			{
				Health: 80%
				Storm Arrows Quantity: 4
				Ultimate Generation Dragonstrike: 110%
			}
			Hazard
			{
				Health: 67%
				Violent Leap Cooldown Time: 116%
			}
			Illari
			{
				Ammunition Clip Size Scalar: 85%
				Healing Pylon Cooldown Time: 114%
				Health: 80%
				Solar Energy Maximum: 86%
				Ultimate Generation Captive Sun: 121%
			}
			Junker Queen
			{
				Carnage Cooldown Time: 88%
				Commanding Shout Cooldown Time: 108%
				Health: 71%
				Ultimate Generation Rampage: 117%
			}
			Junkrat
			{
				Concussion Mine Cooldown Time: 100%
				Health: 80%
				Ultimate Generation RIP-Tire: 109%
			}
			Juno
			{
				Glide Boost Cooldown Time: 133%
				Health: 50%
				Hyper Ring Cooldown Time: 136%
				Pulsar Torpedoes Cooldown Time: 100%
				Ultimate Generation Orbital Ray: 110%
			}
			Kiriko
			{
				Health: 89%
				Protection Suzu Cooldown Time: 93%
				Swift Step Cooldown Time: 100%
				Ultimate Generation Kitsune Rush: 117%
			}
			Lifeweaver
			{
				Ammunition Clip Size Scalar: 80%
				Health: 50%
				Petal Platform Cooldown Time: 100%
				Petal Platform Health: 133%
				Rejuvenating Dash Cooldown Time: 0%
				Rejuvenating Dash Healing: 45%
				Tree of Life Health: 150%
				Ultimate Generation Tree of Life: 110%
			}
			Lúcio
			{
				Health: 89%
				Soundwave Cooldown Time: 105%
				Soundwave Knockback Scalar: 100%
				Ultimate Generation Sound Barrier: 90%
			}
			Mauga
			{
				Ammunition Clip Size Scalar: 100%
				Cardiac Overdrive Cooldown Time: 84%
				Cardiac Overdrive Healing: 0%
				Health: 83%
				Incendiary Chaingun Ignite Damage: 223%
				Incendiary Chaingun Ignite Duration: 75%
				Overrun Cooldown Time: 120%
				Ultimate Generation Cage Fight: 108%
			}
			Mei
			{
				Health: 80%
				Ultimate Generation Blizzard: 120%
				Weapon Freeze Rate Scalar: 130%
			}
			Mercy
			{
				Guardian Angel Cooldown Time: 73%
				Health: 89%
				Resurrect Cooldown Time: 50%
				Sympathetic Recovery: Off
			}
			Moira
			{
				Health: 89%
				Ultimate Generation Coalescence: 104%
			}
			Orisa
			{
				Energy Javelin Cooldown Time: 117%
				Fortify Cooldown Time: 79%
				Health: 69%
				Javelin Spin Cooldown Time: 75%
				No Ammunition Requirement: On
				Ultimate Generation Terra Surge: 119%
			}
			Pharah
			{
				Health: 89%
				Ultimate Generation Barrage: 105%
			}
			Ramattra
			{
				Health: 63%
				Nemesis Form Cooldown Time: 100%
				Ravenous Vortex Cooldown Time: 85%
				Ultimate Duration: 100%
				Ultimate Generation Annihilation: 114%
				Void Barrier Omnic Form Cooldown Time: 81%
			}
			Reaper
			{
				Health: 75%
				Shadow Step Cooldown Time: 80%
				Ultimate Generation Death Blossom: 98%
			}
			Reinhardt
			{
				Barrier Field Recharge Rate: 88%
				Charge Cooldown Time: 143%
				Projectile Speed: 83%
				Ultimate Generation Earthshatter: 123%
			}
			Roadhog
			{
				Chain Hook Cooldown Time: 117%
				Health: 92%
				Pig Pen Cooldown Time: 75%
				Take a Breather Cooldown Time: 480%
				Take a Breather Maximum Time: 89%
				Take a Breather Recharge Rate: 500%
				Ultimate Generation Whole Hog: 110%
			}
			Sigma
			{
				Experimental Barrier Recharge Rate: 94%
				Health: 86%
				Kinetic Grasp Cooldown Time: 108%
				Ultimate Generation Gravitic Flux: 101%
			}
			Sojourn
			{
				Health: 80%
				Power Slide Cooldown Time: 75%
				Ultimate Generation Overclock: 110%
			}
			Soldier: 76
			{
				Health: 80%
				Ultimate Generation Tactical Visor: 119%
			}
			Sombra
			{
				Hack Cooldown Time: 134%
				Health: 89%
				Translocator Cooldown Time: 100%
				Ultimate Generation EMP: 49%
				Virus Cooldown Time: 150%
			}
			Symmetra
			{
				Health: 75%
				Ultimate Generation Photon Barrier: 121%
			}
			Torbjörn
			{
				Deploy Turret Cooldown Time: 83%
				Health: 78%
				Ultimate Generation Molten Core: 110%
			}
			Tracer
			{
				Health: 86%
				Recall Cooldown Time: 103%
				Ultimate Generation Pulse Bomb: 110%
			}
			Venture
			{
				Burrow Duration Scalar: 50%
				Ultimate Generation Tectonic Shock: 137%
			}
			Widowmaker
			{
				Health: 89%
				Ultimate Generation Infra-Sight: 101%
				Venom Mine Cooldown Time: 80%
			}
			Winston
			{
				Health: 92%
				Jump Pack Cooldown Time: 120%
				Ultimate Generation Primal Rage: 138%
			}
			Wrecking Ball
			{
				Grappling Claw Cooldown Time: 120%
				Grappling Claw Knockback Scalar: 85%
				Health: 50%
				Piledriver Cooldown Time: 125%
				Ultimate Generation Minefield: 120%
			}
			Zarya
			{
				Particle Barrier Cooldown Time: 109%
				Ultimate Generation Graviton Surge: 119%
			}
			Zenyatta
			{
				Health: 67%
				Ultimate Generation Transcendence: 104%
			}
		}
	}
	workshop
	{
		Activation Hold Time: 5.5
		Calculate DPS over seconds: 10
		Damage Role Cap: 2
		debug mode: Off
		Support Role Cap: 2
		Tank Role Cap: 2
	}
}
variables {
    global:
        1: DEBUG_MODE
        2: ADJ_TANK_ULT_NEGATION_PERCENT
        3: enable_regeneration
        4: ADJ_REGEN_HPS
        5: ADJ_REGEN_TIMER
        6: ANTI_CRASH_ACTIVATE_PERCENT
        7: ANTI_CRASH_HOLD_TIME
        8: ANTI_CRASH_DEACTIVATE_PERCENT
        9: AllTankHeroes
        10: AllDpsHeroes
        11: AllSupportHeroes
        12: AllRoles
        13: NEGATIVE_STATUS_PREVENTS_REFUND
        14: STEALTH_REFUND_FRACTION
        15: MINIMUM_TRANSLOCATOR_COOLDOWN
        16: dpsTime
        17: bot
        18: Spectator_padding
    player:
        0: within_shout_radius
        1: DamageRecieved
        2: MoveSpeed
        3: custom_hp_pvar
        4: hero_initialized
        5: macro_pvar
        6: max_health_scaler
        7: hero_switch_pvar
        8: hero_setup
        9: Status_effect_hud
        10: zarya_self_bubble_centre_hud
        11: zarya_ally_bubble_centre_hud
        12: Ana_Sleepdart_Target
        13: HeroCoreActive
        14: regen_passive_id
        15: self_heal_pvar
        16: ult_charge_pvar
        17: baptiste_balance_change_check
        18: Baptiste_hud
        19: sentry_healing_id
        20: bash_cooldown
        21: punched_victims
        22: wall_impacted_victims
        23: self_destruct_charge
        24: overhealth_check
        25: orbital_ray_x
        26: orbital_ray_z
        27: orbital_ray_final_x
        28: orbital_ray_final_z
        29: remainingAntiDuration
        30: terra_overhealth_id
        31: balance_change_check
        32: hp_exiting_grasp
        33: overload_overhealth
        34: Hazard_Bubble_Allowed
        35: adaptive_overhealth_id
        36: self_bubble_cd_text
        37: self_bubble_cooldown
        38: ally_bubble_cd_text
        39: ally_bubble_cooldown
        40: AllowedHeroes
        41: Roadhog_vape_target
        42: Roadhog_targeting_hud
        43: Roadhog_vape_confirmed
        44: Roadhog_vape_effect
        45: Roadhog_vape_hud_icon
        46: Explaination_Hud
        47: JQ_Shout_Hud
        48: Cardiac_overdrive_active
        49: Hazard_Downpour_effect
        50: Mauga_Overdrive_Health
        51: Hazard_Downpour_Target
        52: Ashe_Dynamite_Healing_ID
        53: Widowmaker_beam_effect
        54: Mercy_Rez_charges
        55: Lifeweaver_petal_charges
        56: Lifeweaver_petal_hud
        57: Lifeweaver_dash_charges
        58: Lifeweaver_dash_hud
        59: Lifeweaver_healing_hud
        60: Lifeweaver_healing_cd
        61: Lifeweaver_petal_centre_hud
        62: Lifeweaver_leap_centre_target
        63: Ashe_dynamite_hit
        64: Orisa_ring_effect
        65: is_firing_excavator
        66: clobber_cooldown_accelerator
        67: Sombra_invisible
        68: Sombra_hud
        69: Sombra_virus_target
        70: Sombra_targeting_hud
        71: Sombra_virus_confirmed
        72: Sombra_hack_effect
        73: Sombra_hack_icon
        74: Sombra_healing_ring
        75: stealth_timer
        76: Sombra_invis_damage
        77: stealth_pvar
        78: WidowScopeGlint_effect
        79: Within_speed_radius
        80: doom_uppercut_shields
        81: Bastion_healing_id
        82: hazard_bubble_target
        83: hazard_bubble_confirmed
        84: hazard_targeting_hud
        85: HanzoDrawAura
        86: damage
        87: time
        88: textID
        89: position
        90: Echo_Copy
        91: EchoHUD
        92: ImbueBeam
        93: ImbueTarget
        94: ImbueDuration
        95: Junkrat_Trap_target
        96: Junkrat_Trap_effect
        97: ImbueAOERing
        98: number_of_victims_uppercut
        99: RezHUD
        100: ImbueSparkle
        101: ImbueAOESound
        102: MercyUltTrack
        103: RezTarget
        104: healing
        105: ImbueTargetIcon
        106: EchoUltSeconds
        107: hazard_bubble_effect
        108: DoomPunchTrack
        109: ReinChargeTrack
        110: ImbueSecondary
        111: Hanzo_Marked_icon
        112: Hanzo_Marked_effect
        113: Widow_maxscope_duration
        114: Widow_Focus_HUD
        115: is_using_uppercut
        116: uppercut_victims
        117: Nemesis_armor
        118: Junkerqueen_overhealth
        119: hazard_bubble_icon
        120: Orisa_Ammo
        121: Orisa_heat
        122: Orisa_Overheating
        123: Orisa_Heat_HUD
        124: Orisa_Ammo_HUD
        125: Orisa_fortified
        126: hazard_bubble_effect2
}
subroutines {
    0: clearCustomHp
    1: applyCustomHp
    2: resetHero
    3: enableAllAbilities
    4: disableAllAbilities
    5: resetStats
    6: resetStatuses
    7: initHero
    8: resetUltCharge
    9: removeTankPassive
    10: initAna
    11: initAshe
    12: initBaptiste
    13: initBastion
    14: initBrigitte
    15: initDoomfist
    16: initDva
    17: initEcho
    18: initGenji
    19: initHanzo
    20: initIllari
    21: initJunkerQueen
    22: initJunkrat
    23: initJuno
    24: initKiriko
    25: initLucio
    26: initMccree
    27: initMercy
    28: initMoira
    29: initPharah
    30: initRamattra
    31: initReaper
    32: initReinhardt
    33: initRoadhog
    34: initSigma
    35: initSojourn
    36: initSoldier
    37: initTorbjorn
    38: initTracer
    39: initWidowmaker
    40: initWinston
    41: initWreckingBall
    42: showSelfBubbleCD
    43: hideSelfBubbleCD
    44: showAllyBubbleCD
    45: hideAllyBubbleCD
    46: initZarya
    47: initZenyatta
    48: initMauga
    49: initLifeweaver
    50: initOrisa
    51: initVenture
    52: initMei
    53: initSombra
    54: initSymmetra
    55: initHazard
    56: EchoCopy
    57: initFreja
    58: executeUppercut
    59: initDoomfistDPS
}
rule ("[utilities/hero_init.opy]: initHero()") {
    event {
        Subroutine;
        initHero;
    }
    actions {
        If(True);
            Skip(Value In Array(Array(84, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82), Add(1, Index Of Array Value(Array(Hero(Ana), Hero(Ashe), Hero(Baptiste), Hero(Bastion), Hero(Brigitte), Hero(Doomfist), Hero(D.Va), Hero(Echo), Hero(Genji), Hero(Hanzo), Hero(Illari), Hero(Junker Queen), Hero(Junkrat), Hero(Juno), Hero(Kiriko), Hero(Lifeweaver), Hero(Lúcio), Hero(Mauga), Hero(Cassidy), Hero(Mei), Hero(Mercy), Hero(Moira), Hero(Orisa), Hero(Pharah), Hero(Ramattra), Hero(Reaper), Hero(Reinhardt), Hero(Roadhog), Hero(Sigma), Hero(Sojourn), Hero(Soldier: 76), Hero(Sombra), Hero(Symmetra), Hero(Torbjörn), Hero(Tracer), Hero(Venture), Hero(Widowmaker), Hero(Winston), Hero(Wrecking Ball), Hero(Zarya), Hero(Zenyatta), Hero(Hazard), Hero(Freja)), (Event Player).hero_setup))));
            Call Subroutine(initAna);
        Else;
            Call Subroutine(initAshe);
        Else;
            Call Subroutine(initBaptiste);
        Else;
            Call Subroutine(initBastion);
        Else;
            Call Subroutine(initBrigitte);
        Else;
            Call Subroutine(initDoomfist);
        Else;
            Call Subroutine(initDva);
        Else;
            Call Subroutine(initEcho);
        Else;
            Call Subroutine(initGenji);
        Else;
            Call Subroutine(initHanzo);
        Else;
            Call Subroutine(initIllari);
        Else;
            Call Subroutine(initJunkerQueen);
        Else;
            Call Subroutine(initJunkrat);
        Else;
            Call Subroutine(initJuno);
        Else;
            Call Subroutine(initKiriko);
        Else;
            Call Subroutine(initLifeweaver);
        Else;
            Call Subroutine(initLucio);
        Else;
            Call Subroutine(initMauga);
        Else;
            Call Subroutine(initMccree);
        Else;
            Call Subroutine(initMei);
        Else;
            Call Subroutine(initMercy);
        Else;
            Call Subroutine(initMoira);
        Else;
            Call Subroutine(initOrisa);
        Else;
            Call Subroutine(initPharah);
        Else;
            Call Subroutine(initRamattra);
        Else;
            Call Subroutine(initReaper);
        Else;
            Call Subroutine(initReinhardt);
        Else;
            Call Subroutine(initRoadhog);
        Else;
            Call Subroutine(initSigma);
        Else;
            Call Subroutine(initSojourn);
        Else;
            Call Subroutine(initSoldier);
        Else;
            Call Subroutine(initSombra);
        Else;
            Call Subroutine(initSymmetra);
        Else;
            Call Subroutine(initTorbjorn);
        Else;
            Call Subroutine(initTracer);
        Else;
            Call Subroutine(initVenture);
        Else;
            Call Subroutine(initWidowmaker);
        Else;
            Call Subroutine(initWinston);
        Else;
            Call Subroutine(initWreckingBall);
        Else;
            Call Subroutine(initZarya);
        Else;
            Call Subroutine(initZenyatta);
        Else;
            Call Subroutine(initHazard);
        Else;
            Call Subroutine(initFreja);
        Else;
        Else;
        End;
        If(Not((Event Player).hero_initialized));
            Big Message(Event Player, Custom String("warning: {0} not initialized properly!", (Event Player).hero_setup));
        End;
    }
}

rule ("[utilities/global.opy] Initialize global variables") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable(DEBUG_MODE, Workshop Setting Toggle(Custom String("Dev Tools"), Custom String("debug mode"), True, 0));
        Set Global Variable(ADJ_TANK_ULT_NEGATION_PERCENT, Workshop Setting Integer(Custom String("Passive"), Custom String("Tank - Ultimate Charge Negation Percent"), 0, 0, 40, 0));
        Set Global Variable(enable_regeneration, Workshop Setting Toggle(Custom String("Passive"), Custom String("Global - Regeneration"), True, 0));
        Set Global Variable(ADJ_REGEN_HPS, Workshop Setting Integer(Custom String("Passive"), Custom String("Global - Regeneration Healing per Second"), 25, 1, 100, 0));
        Set Global Variable(ADJ_REGEN_TIMER, Workshop Setting Integer(Custom String("Passive"), Custom String("Global - Regeneration Activation Time"), 5, 1, 30, 0));
        Set Global Variable(ANTI_CRASH_ACTIVATE_PERCENT, Workshop Setting Integer(Custom String("Anti Crash"), Custom String("Activation Percent"), 200, 0, 250, 0));
        Set Global Variable(ANTI_CRASH_HOLD_TIME, Workshop Setting Real(Custom String("Anti Crash"), Custom String("Activation Hold Time"), 5.5, 0, 20, 0));
        Set Global Variable(ANTI_CRASH_DEACTIVATE_PERCENT, Workshop Setting Integer(Custom String("Anti Crash"), Custom String("Deactivation Percent"), 110, 0, 250, 0));
    }
}

rule ("[utilities/global.opy] Initialize player variables") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    actions {
        Set Player Variable(Event Player, within_shout_radius, False);
        Set Player Variable(Event Player, DamageRecieved, 100);
        Set Player Variable(Event Player, MoveSpeed, 100);
        Set Player Variable(Event Player, Echo_Copy, False);
        Set Player Variable(Event Player, Within_speed_radius, False);
    }
}

rule ("[utilities/custom_hp.opy]: clearCustomHp()") {
    event {
        Subroutine;
        clearCustomHp;
    }
    actions {
        Remove All Health Pools From Player(Event Player);
    }
}

rule ("[utilities/custom_hp.opy]: applyCustomHp()") {
    event {
        Subroutine;
        applyCustomHp;
    }
    actions {
        "eventPlayer.setHealingReceived(0)\neventPlayer.setHealth(1)\neventPlayer.addHealthPool(Health.NORMAL, 1, true)\neventPlayer.addHealthPool(Health.ARMOR, 1, true)\neventPlayer.addHealthPool(Health.SHIELDS, 1, true)"
        Set Status(Event Player, Null, Invincible, 999999986991104);
        "eventPlayer.removeAllHealthPools()\nwait(0.064)"
        Wait(0.016, Ignore Condition);
        "waitUntil(eventPlayer.getMaxHealth() <= 1, 1)\nApply custom health pool to player"
        If(Compare(First Of((Event Player).custom_hp_pvar), >, 0));
            Add Health Pool To Player(Event Player, Health, Max(1, First Of((Event Player).custom_hp_pvar)), True, True);
        End;
        If(Compare(Value In Array((Event Player).custom_hp_pvar, 1), >, 0));
            Add Health Pool To Player(Event Player, Armor, Max(1, Value In Array((Event Player).custom_hp_pvar, 1)), True, True);
        End;
        If(Compare(Value In Array((Event Player).custom_hp_pvar, 2), >, 0));
            Add Health Pool To Player(Event Player, Shields, Max(1, Value In Array((Event Player).custom_hp_pvar, 2)), True, True);
        End;
        "eventPlayer.setHealingReceived(100)"
        Heal(Event Player, Null, 999999986991104);
        Clear Status(Event Player, Invincible);
    }
}

rule ("[utilities/hero_switch.opy]: detect hero switch") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Event Player).hero_switch_pvar) != Hero Of(Event Player);
    }
    actions {
        Set Player Variable At Index(Event Player, hero_switch_pvar, 1, True);
        Wait(0.016, Ignore Condition);
        Set Player Variable At Index(Event Player, hero_switch_pvar, 0, Hero Of(Event Player));
        "eventPlayer._hero_id = heroID(eventPlayer._last_hero_played)"
        Set Player Variable At Index(Event Player, hero_switch_pvar, 1, False);
    }
}

rule ("[utilities/hero_switch.opy]: Initialize hero on hero switch") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).hero_switch_pvar, 1) != False;
    }
    actions {
        Wait Until(Has Spawned(Event Player), 999999986991104);
        Wait Until(Not(Value In Array((Event Player).hero_switch_pvar, 1)), 999999986991104);
        Set Player Variable(Event Player, hero_setup, Hero Of(Event Player));
        Call Subroutine(resetHero);
        Call Subroutine(initHero);
    }
}

rule ("[utilities/hero_switch.opy]: Reinitialize hero on new round") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Between Rounds == True;
    }
    actions {
        Wait Until(Not(Is Between Rounds), 999999986991104);
        Call Subroutine(resetHero);
        Call Subroutine(initHero);
    }
}

rule ("[utilities/anti_crash.opy]: Activate anti crash") {
    event {
        Ongoing - Global;
    }
    conditions {
        Server Load > Global.ANTI_CRASH_ACTIVATE_PERCENT;
    }
    actions {
        Wait(Global.ANTI_CRASH_HOLD_TIME, Abort When False);
        Small Message(All Players(All Teams), Custom String("Crash protection in progress..."));
        Set Slow Motion(1);
        Wait Until(Compare(Server Load, <, Global.ANTI_CRASH_DEACTIVATE_PERCENT), 999999986991104);
        Set Slow Motion(100);
    }
}

rule ("[utilities/hud.opy]: Padding lines for HUD display Roadhog and Sombra (makes it visable to spectators)") {
    event {
        Ongoing - Global;
    }
    conditions {
        Global.Spectator_padding == Null;
        Global.DEBUG_MODE == False;
    }
    actions {
        Create HUD Text(Local Player, Null, Null, Custom String(" \r\n\r\n\r\n\r"), Left, 1, Null, Null, Color(White), Visible To and String, Visible Never);
        Set Global Variable(Spectator_padding, True);
    }
}

rule ("[utilities/hud.opy]: Display buffs from Roadhog, Hanzo and Sombra") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Global.DEBUG_MODE == False;
    }
    actions {
        Create HUD Text(Event Player, Null, Null, Custom String(" \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                                                         {0} {1} {2}", If-Then-Else(Compare((Event Player).Roadhog_vape_hud_icon, ==, True), Ability Icon String(Hero(Roadhog), Button(Secondary Fire)), Custom String(" ")), If-Then-Else(Compare((Event Player).Sombra_hack_icon, ==, True), Ability Icon String(Hero(Sombra), Button(Ultimate)), Custom String(" ")), If-Then-Else((Event Player).Hanzo_Marked_icon, Icon String(Skull), Custom String(" "))), Left, 2, Null, Null, Color(White), Visible To and String, Default Visibility);
        Set Player Variable(Event Player, Status_effect_hud, Last Text ID);
    }
}

rule ("[utilities.opy]: destroy all huds and effects between rounds") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Between Rounds == True;
    }
    actions {
        Destroy All Progress Bar In-World Text;
        Destroy All In-World Text;
        Destroy All Effects;
        Destroy All Progress Bar HUD Text;
    }
}

rule ("[role_lock.opy]: Global/set all Heroes") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable(AllTankHeroes, Array(Hero(D.Va), Hero(Junker Queen), Hero(Mauga), Hero(Orisa), Hero(Ramattra), Hero(Reinhardt), Hero(Roadhog), Hero(Sigma), Hero(Venture), Hero(Winston), Hero(Wrecking Ball), Hero(Zarya), Hero(Hazard)));
        Set Global Variable(AllDpsHeroes, Array(Hero(Ashe), Hero(Bastion), Hero(Cassidy), Hero(Echo), Hero(Genji), Hero(Hanzo), Hero(Junkrat), Hero(Pharah), Hero(Reaper), Hero(Sojourn), Hero(Soldier: 76), Hero(Torbjörn), Hero(Tracer), Hero(Widowmaker), Hero(Symmetra), Hero(Freja), Hero(Doomfist), Hero(Mei)));
        Set Global Variable(AllSupportHeroes, Array(Hero(Ana), Hero(Baptiste), Hero(Brigitte), Hero(Illari), Hero(Juno), Hero(Kiriko), Hero(Lifeweaver), Hero(Lúcio), Hero(Mercy), Hero(Moira), Hero(Sombra), Hero(Zenyatta)));
    }
}

rule ("[role_lock.opy]: Role Limits") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable(AllRoles, Array(Workshop Setting Integer(Custom String("Roles"), Custom String("Tank Role Cap"), 0, 0, 6, 0), Workshop Setting Integer(Custom String("Roles"), Custom String("Damage Role Cap"), 0, 0, 6, 1), Workshop Setting Integer(Custom String("Roles"), Custom String("Support Role Cap"), 0, 0, 6, 2)));
    }
}

rule ("[role_lock.opy]: Player Init") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    actions {
        Set Player Variable(Event Player, AllowedHeroes, All Heroes);
    }
}

rule ("[role_lock.opy]: Tank") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllTankHeroes, Hero Of(Current Array Element))), Event Player)) >= First Of(Global.AllRoles);
        First Of(Global.AllRoles) > 0;
    }
    actions {
        If(Compare((Event Player).Echo_Copy, ==, False));
            Modify Player Variable(Event Player, AllowedHeroes, Remove From Array By Value, Global.AllTankHeroes);
            Set Player Allowed Heroes(Event Player, (Event Player).AllowedHeroes);
            Wait Until(Compare(Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllTankHeroes, Hero Of(Current Array Element))), Event Player)), <, First Of(Global.AllRoles)), 99999);
            Modify Player Variable(Event Player, AllowedHeroes, Append To Array, Global.AllTankHeroes);
            Set Player Allowed Heroes(Event Player, (Event Player).AllowedHeroes);
    }
}

rule ("[role_lock.opy]: Damage") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllDpsHeroes, Hero Of(Current Array Element))), Event Player)) >= Value In Array(Global.AllRoles, 1);
        Value In Array(Global.AllRoles, 1) > 0;
    }
    actions {
        If(Compare((Event Player).Echo_Copy, ==, False));
            Modify Player Variable(Event Player, AllowedHeroes, Remove From Array By Value, Global.AllDpsHeroes);
            Set Player Allowed Heroes(Event Player, (Event Player).AllowedHeroes);
            Wait Until(Compare(Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllDpsHeroes, Hero Of(Current Array Element))), Event Player)), <, Value In Array(Global.AllRoles, 1)), 99999);
            Modify Player Variable(Event Player, AllowedHeroes, Append To Array, Global.AllDpsHeroes);
            Set Player Allowed Heroes(Event Player, (Event Player).AllowedHeroes);
    }
}

rule ("[role_lock.opy]: Support") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllSupportHeroes, Hero Of(Current Array Element))), Event Player)) >= Value In Array(Global.AllRoles, 2);
        Value In Array(Global.AllRoles, 2) > 0;
    }
    actions {
        If(Compare((Event Player).Echo_Copy, ==, False));
            Modify Player Variable(Event Player, AllowedHeroes, Remove From Array By Value, Global.AllSupportHeroes);
            Set Player Allowed Heroes(Event Player, (Event Player).AllowedHeroes);
            Wait Until(Compare(Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllSupportHeroes, Hero Of(Current Array Element))), Event Player)), <, Value In Array(Global.AllRoles, 2)), 99999);
            Modify Player Variable(Event Player, AllowedHeroes, Append To Array, Global.AllSupportHeroes);
            Set Player Allowed Heroes(Event Player, (Event Player).AllowedHeroes);
    }
}

rule ("[role_lock.opy]: Skip Assemble Heroes") {
    event {
        Ongoing - Global;
    }
    conditions {
        Is Assembling Heroes == True;
    }
    actions {
        Wait(1, Ignore Condition);
        Set Match Time(1);
        Wait Until(Not(Is Assembling Heroes), 99999);
        Set Match Time(60);
    }
}

rule ("[passives/tank/ult_charge.opy]: resetUltCharge()") {
    event {
        Subroutine;
        resetUltCharge;
    }
    actions {
        Set Player Variable At Index(Event Player, ult_charge_pvar, 0, 0);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 0);
        Wait Until(Compare(Ultimate Charge Percent(Event Player), >, 0), 1);
        Set Ultimate Charge(Event Player, 0);
    }
}

rule ("[passives/tank/ult_charge.opy]: Remember missing ult charge from damaging tank") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Array Contains(All Tank Heroes, Hero Of(Victim)) == True;
        Is Using Ultimate(Event Player) == False;
        Victim != Event Player;
    }
    actions {
        Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Add, Multiply(Divide(Subtract(40, Global.ADJ_TANK_ULT_NEGATION_PERCENT), 100), Event Damage));
    }
}

rule ("[passives/tank/ult_charge.opy]: Remember missing ult charge from healing tank (+ workshop healing ultcharge)") {
    event {
        Player Dealt Healing;
        All;
        All;
    }
    conditions {
        "@Condition healee.getHero() in getTankHeroes() == true"
        Or(Or(Or(Or(Array Contains(All Tank Heroes, Hero Of(Healee)), And(Compare(Hero Of(Event Player), ==, Hero(Sombra)), Not(Event Was Health Pack))), And(Compare(Hero Of(Event Player), ==, Hero(Mercy)), Compare(Event Ability, !=, Button(Primary Fire)))), And(Compare(Healee, !=, Event Player), Compare(Hero Of(Event Player), ==, Hero(Roadhog)))), Compare(Hero Of(Event Player), ==, Hero(Mauga))) == True;
        Is Using Ultimate(Event Player) == False;
        Ultimate Charge Percent(Event Player) < 100;
    }
    actions {
        If(Or(And(Compare(Hero Of(Event Player), ==, Hero(Sombra)), Not(Event Was Health Pack)), Or(Or(And(Compare(Hero Of(Event Player), ==, Hero(Mercy)), Compare(Event Ability, !=, Button(Primary Fire))), And(Compare(Healee, !=, Event Player), Compare(Hero Of(Event Player), ==, Hero(Roadhog)))), Compare(Hero Of(Event Player), ==, Hero(Mauga)))));
            Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Add, Event Healing);
        Else If(Array Contains(All Tank Heroes, Hero Of(Healee)));
            Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Add, Multiply(Divide(Subtract(40, Global.ADJ_TANK_ULT_NEGATION_PERCENT), 100), Event Healing));
    }
}

disabled rule ("[passives/tank/ult_charge.opy]: Remember missing ult charge from healing tank") {
    event {
        Player Dealt Healing;
        All;
        All;
    }
    conditions {
        Array Contains(All Tank Heroes, Hero Of(Healee)) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Add, Multiply(Divide(Subtract(40, Global.ADJ_TANK_ULT_NEGATION_PERCENT), 100), Event Healing));
    }
}

rule ("[passives/tank/ult_charge.opy]: Compensate missing ultimate percentage") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Event Player).ult_charge_pvar) > Multiply(0.01, Value In Array((Event Player).ult_charge_pvar, 1));
        "guard to protect ult resetting accidentally"
        Value In Array((Event Player).ult_charge_pvar, 1) > 0;
    }
    actions {
        Set Player Variable At Index(Event Player, ult_charge_pvar, 2, Round To Integer(Multiply(100, Divide(Add(Multiply(Divide(Ultimate Charge Percent(Event Player), 100), Value In Array((Event Player).ult_charge_pvar, 1)), First Of((Event Player).ult_charge_pvar)), Value In Array((Event Player).ult_charge_pvar, 1))), Up));
        Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Subtract, Subtract(Multiply(Divide(Value In Array((Event Player).ult_charge_pvar, 2), 100), Value In Array((Event Player).ult_charge_pvar, 1)), Multiply(Divide(Ultimate Charge Percent(Event Player), 100), Value In Array((Event Player).ult_charge_pvar, 1))));
        Set Ultimate Charge(Event Player, Value In Array((Event Player).ult_charge_pvar, 2));
    }
}

rule ("[passives/tank/ult_charge.opy]: Reset ult compensation after using ult") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, ult_charge_pvar, 0, 0);
    }
}

rule ("[passives/tank/knockback.opy]: removeTankPassive()") {
    event {
        Subroutine;
        removeTankPassive;
    }
    actions {
        Set Knockback Received(Event Player, 130);
    }
}

rule ("[passives/damage/damage_passive.opy]: Remove DPS Passive") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        Array Contains(All Damage Heroes, Hero Of(Attacker)) == True;
        Attacker != Victim;
    }
    actions {
        If(Array Contains(All Tank Heroes, Hero Of(Victim)));
            Set Healing Received(Event Player, 112.5);
        Else;
            Set Healing Received(Event Player, 125);
        End;
        Wait(0.5, Ignore Condition);
        Wait(2.5, Restart When True);
        Set Healing Received(Event Player, 100);
    }
}

rule ("[passives/damage/healthpack.opy] Healthpacks substitute healing") {
    event {
        Player Received Healing;
        All;
        All;
    }
    conditions {
        Event Was Health Pack == True;
    }
    actions {
        If(Compare(Event Healing, >=, 250));
            If(Compare(Event Healing, >, 251));
                If(Array Contains(All Tank Heroes, Hero Of(Event Player)));
                    Heal(Event Player, Null, 39);
                Else;
                    Heal(Event Player, Null, 8);
                End;
            Else;
                Heal(Event Player, Null, 70);
            End;
        Else If(Compare(Event Healing, >=, 75));
            If(Compare(Event Healing, >, 76));
                If(Array Contains(All Tank Heroes, Hero Of(Event Player)));
                    Heal(Event Player, Null, 16);
                Else;
                    Heal(Event Player, Null, 6);
                End;
            Else;
                Heal(Event Player, Null, 25);
    }
}

rule ("[debug_mode.opy]: Global init") {
    event {
        Ongoing - Global;
    }
    conditions {
        Global.DEBUG_MODE == True;
    }
    actions {
        "By Lotto"
        Set Global Variable(dpsTime, Workshop Setting Integer(Custom String("Dev Tools"), Custom String("Calculate DPS over seconds"), 20, 1, 200, 1));
        Create HUD Text(All Players(All Teams), Null, Null, Custom String("[{0}] -- Start/reset the DPS calculation.", Input Binding String(Button(Interact))), Left, 0, Null, Null, Color(Green), Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Null, Custom String("[Crouch] + [Jump] -- Spawn a bot."), Left, 1, Null, Null, Color(Turquoise), Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Null, Custom String("[Crouch] + [Melee] -- Remove all bots."), Left, 2, Null, Null, Color(Orange), Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Null, Custom String("Hold [Melee] -- Change Hero."), Left, 3, Null, Null, Color(Rose), Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Null, Custom String(" "), Left, 4, Null, Null, Color(White), Visible To and String, Default Visibility);
    }
}

rule ("[debug_mode.opy]: Player init") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Global.DEBUG_MODE == True;
    }
    actions {
        Chase Player Variable At Rate(Event Player, time, 0, 1, Destination and Rate);
        Create HUD Text(Event Player, (Event Player).damage, Custom String("Total damage"), Null, Left, 5, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
        Create HUD Text(Event Player, Divide((Event Player).damage, Subtract(Global.dpsTime, (Event Player).time)), Custom String("DPS"), Null, Left, 6, Color(Red), Color(White), Color(White), Visible To and String, Default Visibility);
        Create HUD Text(Event Player, (Event Player).time, Custom String("Time"), Null, Left, 7, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
        Create HUD Text(Event Player, (Event Player).healing, Custom String("Total healing"), Null, Left, 8, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
        Create HUD Text(Event Player, Divide((Event Player).healing, Subtract(Global.dpsTime, (Event Player).time)), Custom String("HPS"), Null, Left, 9, Color(Red), Color(White), Color(White), Visible To and String, Default Visibility);
        Create HUD Text(Event Player, Custom String("{0}", Speed Of(Event Player)), Null, Null, Top, 0, Color(White), Null, Null, Visible To and String, Default Visibility);
    }
}

rule ("[debug_mode.opy]: Player Dealt Damage") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Victim != Attacker;
        Global.DEBUG_MODE == True;
    }
    actions {
        "Inspired by a damage numbers mode by Darwin"
        Destroy In-World Text((Event Player).textID);
        Set Player Variable(Event Player, position, Eye Position(Victim));
        Create In-World Text(Event Player, Event Damage, (Event Player).position, Add(0.85, Divide(Event Damage, 30)), Clip Against Surfaces, Visible To Position and String, Color(White), Default Visibility);
        Set Player Variable(Event Player, textID, Last Text ID);
        Chase Player Variable At Rate(Event Player, position, Add(Eye Position(Victim), Up), 0.9, None);
        Skip If(Compare((Event Player).time, ==, 0), 1);
        Modify Player Variable(Event Player, damage, Add, Event Damage);
        //lbl_0:
    }
}

rule ("[debug_mode.opy]: Start") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Button Held(Event Player, Button(Interact)) == True;
        Global.DEBUG_MODE == True;
    }
    actions {
        Set Player Variable(Event Player, time, Global.dpsTime);
        Set Player Variable(Event Player, damage, 0);
        Set Player Variable(Event Player, healing, 0);
    }
}

rule ("[debug_mode.opy]: Spawn bot") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Button Held(Event Player, Button(Crouch)) == True;
        Is Button Held(Event Player, Button(Jump)) == True;
        Global.DEBUG_MODE == True;
    }
    actions {
        Create Dummy Bot(Hero(Ana), Opposite Team Of(Team Of(Event Player)), -1, Position Of(Event Player), Facing Direction Of(Event Player));
        Set Global Variable(bot, Last Created Entity);
        Wait(0.1, Ignore Condition);
        Set Max Health(Global.bot, 1000);
        Start Heal Over Time(Global.bot, Null, 9999, 50);
    }
}

rule ("[debug_mode.opy]: Remove all bots") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Button Held(Event Player, Button(Crouch)) == True;
        Is Button Held(Event Player, Button(Melee)) == True;
        Global.DEBUG_MODE == True;
    }
    actions {
        Destroy All Dummy Bots;
        Destroy In-World Text((Event Player).textID);
    }
}

rule ("[debug_mode.opy]: Change hero") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Button Held(Event Player, Button(Melee)) == True;
        Global.DEBUG_MODE == True;
    }
    actions {
        Wait(1, Abort When False);
        Set Player Variable(Event Player, position, Position Of(Event Player));
        Set Player Allowed Heroes(Event Player, Remove From Array(All Heroes, Hero Of(Event Player)));
        Wait(0.1, Ignore Condition);
        Set Player Allowed Heroes(Event Player, All Heroes);
        Destroy In-World Text((Event Player).textID);
        Wait Until(Has Spawned(Event Player), 99999);
        Teleport(Event Player, (Event Player).position);
    }
}

rule ("[debug_mode.opy]: Player Dealt Damage") {
    event {
        Player Dealt Healing;
        All;
        All;
    }
    conditions {
        Healee != Healer;
        Global.DEBUG_MODE == True;
    }
    actions {
        "Inspired by a damage numbers mode by Darwin"
        Destroy In-World Text((Event Player).textID);
        Set Player Variable(Event Player, position, Eye Position(Healee));
        Create In-World Text(Event Player, Event Healing, (Event Player).position, Add(0.85, Divide(Event Damage, 30)), Clip Against Surfaces, Visible To Position and String, Color(Yellow), Default Visibility);
        Set Player Variable(Event Player, textID, Last Text ID);
        Chase Player Variable At Rate(Event Player, position, Add(Eye Position(Healee), Up), 0.9, None);
        Skip If(Compare((Event Player).time, ==, 0), 1);
        Modify Player Variable(Event Player, healing, Add, Event Healing);
        //lbl_0:
    }
}

rule ("[debug_mode.opy]: Test Roadhog and Sombra new abilities") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Button Held(Event Player, Button(Melee)) == True;
        Global.DEBUG_MODE == True;
    }
    actions {
        Set Player Variable(Event Player, Roadhog_vape_confirmed, True);
        Set Player Variable(Event Player, Sombra_virus_confirmed, True);
        Set Player Variable(Event Player, hazard_bubble_confirmed, True);
        Set Player Variable(Event Player, Hanzo_Marked_icon, True);
    }
}

rule ("[ana/sleep.opy]: Sleep tanks as long as other heroes") {
    event {
        Player Dealt Damage;
        All;
        Ana;
    }
    conditions {
        Event Ability == Button(Ability 1);
        Array Contains(All Tank Heroes, Hero Of(Victim)) == True;
    }
    actions {
        Wait Until(Has Status(Victim, Asleep), 999999986991104);
        Wait(0.2, Ignore Condition);
        "Sleeping someone on top of sleep doesnt work anymore"
        Set Status(Victim, Attacker, Knocked Down, 4.8);
        Set Player Variable(Victim, Ana_Sleepdart_Target, True);
    }
}

rule ("[ana/sleep.opy]: Cleanse the sleep on tanks on damage") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        Has Status(Event Player, Knocked Down) == True;
        (Event Player).Ana_Sleepdart_Target == True;
    }
    actions {
        If(Compare(Ability Cooldown(Players On Hero(Hero(Ana), Opposite Team Of(Team Of(Event Player))), Button(Ability 1)), !=, 0));
            Clear Status(Event Player, Knocked Down);
            Set Player Variable(Event Player, Ana_Sleepdart_Target, Null);
    }
}

rule ("[ana/nade.opy]: Increase Biotic Grenade damage") {
    event {
        Player Dealt Damage;
        All;
        Ana;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.8, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[ana/nade.opy]: Increase Biotic Grenade healing") {
    event {
        Player Dealt Healing;
        All;
        Ana;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Heal(Healee, Healer, Subtract(Divide(Multiply(Event Healing, 1.334), Value In Array((Event Player).macro_pvar, 1)), Event Healing));
    }
}

rule ("[ana/init.opy]: initAna()") {
    event {
        Subroutine;
        initAna;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 200\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2300);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.667);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 1, 0.933);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[ana/init.opy]: Correct Sleep Dart and Ana Melee damage") {
    event {
        Player Dealt Damage;
        All;
        Ana;
    }
    conditions {
        Array Contains(Array(Button(Ability 1), Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[ana/init.opy]: Correct Sleep Dart and Ana Melee damage") {
    event {
        Player Dealt Damage;
        All;
        Ana;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.933), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[ashe/dynamite.opy]: Decreased dynamite damage by healing until timeout or cleansed = 85 damage") {
    event {
        Player Dealt Damage;
        All;
        Ashe;
    }
    conditions {
        Event Ability == Button(Ability 2);
        (Victim).Ashe_dynamite_hit == Null;
    }
    actions {
        Set Player Variable(Event Player, Ashe_dynamite_hit, True);
        Start Heal Over Time(Victim, Null, 5, 2);
        Set Player Variable(Victim, Ashe_Dynamite_Healing_ID, Last Healing Modification ID);
        Wait Until(Or(Has Status(Victim, Phased Out), Has Status(Victim, Invincible)), 5);
        Stop Heal Over Time((Victim).Ashe_Dynamite_Healing_ID);
        Set Player Variable(Victim, Ashe_Dynamite_Healing_ID, Null);
        Set Player Variable(Event Player, Ashe_dynamite_hit, Null);
    }
}

rule ("[ashe/viper.opy]: correct viper damage") {
    event {
        Player Dealt Damage;
        All;
        Ashe;
    }
    conditions {
        Event Ability == Button(Primary Fire);
        Is Button Held(Event Player, Button(Secondary Fire)) == False;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[ashe/init.opy]: initAshe()") {
    event {
        Subroutine;
        initAshe;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 200\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2240);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.934);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, max_health_scaler, 0.8);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[ashe/init.opy]: Correct damage numbers") {
    event {
        Player Dealt Damage;
        All;
        Ashe;
    }
    conditions {
        Array Contains(Array(Button(Ability 1), Button(Ability 2), Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[baptiste/regen_burst.opy]: Correct regenerative burst hps") {
    event {
        Player Dealt Healing;
        All;
        Baptiste;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        "self healing"
        If(Compare(Healee, ==, Healer));
            Heal(Healee, Healer, Subtract(Multiply(Divide(Event Healing, Value In Array((Event Player).macro_pvar, 1)), 3.75), Event Healing));
        Else;
            Heal(Healee, Healer, Subtract(Multiply(Divide(Event Healing, Value In Array((Event Player).macro_pvar, 1)), 2.125), Event Healing));
    }
}

rule ("[baptiste/regen_burst.opy]: Remove initial burst healing from Regenerative Burst and set cooldown for duplicate") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Healing Dealt(Event Player, 0);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999986991104);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
    }
}

rule ("[baptiste/init.opy]: initBaptiste()") {
    event {
        Subroutine;
        initBaptiste;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 200\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2440);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.96);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 1, 0.584);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Player Variable(Event Player, baptiste_balance_change_check, True);
        Set Player Variable(Event Player, max_health_scaler, 0.8);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[baptiste/init.opy]: Increase Baptiste melee damage") {
    event {
        Player Dealt Damage;
        All;
        Baptiste;
    }
    conditions {
        Array Contains(Array(Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[baptiste/init.opy]: Increase Biotic Launcher healing") {
    event {
        Player Dealt Healing;
        All;
        Baptiste;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Event Healing < 35;
        (Event Player).baptiste_balance_change_check != False;
    }
    actions {
        Set Player Variable(Event Player, baptiste_balance_change_check, False);
        Heal(Healee, Healer, Subtract(Multiply(Divide(Event Healing, Value In Array((Event Player).macro_pvar, 1)), 1.167), Event Healing));
        Wait(0.15, Ignore Condition);
        Set Player Variable(Event Player, baptiste_balance_change_check, True);
    }
}

rule ("[baptiste/init.opy]: Healing indicator") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Between Rounds == False;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0} {1}", Count Of(Filtered Array(All Living Players(Team Of(Event Player)), And(And(Compare(Distance Between(Event Player, Current Array Element), <=, 12), Is In Line of Sight(Event Player, Current Array Element, Enemy Barriers Block LOS)), Compare(Hero Of(Current Array Element), !=, Hero(Baptiste))))), Ability Icon String(Hero(Baptiste), Button(Ability 1))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(-0.35, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 2, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, Baptiste_hud, Last Text ID);
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Ability 1)), !=, 0), 99999);
        Destroy In-World Text((Event Player).Baptiste_hud);
    }
}

rule ("[baptiste/init.opy]: Clean up Baptiste") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Baptiste);
    }
    actions {
        Destroy In-World Text((Event Player).Baptiste_hud);
    }
}

rule ("[bastion/reconfigure.opy]: Reduce assault form damage and movement speed") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Damage Received(Event Player, 112.5);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 15);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait(0.95, Ignore Condition);
        Start Heal Over Time(Event Player, Event Player, 8, 15);
        Set Player Variable(Event Player, sentry_healing_id, Last Heal Over Time ID);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999986991104);
        Set Damage Received(Event Player, 100);
        Modify Player Variable(Event Player, MoveSpeed, Add, 15);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Stop Heal Over Time((Event Player).sentry_healing_id);
        Set Player Variable(Event Player, sentry_healing_id, Null);
    }
}

rule ("[bastion/reconfigure.opy]: Increase movement allowed by self-damage grenade") {
    event {
        Player Dealt Damage;
        All;
        Bastion;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Attacker == Victim;
    }
    actions {
        Modify Player Variable(Event Player, MoveSpeed, Add, 25);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        "Grace period to make sure the player receives this benefit"
        Wait(0.1, Ignore Condition);
        Wait Until(Is On Ground(Event Player), 999999986991104);
        "if not ruleCondition:\nreturn"
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 25);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

rule ("[bastion/init.opy]: initBastion()") {
    event {
        Subroutine;
        initBastion;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 50);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 5);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2300);
        Start Scaling Player(Event Player, 0.96, True);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[bastion/init.opy]: Reduce grenade self-damage") {
    event {
        Player Dealt Damage;
        All;
        Bastion;
    }
    conditions {
        Attacker == Victim;
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Multiply(Event Damage, 0.5)));
    }
}

rule ("[bastion/init.opy]: Clean up Bastion") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Bastion);
    }
    actions {
        Stop Heal Over Time((Event Player).Bastion_healing_id);
        Stop Heal Over Time((Event Player).sentry_healing_id);
    }
}

rule ("[brigitte/bash.opy]: Correct Shield Bash damage") {
    event {
        Player Dealt Damage;
        All;
        Brigitte;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[brigitte/bash.opy]: Track Bash cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        Is Firing Primary(Event Player) == True;
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, bash_cooldown, 5.3);
        Chase Player Variable At Rate(Event Player, bash_cooldown, 0, 1, None);
    }
}

rule ("[brigitte/bash.opy]: Force cooldown for Bash in Rally") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Primary Fire), (Event Player).bash_cooldown);
    }
}

rule ("[brigitte/inspire.opy]: Increase Inspire self healing") {
    event {
        Player Dealt Healing;
        All;
        Brigitte;
    }
    conditions {
        Healee == Healer;
    }
    actions {
        Heal(Healee, Null, Subtract(Multiply(Event Healing, 1.25), Event Healing));
    }
}

rule ("[brigitte/repair_pack.opy]: Increase Repair Pack healing") {
    event {
        Player Dealt Healing;
        All;
        Brigitte;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Heal(Healee, Healer, Subtract(Multiply(Event Healing, 1.25), Event Healing));
    }
}

rule ("[brigitte/repair_pack.opy]: Extra Repair Pack burst healing") {
    event {
        Player Dealt Healing;
        All;
        Brigitte;
    }
    conditions {
        Event Ability == Button(Ability 2);
        Event Healing >= 19;
    }
    actions {
        Heal(Healee, Healer, 5);
    }
}

rule ("[brigitte/init.opy]: initBrigitte()") {
    event {
        Subroutine;
        initBrigitte;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 15);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 10);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2625);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.778);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 1, 0.8);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[brigitte/init.opy]: Correct Whipshot damage") {
    event {
        Player Dealt Damage;
        All;
        Brigitte;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[cassidy/deadeye.opy]: Set damage during deadeye") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 100);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[cassidy/fanthehammer.opy]: Increase Fan the hammer damage to 40") {
    event {
        Player Dealt Damage;
        All;
        Cassidy;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.8, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[cassidy/flashbang.opy] Flashbang stun target for 0.4s") {
    event {
        Player Dealt Damage;
        All;
        Cassidy;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Set Status(Victim, Event Player, Stunned, 0.4);
    }
}

rule ("[cassidy/init.opy]: initMccree()") {
    event {
        Subroutine;
        initMccree;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 1);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1680);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.667);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[cassidy/init.opy]: Correct Cassidy melee damage and gun damage") {
    event {
        Player Dealt Damage;
        All;
        Cassidy;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Primary Fire)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[doomfist/meteor_strike.opy]: Correct Meteor Strike and Doomfist melee damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Ultimate)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Event Player, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[doomfist/meteor_strike.opy]: Doomfist ult remove self healing") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Healing Dealt(Event Player, 0);
        Wait Until(Not(Is Using Ultimate(Event Player)), 99999);
        Set Healing Dealt(Event Player, 100);
    }
}

rule ("[doomfist/punch.opy]: Initialize rocket punch") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.5);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, punched_victims, Empty Array);
        Set Player Variable(Event Player, wall_impacted_victims, Empty Array);
        Wait Until(Not(Is Firing Secondary(Event Player)), 4);
        Wait(0.2, Ignore Condition);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.8);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[doomfist/punch.opy]: Find wall impacted victims") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Array Contains((Attacker).punched_victims, Victim) == True;
        Array Contains((Attacker).wall_impacted_victims, Victim) == False;
    }
    actions {
        Modify Player Variable(Attacker, wall_impacted_victims, Append To Array, Victim);
        Clear Status(Victim, Stunned);
        "OW1 single punch victim"
        If(Compare(Count Of((Attacker).punched_victims), ==, 1));
            Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Attacker).macro_pvar)), Event Damage), First Of((Attacker).macro_pvar)));
        Else;
    }
}

rule ("[doomfist/punch.opy]: Find punched victims") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Array Contains((Attacker).punched_victims, Victim) == False;
    }
    actions {
        Modify Player Variable(Attacker, punched_victims, Append To Array, Victim);
        "OW1 single punch victim"
        If(Compare(Count Of((Attacker).punched_victims), ==, 1));
            Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Attacker).macro_pvar)), Event Damage), First Of((Attacker).macro_pvar)));
        Else;
    }
}

disabled rule ("[doomfist/powerblock.opy]: Reduce Power Block active duration") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait(1.75, Ignore Condition);
        Press Button(Event Player, Button(Ability 2));
    }
}

rule ("[doomfist/powerblock.opy]: Cancel Powerblock animation") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait(0.15, Ignore Condition);
        Set Ability 2 Enabled(Event Player, False);
    }
}

rule ("[doomfist/uppercut.opy]: Execute main logic for Rising Uppercut ability") {
    event {
        Subroutine;
        executeUppercut;
    }
    actions {
        "Clear uppercut victims"
        Set Player Variable(Event Player, uppercut_victims, Empty Array);
        "Start of uppercut"
        Set Player Variable(Event Player, is_using_uppercut, True);
        "Doomfist phases through enemies during uppercut"
        Disable Movement Collision With Players(Event Player);
        "Doomfist cannot melee during uppercut"
        Disallow Button(Event Player, Button(Melee));
        "Doomfist cannot shoot during uppercut"
        Disallow Button(Event Player, Button(Primary Fire));
        "Doomfist cannot punch during uppercut"
        Set Secondary Fire Enabled(Event Player, False);
        "Uppercut physics\nCancel current momentum"
        Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
        "Move laterally in the facing direction"
        Apply Impulse(Event Player, Vector(X Component Of(Facing Direction Of(Event Player)), 0, Z Component Of(Facing Direction Of(Event Player))), 5, To World, Incorporate Contrary Motion);
        "Override gravity during uppercut"
        Set Gravity(Event Player, 0);
        "Deny player from inputting movement commands"
        Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
        Communicate(Event Player, Goodbye);
        Wait(0.15, Ignore Condition);
        Apply Impulse(Event Player, Up, 40, To World, Incorporate Contrary Motion);
        Wait(0.1, Ignore Condition);
        Apply Impulse(Event Player, Down, Max(0, Speed Of In Direction(Event Player, Up)), To World, Incorporate Contrary Motion);
        "End of uppercut"
        Set Player Variable(Event Player, is_using_uppercut, False);
        Wait(0.016, Ignore Condition);
        Apply Impulse(Event Player, Up, 2.5, To World, Incorporate Contrary Motion);
        Set Gravity(Event Player, 0);
        Enable Movement Collision With Players(Event Player);
        Allow Button(Event Player, Button(Melee));
        Allow Button(Event Player, Button(Primary Fire));
        Set Secondary Fire Enabled(Event Player, True);
        Wait(0.35, Ignore Condition);
        Set Ability 2 Enabled(Event Player, True);
        Stop Forcing Throttle(Event Player);
        Wait(0.15, Ignore Condition);
        Set Gravity(Event Player, 50);
        Wait(0.25, Ignore Condition);
        Set Gravity(Event Player, 100);
    }
}

rule ("[doomfist/uppercut.opy]: Control flow for Uppercut") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Call Subroutine(executeUppercut);
    }
}

rule ("[doomfist/uppercut.opy]: Detect Uppercut Victims") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is True For Any(Filtered Array(Players Within Radius(Event Player, 7, Opposite Team Of(Team Of(Event Player)), Surfaces), Compare(Hero Of(Current Array Element), ==, Hero(Doomfist))), Compare((Current Array Element).is_using_uppercut, ==, True)) == True;
        Angle Between Vectors(Normalize(Vector(X Component Of(Facing Direction Of(First Of(Filtered Array(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player))), Compare((Current Array Element).is_using_uppercut, ==, True))))), 0, Z Component Of(Facing Direction Of(First Of(Filtered Array(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player))), Compare((Current Array Element).is_using_uppercut, ==, True))))))), Direction Towards(First Of(Filtered Array(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player))), Compare((Current Array Element).is_using_uppercut, ==, True))), Event Player)) <= 90;
        Array Contains((First Of(Filtered Array(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player))), Compare((Current Array Element).is_using_uppercut, ==, True)))).uppercut_victims, Event Player) == False;
        (Event Player).Orisa_fortified == Null;
    }
    actions {
        Modify Player Variable(First Of(Filtered Array(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player))), Compare((Current Array Element).is_using_uppercut, ==, True))), uppercut_victims, Append To Array, Event Player);
        Damage(Event Player, First Of(Filtered Array(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player))), Compare((Current Array Element).is_using_uppercut, ==, True))), Divide(60, First Of((Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player)))).macro_pvar)));
        Play Effect(All Players(All Teams), Bad Explosion, Color(White), Event Player, 1);
        Play Effect(All Players(All Teams), Explosion Sound, Color(White), Event Player, 80);
        "eventPlayer.applyImpulse(Vector.UP, 13, Relativity.TO_PLAYER)\nUppercut physics\nCancel current momentum"
        Apply Impulse(Event Player, Velocity Of(Event Player), Multiply(-1, Speed Of(Event Player)), To World, Incorporate Contrary Motion);
        Apply Impulse(Event Player, Vector(X Component Of(Facing Direction Of(First Of(Filtered Array(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player))), Compare((Current Array Element).is_using_uppercut, ==, True))))), 0, Z Component Of(Facing Direction Of(First Of(Filtered Array(Players On Hero(Hero(Doomfist), Opposite Team Of(Team Of(Event Player))), Compare((Current Array Element).is_using_uppercut, ==, True)))))), 5, To World, Cancel Contrary Motion XYZ);
        "Override gravity during uppercut"
        Set Gravity(Event Player, 0);
        Wait(0.15, Ignore Condition);
        Apply Impulse(Event Player, Up, 40, To World, Incorporate Contrary Motion);
        Wait(0.1, Ignore Condition);
        Apply Impulse(Event Player, Down, Max(0, Speed Of In Direction(Event Player, Up)), To World, Incorporate Contrary Motion);
        Wait(0.016, Ignore Condition);
        Apply Impulse(Event Player, Up, 2.5, To World, Incorporate Contrary Motion);
        Set Gravity(Event Player, 0);
        Wait(0.35, Ignore Condition);
        Stop Forcing Throttle(Event Player);
        Wait(0.15, Ignore Condition);
        Set Gravity(Event Player, 50);
        Wait(0.25, Ignore Condition);
        Set Gravity(Event Player, 100);
    }
}

rule ("[doomfist/uppercut.opy]: Shields for Uppercut") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        (Event Player).is_using_uppercut == True;
    }
    actions {
        Wait Until(Compare((Event Player).is_using_uppercut, ==, False), 99999);
        Set Player Variable(Event Player, number_of_victims_uppercut, Count Of((Event Player).uppercut_victims));
        Add Health Pool To Player(Event Player, Health, Multiply((Event Player).number_of_victims_uppercut, 25), False, True);
        Set Player Variable(Event Player, doom_uppercut_shields, Last Created Health Pool);
    }
}

rule ("[doomfist/dps.opy]: initDoomfistDPS()") {
    event {
        Subroutine;
        initDoomfistDPS;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 15);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1750);
        Call Subroutine(removeTankPassive);
        Start Scaling Player(Event Player, 0.92, True);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.82);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, max_health_scaler, 0.625);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[doomfist/dps.opy]: doom cap health at 400") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Health(Event Player) > 400;
    }
    actions {
        Set Player Health(Event Player, 400);
    }
}

rule ("[doomfist/dps.opy]: Increase headshot damage taken") {
    event {
        Player Took Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Was Critical Hit == True;
    }
    actions {
        Damage(Event Player, Attacker, Multiply(Event Damage, 0.25));
    }
}

rule ("[doomfist/seismic_slam.opy]: Correct Seismic Slam damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Damage(Victim, Event Player, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.8), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[doomfist/hand_cannon.opy]: Correct Hand Cannon damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Event Player, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.91), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[doomfist/init.opy]: initDoomfist()") {
    event {
        Subroutine;
        initDoomfist;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 450);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1750);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.8);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, max_health_scaler, 0.625);
        Set Player Variable(Event Player, punched_victims, Empty Array);
        Set Player Variable(Event Player, wall_impacted_victims, Empty Array);
        Set Player Variable(Event Player, uppercut_victims, Empty Array);
        Set Player Variable(Event Player, is_using_uppercut, False);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[doomfist/init.opy]: Clean up Doomfist") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Doomfist);
    }
    actions {
        Set Player Variable(Event Player, punched_victims, Null);
        Set Player Variable(Event Player, wall_impacted_victims, Null);
        Set Player Variable(Event Player, uppercut_victims, Null);
        Set Player Variable(Event Player, is_using_uppercut, Null);
        Set Player Variable(Event Player, doom_uppercut_shields, Null);
        Set Player Variable(Event Player, number_of_victims_uppercut, Null);
    }
}

rule ("[dva/boosters.opy]: Reduce Boosters damage") {
    event {
        Player Dealt Damage;
        All;
        D.Va;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Divide(Multiply(0.8, Event Damage), First Of((Event Player).macro_pvar))));
    }
}

rule ("[dva/hp.opy]: Correct DVa mech health") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup == Hero(D.Va);
        Is In Alternate Form(Event Player) == False;
        (Event Player).hero_initialized != False;
    }
    actions {
        Call Subroutine(clearCustomHp);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 169);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
    }
}

rule ("[dva/hp.opy]: Correct DVa pilot health") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup == Hero(D.Va);
        Is In Alternate Form(Event Player) == True;
        Max Health Of Type(Event Player, Health) != 150;
        (Event Player).hero_initialized != False;
    }
    actions {
        Call Subroutine(clearCustomHp);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 28);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
    }
}

rule ("[dva/defense_matrix.opy]: Increase Defense Matrix cooldown") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        "Defense Matrix still goes on cooldown visually even when the ability is disabled, so a faux cooldown was not implemented"
        Wait Until(Not(Is Firing Secondary(Event Player)), 999999986991104);
        Set Secondary Fire Enabled(Event Player, False);
        Wait(1.5, Ignore Condition);
        Set Secondary Fire Enabled(Event Player, True);
    }
}

rule ("[dva/init.opy]: initDva()") {
    event {
        Subroutine;
        initDva;
    }
    actions {
        "setCustomHp(\nADJ_DVA_HEALTH_DUPLICATE if eventPlayer.isDuplicatingAHero() or SETTING_ECHO_TANK_HP else ADJ_DVA_HEALTH,\nADJ_DVA_ARMOR_DUPLICATE if eventPlayer.isDuplicatingAHero() or SETTING_ECHO_TANK_HP else ADJ_DVA_ARMOR,\n0)"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1540);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.91);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, self_destruct_charge, 0);
        Set Player Variable(Event Player, max_health_scaler, 0.857);
        Wait Until(Not(Is In Alternate Form(Event Player)), 999999986991104);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 169);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[dva/init.opy]: Reduce Micro Missiles damage") {
    event {
        Player Dealt Damage;
        All;
        D.Va;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Divide(Multiply(0.75, Event Damage), First Of((Event Player).macro_pvar))));
    }
}

rule ("[dva/init.opy]: Increase D.va other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        D.Va;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Ultimate)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[dva/init.opy]: Force reset ult charge when DVa exits Mech") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is In Alternate Form(Event Player) == True;
    }
    actions {
        Abort If(Is Using Ultimate(Event Player));
        Set Ultimate Charge(Event Player, 0);
    }
}

rule ("[echo/copy.opy] Echo new ultimate") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Button Held(Event Player, Button(Ultimate)) == True;
        (Event Player).hero_setup == Hero(Echo);
    }
    actions {
        If(And(Is Alive(Event Player), Compare(Ultimate Charge Percent(Event Player), ==, 100)));
            Set Player Variable(All Players(Team Of(Event Player)), Echo_Copy, True);
            Start Forcing Player To Be Hero(Event Player, Hero Of(First Of(Sorted Array(Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))), And(And(And(And(Compare(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)), <=, 19), Has Spawned(Current Array Element)), Compare(Distance Between(Event Player, Current Array Element), <=, 40)), Compare(Current Array Element, !=, Players On Hero(Hero(Echo), All Teams))), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element))))));
            If(Compare(Hero Of(Event Player), !=, Hero(Echo)));
                Set Status(Event Player, Null, Frozen, 1);
                Set Status(Event Player, Null, Phased Out, 1);
                Wait(1, Ignore Condition);
                Set Ultimate Charge(Event Player, 92);
                Call Subroutine(EchoCopy);
                Wait Until(Is Dead(Event Player), 16);
                Destroy Progress Bar In-World Text((Event Player).EchoHUD);
                Stop Chasing Player Variable(Event Player, EchoUltSeconds);
                Start Forcing Player To Be Hero(Event Player, Hero(Echo));
                Stop Forcing Player To Be Hero(Event Player);
                Set Player Variable(All Players(Team Of(Event Player)), Echo_Copy, False);
    }
}

rule ("[echo/ultimate.opy]: Sub for HUD") {
    event {
        Subroutine;
        EchoCopy;
    }
    actions {
        Set Player Variable(Event Player, EchoUltSeconds, 100);
        Chase Player Variable At Rate(Event Player, EchoUltSeconds, 0, 6.25, Destination and Rate);
        Create Progress Bar In-World Text(Event Player, (Event Player).EchoUltSeconds, Custom String("{0} {1}", Ability Icon String(Hero(Echo), Button(Ultimate)), Round To Integer(Divide((Event Player).EchoUltSeconds, 6.25), Up)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(-1, World Vector Of(Right, Event Player, Rotation)), Multiply(-0.25, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 0.75, Do Not Clip, Color(White), Color(White), Visible To Position Values and Color, Default Visibility);
        Set Player Variable(Event Player, EchoHUD, Last Text ID);
    }
}

rule ("[echo/init.opy]: initEcho()") {
    event {
        Subroutine;
        initEcho;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 125);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1880);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.833);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Start Scaling Player(Event Player, 0.94, True);
        Disallow Button(Event Player, Button(Ultimate));
        Set Player Variable(Event Player, MoveSpeed, 100);
        Set Move Speed(Event Player, 100);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[echo/init.opy]: Correct Echo Tri-Shot damage") {
    event {
        Player Dealt Damage;
        All;
        Echo;
    }
    conditions {
        Is Duplicating(Event Player) == False;
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.971), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[echo/init.opy]: Correct Echo other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        Echo;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Ability 2)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[echo/init.opy]: Clean up Echo") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Echo);
    }
    actions {
        Destroy Progress Bar In-World Text((Event Player).EchoHUD);
        Stop Chasing Player Variable(Event Player, EchoUltSeconds);
        Set Player Variable(All Players(Team Of(Event Player)), Echo_Copy, False);
        Set Player Variable(Event Player, EchoHUD, Null);
        Set Player Variable(Event Player, EchoUltSeconds, Null);
    }
}

rule ("[freja/init.opy]: initFreja()") {
    event {
        Subroutine;
        initFreja;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 200\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1750);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.667);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Start Scaling Player(Event Player, 0.96, True);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[freja/init.opy]: Correct Freja other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        Freja;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[freja/init.opy]: Correct Freja secondary impact damage") {
    event {
        Player Dealt Damage;
        All;
        Freja;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Event Damage < 59;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[freja/init.opy]: Correct Freja ultimate impact damage") {
    event {
        Player Dealt Damage;
        All;
        Freja;
    }
    conditions {
        Event Ability == Button(Ultimate);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
        Wait(1.3, Ignore Condition);
    }
}

rule ("[genji/dragonblade.opy]: Genji Damage in Ultimate 100 and reset deflect cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Genji;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Ability 2), 0);
        Set Damage Dealt(Event Player, 91);
        Wait Until(Not(Is Using Ultimate(Event Player)), 6);
        Set Damage Dealt(Event Player, 100);
    }
}

rule ("[genji/init.opy]: initGenji()") {
    event {
        Subroutine;
        initGenji;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 200\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1150);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[genji/init.opy]: Reduce Deflect duration") {
    event {
        Ongoing - Each Player;
        All;
        Genji;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait(1.5, Ignore Condition);
        Press Button(Event Player, Button(Ability 2));
    }
}

rule ("[hanzo/primary.opy]: Hanzo draw aura") {
    event {
        Ongoing - Each Player;
        All;
        Hanzo;
    }
    conditions {
        Is Firing Primary(Event Player) == True;
    }
    actions {
        "max draw time\nwait(0.8, Wait.ABORT_WHEN_FALSE)"
        Create Effect(Filtered Array(All Players(Opposite Team Of(Team Of(Event Player))), And(And(Compare(Distance Between(Event Player, Current Array Element), >=, 1), Is In View Angle(Event Player, Eye Position(Current Array Element), 30)), Compare((Current Array Element).Hanzo_Marked_icon, ==, True))), Good Aura, Custom Color(239, 47, 60, 125), Eye Position(Event Player), 0.475, Visible To Position and Radius);
        Set Player Variable(Event Player, HanzoDrawAura, Last Created Entity);
        Wait Until(Not(Is Firing Primary(Event Player)), 100000000);
        Destroy Effect((Event Player).HanzoDrawAura);
    }
}

rule ("[hanzo/stormarrow.opy]: Correct Arrow speed Storm arrows (110ms)") {
    event {
        Ongoing - Each Player;
        All;
        Hanzo;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Projectile Speed(Event Player, 200);
        Wait Until(Not(Is Using Ability 1(Event Player)), 6);
        Set Projectile Speed(Event Player, 100);
    }
}

rule ("[hanzo/mark.opy]: Mark enemy play effects") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).Hanzo_Marked_icon == True;
    }
    actions {
        Destroy In-World Text((Event Player).Hanzo_Marked_effect);
        Set Player Variable(Event Player, Hanzo_Marked_effect, Null);
        Create In-World Text(Players On Hero(Hero(Hanzo), Opposite Team Of(Team Of(Event Player))), Icon String(Skull), Add(Event Player, Vector(0, 2.5, 0)), 1.2, Do Not Clip, Visible To Position and String, Color(Red), Default Visibility);
        Set Player Variable(Event Player, Hanzo_Marked_effect, Last Text ID);
    }
}

rule ("[hanzo/mark.opy]: Extra damage on marked enemy") {
    event {
        Player Dealt Damage;
        All;
        Hanzo;
    }
    conditions {
        (Victim).Hanzo_Marked_icon == True;
        Array Contains(Array(Button(Primary Fire), Button(Ability 1), Button(Ultimate)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Event Player, Divide(Event Damage, First Of((Event Player).macro_pvar)));
    }
}

rule ("[hanzo/mark.opy]: Mark enemy on damage") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        Array Contains(Array(Button(Ability 1), Button(Primary Fire), Button(Ability 2)), Event Ability) == True;
        Hero Of(Attacker) == Hero(Hanzo);
    }
    actions {
        Wait(0.1, Ignore Condition);
        Set Player Variable(Event Player, Hanzo_Marked_icon, True);
        Wait(8, Restart When True);
        Set Player Variable(Event Player, Hanzo_Marked_icon, Null);
        Destroy In-World Text((Event Player).Hanzo_Marked_effect);
        Set Player Variable(Event Player, Hanzo_Marked_effect, Null);
    }
}

rule ("[hanzo/init.opy]: initHanzo()") {
    event {
        Subroutine;
        initHanzo;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 200\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1680);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.6);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[hanzo/init.opy]: Correct Hanzo other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        Hanzo;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Ultimate)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[hazard/spike_guard.opy] Increase damage on block to 230") {
    event {
        Player Dealt Damage;
        All;
        Hazard;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.94, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("Hazard Lifesteal heal 2 per spike") {
    event {
        Player Dealt Damage;
        All;
        Hazard;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Heal(Event Player, Null, 2);
    }
}

rule ("[hazard/violent_leap.opy] Increase damage violant leap to 70") {
    event {
        Player Dealt Damage;
        All;
        Hazard;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.813, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[hazard/downpour.opy]: hazard reveal enemies") {
    event {
        Player Dealt Damage;
        All;
        Hazard;
    }
    conditions {
        Has Status(Victim, Rooted) == True;
        Event Ability == Button(Ultimate);
        (Victim).Hazard_Downpour_Target == Null;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0} {1}m", Ability Icon String(Hero(Hazard), Button(Ultimate)), Round To Integer(Distance Between(Event Player, Victim), Up)), Add(Victim, Vector(0, 2.5, 0)), 1.5, Do Not Clip, Visible To Position and String, Color(White), Default Visibility);
        Set Player Variable(Victim, Hazard_Downpour_effect, Last Text ID);
        Set Player Variable(Victim, Hazard_Downpour_Target, True);
    }
}

rule ("[hazard/downpour.opy]: hazard reset reveal enemies") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).Hazard_Downpour_Target == True;
    }
    actions {
        Wait(2.5, Ignore Condition);
        Destroy In-World Text((Event Player).Hazard_Downpour_effect);
        Set Player Variable(Event Player, Hazard_Downpour_Target, Null);
        Set Player Variable(Event Player, Hazard_Downpour_effect, Null);
    }
}

rule ("[hazard/downpour.opy]: hazard reset reveal enemies") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).Junkrat_Trap_target == True;
    }
    actions {
        Wait(2.5, Ignore Condition);
        Destroy In-World Text((Event Player).Junkrat_Trap_effect);
        Set Player Variable(Event Player, Junkrat_Trap_target, Null);
        Set Player Variable(Event Player, Junkrat_Trap_effect, Null);
    }
}

rule ("[hazard/thorn_wall.opy]: Haz cancel wall") {
    event {
        Ongoing - Each Player;
        All;
        Hazard;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == True;
    }
    actions {
        "@Condition eventPlayer.isUsingAbility2() == true"
        If(Compare((Event Player).Hazard_Bubble_Allowed, ==, True));
            Wait(0.14, Ignore Condition);
            Cancel Primary Action(Event Player);
    }
}

rule ("[hazard/thorn_wall.opy]: Target Teammate") {
    event {
        Ongoing - Each Player;
        All;
        Hazard;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
    }
    actions {
        Set Player Variable(Event Player, hazard_bubble_target, First Of(Sorted Array(Filtered Array(All Living Players(Team Of(Event Player)), And(And(And(And(Compare(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)), <=, 30), Has Spawned(Current Array Element)), Compare(Distance Between(Event Player, Current Array Element), <=, 25)), Compare(Current Array Element, !=, Event Player)), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)))));
        Wait(0.16, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[hazard/thorn_wall.opy]: Target Teammate HUD and allow bubble") {
    event {
        Ongoing - Each Player;
        All;
        Hazard;
    }
    conditions {
        (Event Player).hazard_bubble_target != Null;
    }
    actions {
        "targeting hud"
        Create In-World Text(If-Then-Else(And(Compare((Event Player).hazard_bubble_target, !=, Null), Compare(Ability Cooldown(Event Player, Button(Ability 2)), ==, 0)), Event Player, Null), Custom String(" \n\n\n\n\n\n     ︿\n〈      〉\n     ﹀ "), Add((Event Player).hazard_bubble_target, Vector(0, 0.7, 0)), 2, Do Not Clip, Visible To Position and String, Custom Color(55, 230, 255, 210), Default Visibility);
        Set Player Variable(Event Player, hazard_targeting_hud, Last Text ID);
        Set Ability 2 Enabled(Event Player, True);
        Set Player Variable(Event Player, Hazard_Bubble_Allowed, True);
    }
}

rule ("[hazard/thorn_wall.opy]: Disallow bubble") {
    event {
        Ongoing - Each Player;
        All;
        Hazard;
    }
    conditions {
        (Event Player).hazard_bubble_target == Null;
    }
    actions {
        Set Ability 2 Enabled(Event Player, False);
        Destroy In-World Text((Event Player).hazard_targeting_hud);
        Set Player Variable(Event Player, Hazard_Bubble_Allowed, False);
    }
}

rule ("[hazard/thorn_wall.opy]: Confirm Target") {
    event {
        Ongoing - Each Player;
        All;
        Hazard;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == True;
    }
    actions {
        If(Compare((Event Player).Hazard_Bubble_Allowed, ==, True));
            Set Ability Cooldown(Event Player, Button(Ability 2), 10);
            Set Player Variable((Event Player).hazard_bubble_target, hazard_bubble_confirmed, True);
    }
}

rule ("[hazard/thorn_wall.opy]: Buff Teammate and play effects") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hazard_bubble_confirmed == True;
    }
    actions {
        Set Player Variable(Event Player, hazard_bubble_confirmed, False);
        Create Effect(Remove From Array(All Players(All Teams), Event Player), Bad Aura, Color(Purple), Event Player, 0.5, Visible To Position and Radius);
        Set Player Variable(Event Player, hazard_bubble_effect, Last Created Entity);
        Create Effect(Remove From Array(All Players(All Teams), Event Player), Sphere, Color(Purple), Event Player, 1.2, Visible To Position and Radius);
        Set Player Variable(Event Player, hazard_bubble_effect2, Last Created Entity);
        Set Player Variable(Players On Hero(Hero(Hazard), Team Of(Event Player)), hazard_bubble_target, Null);
        Set Player Variable(Event Player, hazard_bubble_icon, True);
        Big Message(Event Player, Custom String("{0} Bubbled", Hero Icon String(Hero(Hazard))));
        Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), Event Player, 80);
        Modify Player Variable(Event Player, DamageRecieved, Subtract, 50);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Wait(2.25, Ignore Condition);
        Modify Player Variable(Event Player, DamageRecieved, Add, 50);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Destroy Effect((Event Player).hazard_bubble_effect);
        Destroy Effect((Event Player).hazard_bubble_effect2);
        Set Player Variable(Event Player, hazard_bubble_icon, Null);
        Set Player Variable(Event Player, hazard_bubble_effect, Null);
        Set Player Variable(Event Player, hazard_bubble_effect2, Null);
    }
}

rule ("[hazard/thorn_wall.opy]: Return Damage to attacker and heal hazard") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        (Event Player).hazard_bubble_icon == True;
    }
    actions {
        Damage(Attacker, Players On Hero(Hero(Hazard), Team Of(Event Player)), Divide(Event Damage, 2));
        Play Effect(Event Player, Debuff Impact Sound, Color(White), Event Player, 80);
        Heal(Players On Hero(Hero(Hazard), Team Of(Event Player)), Null, Divide(Event Damage, 4));
    }
}

rule ("[hazard/thorn_wall.opy]: Make immune to CC after 0.1s") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Or(Or(Or(Or(Has Status(Event Player, Stunned), Has Status(Event Player, Rooted)), Has Status(Event Player, Frozen)), Has Status(Event Player, Asleep)), Has Status(Event Player, Knocked Down)) == True;
        (Event Player).hazard_bubble_icon == True;
    }
    actions {
        If(Compare((Event Player).hazard_bubble_icon, ==, True));
            Wait(0.1, Ignore Condition);
            Clear Status(Event Player, Knocked Down);
            Clear Status(Event Player, Asleep);
            Clear Status(Event Player, Frozen);
            Clear Status(Event Player, Rooted);
            Clear Status(Event Player, Stunned);
    }
}

rule ("[hazard/init.opy]: initHazard()") {
    event {
        Subroutine;
        initHazard;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 116);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2000);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.8);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Ability 2 Enabled(Event Player, False);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[hazard/init.opy]: Increase Hazard melee, wall, ultimate damage") {
    event {
        Player Dealt Damage;
        All;
        Hazard;
    }
    conditions {
        Array Contains(Array(Button(Ability 2), Button(Ultimate), Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[hazard/init.opy]: Clean up Hazard") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Hazard);
    }
    actions {
        Set Player Variable(Event Player, hazard_bubble_target, Null);
        Destroy In-World Text((Event Player).hazard_targeting_hud);
        Set Player Variable(Event Player, Hazard_Bubble_Allowed, Null);
    }
}

rule ("[illari/solar_rifle.opy]: Correct Solar Rifle damage") {
    event {
        Player Dealt Damage;
        All;
        Illari;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        If(Event Was Critical Hit);
            Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 1.143), Event Damage), First Of((Event Player).macro_pvar)));
        Else;
            Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[illari/solar_rifle.opy]: Correct Solar Rifle healing") {
    event {
        Ongoing - Each Player;
        All;
        Illari;
    }
    conditions {
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
    }
    actions {
        Set Healing Dealt(Event Player, 100);
        Wait Until(Not(Is Button Held(Event Player, Button(Secondary Fire))), 999999986991104);
        Set Healing Dealt(Event Player, 75);
    }
}

rule ("[illari/init.opy]: initIllari()") {
    event {
        Subroutine;
        initIllari;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 0\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2450);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.75);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 1, 0.75);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Player Variable(Event Player, max_health_scaler, 0.8);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[illari/init.opy]: Correct Outburst and melee damage") {
    event {
        Player Dealt Damage;
        All;
        Illari;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Ability 1)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[illari/init.opy]: Correct Pylon self healing") {
    event {
        Player Dealt Healing;
        All;
        Illari;
    }
    conditions {
        Healee == Healer;
    }
    actions {
        Heal(Healer, Null, Event Healing);
    }
}

rule ("[junkerqueen/carnage.opy]: Reduce Carnage damage") {
    event {
        Ongoing - Each Player;
        All;
        Junker Queen;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 85.714);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[junkerqueen/commanding_shout.opy]: Prepare Commanding Shout ally tracking") {
    event {
        Ongoing - Each Player;
        All;
        Junker Queen;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Remove From Array(Players Within Radius(Event Player, 15.5, Team Of(Event Player), Surfaces), Event Player), within_shout_radius, True);
    }
}

rule ("[junkerqueen/commanding_shout.opy]: increase overhealth for allies") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).within_shout_radius == True;
    }
    actions {
        "eventPlayer.MoveSpeed = eventPlayer.MoveSpeed + 3.8\neventPlayer.setMoveSpeed(eventPlayer.MoveSpeed)"
        Add Health Pool To Player(Event Player, Health, 9.5, False, False);
        Set Player Variable(Event Player, Junkerqueen_overhealth, Last Created Health Pool);
        Wait(2.9, Ignore Condition);
        "eventPlayer.setMoveSpeed(100 * eventPlayer.macro_pvar[2] * 1.35)"
        Modify Player Variable(Event Player, MoveSpeed, Add, 30);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait(1.9, Ignore Condition);
        "eventPlayer.setMoveSpeed(100 * eventPlayer.macro_pvar[2])"
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 30);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Remove Health Pool From Player((Event Player).Junkerqueen_overhealth);
        Set Player Variable(Event Player, Junkerqueen_overhealth, Null);
        Set Player Variable(Event Player, within_shout_radius, False);
    }
}

rule ("[junkerqueen/jagged_blade.opy]: Correct Jagged Blade impact damage") {
    event {
        Player Dealt Damage;
        All;
        Junker Queen;
    }
    conditions {
        Event Damage == Multiply(65, First Of((Event Player).macro_pvar));
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[junkerqueen/jagged_blade.opy]: Increase Jagged Blade pull distance on squishies") {
    event {
        Player Dealt Knockback;
        All;
        Junker Queen;
    }
    conditions {
        Is Meleeing(Event Player) == False;
        Array Contains(All Tank Heroes, Hero Of(Victim)) == False;
    }
    actions {
        Apply Impulse(Victim, Vector(X Component Of(Normalize(Subtract(Position Of(Event Player), Position Of(Victim)))), 0, Z Component Of(Normalize(Subtract(Position Of(Event Player), Victim)))), 7.5, To World, Incorporate Contrary Motion);
    }
}

rule ("[junkerqueen/rampage.opy]: Reduce Rampage damage") {
    event {
        Ongoing - Each Player;
        All;
        Junker Queen;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 83.333);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[junkerqueen/init.opy]: initJunkerQueen()") {
    event {
        Subroutine;
        initJunkerQueen;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 157);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2300);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.875);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Healing Dealt(Event Player, 73.563);
        Set Knockback Dealt(Event Player, 64);
        Start Scaling Player(Event Player, 0.96, True);
        Set Max Ammo(Event Player, 0, 8);
        Set Ammo(Event Player, 0, 8);
        Set Player Variable(Event Player, overhealth_check, False);
        Set Player Variable(Event Player, max_health_scaler, 0.714);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[junkerqueen/init.opy]: Shout indicator") {
    event {
        Ongoing - Each Player;
        All;
        Junker Queen;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Between Rounds == False;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0} {1}", Count Of(Filtered Array(All Living Players(Team Of(Event Player)), And(And(Compare(Distance Between(Event Player, Current Array Element), <=, 15), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS)), Compare(Hero Of(Current Array Element), !=, Hero(Junker Queen))))), Ability Icon String(Hero(Junker Queen), Button(Ability 1))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(-0.5, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 2, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, JQ_Shout_Hud, Last Text ID);
        Wait Until(Is Using Ability 1(Event Player), 99999);
        Destroy In-World Text((Event Player).JQ_Shout_Hud);
        Set Player Variable(Event Player, JQ_Shout_Hud, Null);
    }
}

rule ("[junkerqueen/init.opy]: Clean up JQ") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Junker Queen);
    }
    actions {
        Destroy In-World Text((Event Player).JQ_Shout_Hud);
    }
}

rule ("[junkrat/mayhem.opy]: Correct Frag Launcher damage") {
    event {
        Player Dealt Damage;
        All;
        Junkrat;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        "damage(victim, attacker, ((eventDamage/eventPlayer._base_damage_scalar)*(ADJ_JUNKRAT_FRAG_DAMAGE/OW2_JUNKRAT_FRAG_DAMAGE) - eventDamage)/eventPlayer._base_damage_scalar)"
        Heal(Victim, Null, Multiply(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.8), Event Damage), -1));
    }
}

rule ("[junkrat/mayhem.opy]: Correct Junkrat Melee damage") {
    event {
        Player Dealt Damage;
        All;
        Junkrat;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[junkrat/mayhem.opy]: Correct Junkrat Trap damage") {
    event {
        Player Dealt Damage;
        All;
        Junkrat;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.9), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[junkrat/mayhem.opy]: Reset damage for Rip-Tire") {
    event {
        Ongoing - Each Player;
        All;
        Junkrat;
    }
    conditions {
        Is Button Held(Event Player, Button(Ultimate)) == True;
        Is On Ground(Event Player) == True;
        Ultimate Charge Percent(Event Player) >= 100;
    }
    actions {
        Set Damage Dealt(Event Player, 100);
        Allow Button(Event Player, Button(Ultimate));
        Press Button(Event Player, Button(Ultimate));
        Disallow Button(Event Player, Button(Ultimate));
        Wait(1, Ignore Condition);
        "revert damage back after Rip-Tire is deployed"
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[junkrat/trap.opy]: junkrat reveal enemies") {
    event {
        Player Dealt Damage;
        All;
        Junkrat;
    }
    conditions {
        Has Status(Victim, Rooted) == True;
        Event Ability == Button(Ability 2);
        (Victim).Junkrat_Trap_target == Null;
    }
    actions {
        Create In-World Text(All Players(Team Of(Event Player)), Custom String("{0} {1}m", Ability Icon String(Hero(Junkrat), Button(Ability 2)), Round To Integer(Distance Between(Event Player, Victim), Up)), Add(Victim, Vector(0, 2.5, 0)), 1.5, Do Not Clip, Visible To Position and String, Color(White), Default Visibility);
        Set Player Variable(Victim, Junkrat_Trap_effect, Last Text ID);
        Set Player Variable(Victim, Junkrat_Trap_target, True);
    }
}

rule ("[junkrat/init.opy]: initJunkrat()") {
    event {
        Subroutine;
        initJunkrat;
    }
    actions {
        "eventPlayer.addHealthPool(Health.ARMOR, 1, true, true)\neventPlayer.addHealthPool(Health.SHIELDS, 1, true, true)\neventPlayer.removeAllHealthPools()\n#eventPlayer.addHealthPool(Health.NORMAL, 199, true, true)\nheal(eventPlayer, null, 1)"
        Call Subroutine(resetStats);
        Call Subroutine(resetStatuses);
        Call Subroutine(enableAllAbilities);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1925);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.875);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        "check mayhem.opy"
        Disallow Button(Event Player, Button(Ultimate));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[juno/orbital_ray.opy]: Adjust Orbital Ray Healing") {
    event {
        Ongoing - Each Player;
        All;
        Juno;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Is Alive(Event Player) == True;
        Has Status(Event Player, Asleep) == False;
        Has Status(Event Player, Frozen) == False;
        Has Status(Event Player, Knocked Down) == False;
        Has Status(Event Player, Stunned) == False;
    }
    actions {
        Wait(0.469, Ignore Condition);
        Set Player Variable(Event Player, orbital_ray_x, X Component Of(Add(Position Of(Event Player), Multiply(1.625, Direction From Angles(Horizontal Facing Angle Of(Event Player), 0)))));
        Set Player Variable(Event Player, orbital_ray_z, Z Component Of(Add(Position Of(Event Player), Multiply(1.625, Direction From Angles(Horizontal Facing Angle Of(Event Player), 0)))));
        Set Player Variable(Event Player, orbital_ray_final_x, X Component Of(Add(Position Of(Event Player), Multiply(24.125, Direction From Angles(Horizontal Facing Angle Of(Event Player), 0)))));
        Set Player Variable(Event Player, orbital_ray_final_z, Z Component Of(Add(Position Of(Event Player), Multiply(24.125, Direction From Angles(Horizontal Facing Angle Of(Event Player), 0)))));
        Chase Player Variable Over Time(Event Player, orbital_ray_x, (Event Player).orbital_ray_final_x, 10, None);
        Chase Player Variable Over Time(Event Player, orbital_ray_z, (Event Player).orbital_ray_final_z, 10, None);
        "createBeam(eventPlayer, Beam.GOOD, vect(eventPlayer.orbital_ray_x, 0.0, eventPlayer.orbital_ray_z), vect(eventPlayer.orbital_ray_x, 100.0, eventPlayer.orbital_ray_z), Color.WHITE, EffectReeval.POSITION_AND_RADIUS)"
        While(Is Using Ultimate(Event Player));
            Start Damage Over Time(Filtered Array(All Living Players(Team Of(Event Player)), And(And(Compare(Distance Between(Vector((Event Player).orbital_ray_x, 0, (Event Player).orbital_ray_z), Vector(X Component Of(Position Of(Current Array Element)), 0, Z Component Of(Position Of(Current Array Element)))), <, 8), Compare(Health(Current Array Element), <, Max Health(Current Array Element))), Compare((Current Array Element).remainingAntiDuration, <=, 0))), Null, 0.098, 19);
            Wait(0.098, Ignore Condition);
        End;
    }
}

rule ("[juno/init.opy]: initJuno()") {
    event {
        Subroutine;
        initJuno;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 87);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2850);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.867);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 1, 0.833);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Modify Player Variable(Event Player, MoveSpeed, Add, 9.1);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Set Ammo(Event Player, 0, 120);
        Set Max Ammo(Event Player, 0, 120);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[juno/init.opy]: Correct Pulsar Torpedo healing and damage") {
    event {
        Ongoing - Each Player;
        All;
        Juno;
    }
    conditions {
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
        Ability Cooldown(Event Player, Button(Secondary Fire)) < 0.1;
        Is Meleeing(Event Player) == False;
        Is Reloading(Event Player) == False;
    }
    actions {
        Set Healing Dealt(Event Player, 58.824);
        Set Damage Dealt(Event Player, 58.824);
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Secondary Fire)), >, 0), 4);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[juno/init.opy]: Correct Juno Melee damage") {
    event {
        Player Dealt Damage;
        All;
        Juno;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[juno/init.opy]: Correct Pulsar Torpedo healing over time") {
    event {
        Player Dealt Healing;
        All;
        Juno;
    }
    conditions {
        Event Healing > 69;
    }
    actions {
        Start Damage Over Time(Healee, Null, 2.4, 10);
    }
}

rule ("[kiriko/swift_step.opy]: Force swift step cooldown after spawning") {
    event {
        Player Died;
        All;
        Kiriko;
    }
    actions {
        Wait Until(And(Is Alive(Event Player), Is In Spawn Room(Event Player)), 999999986991104);
        Set Ability Cooldown(Event Player, Button(Ability 1), 5);
    }
}

rule ("[kiriko/swift_step.opy]: Heal when using Swift Step") {
    event {
        Ongoing - Each Player;
        All;
        Kiriko;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        "grace period to allow SS to cleanse anti-heal effects"
        Wait(0.1, Ignore Condition);
        Start Heal Over Time(Event Player, Null, 0.25, Divide(140, Value In Array((Event Player).macro_pvar, 1)));
    }
}

rule ("[kiriko/protection_suzu.opy]: correct suzu healing") {
    event {
        Player Dealt Healing;
        All;
        Kiriko;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Heal(Healee, Event Player, Subtract(Divide(Event Healing, Value In Array((Event Player).macro_pvar, 1)), Event Healing));
    }
}

rule ("[kiriko/init.opy]: initKiriko()") {
    event {
        Subroutine;
        initKiriko;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 0\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2100);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.867);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 1, 0.77);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Modify Player Variable(Event Player, MoveSpeed, Add, 9.1);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Set Ability Cooldown(Event Player, Button(Ability 1), 5);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[kiriko/init.opy]: Correct Kiriko melee damage") {
    event {
        Player Dealt Damage;
        All;
        Kiriko;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[lifeweaver/healing.opy]: Correct Healing ammount") {
    event {
        Player Dealt Healing;
        All;
        Lifeweaver;
    }
    conditions {
        Event Ability != Button(Ultimate);
        Event Ability != Button(Ability 2);
        Event Player != Healee;
        (Healee).Lifeweaver_healing_cd != True;
    }
    actions {
        Start Heal Over Time(Healee, Null, 4, 10);
        Set Player Variable(Healee, Lifeweaver_healing_cd, True);
        Wait(4, Ignore Condition);
        Set Player Variable(Healee, Lifeweaver_healing_cd, Null);
    }
}

rule ("[lifeweaver/petalplatform.opy]: Lose charges and reset cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        (Event Player).Lifeweaver_petal_charges != 0;
        Is Button Held(Event Player, Button(Ability 1)) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions {
        Modify Player Variable(Event Player, Lifeweaver_petal_charges, Subtract, 1);
        If(Compare((Event Player).Lifeweaver_petal_charges, !=, 0));
            "waitUntil(eventPlayer.isUsingAbility1(), 99999)"
            Wait(0.25, Ignore Condition);
            Set Ability Cooldown(Event Player, Button(Ability 1), 0);
    }
}

rule ("[lifeweaver/petalplatform.opy]: recharge petal") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        (Event Player).Lifeweaver_petal_charges != 2;
    }
    actions {
        Wait(12, Abort When False);
        Modify Player Variable(Event Player, Lifeweaver_petal_charges, Add, 1);
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
        Loop If Condition Is True;
    }
}

rule ("[lifeweaver/dash.opy]: Lose charges") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        Vertical Speed Of(Event Player) == False;
        Is On Ground(Event Player) == False;
    }
    actions {
        Wait(0.032, Abort When False);
        If(Compare(Distance Between(Event Player, Add(Event Player, Velocity Of(Event Player))), >=, 8));
            Modify Player Variable(Event Player, Lifeweaver_dash_charges, Subtract, 1);
        Else;
            If(Compare(Distance Between(Event Player, Ray Cast Hit Position(Event Player, Add(Event Player, Velocity Of(Event Player)), Null, Null, True)), <=, 5));
                Modify Player Variable(Event Player, Lifeweaver_dash_charges, Subtract, 1);
    }
}

rule ("[lifeweaver/dash.opy]: Gain charges") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        (Event Player).Lifeweaver_dash_charges != 2;
    }
    actions {
        Wait(6, Ignore Condition);
        Modify Player Variable(Event Player, Lifeweaver_dash_charges, Add, 1);
        Loop If Condition Is True;
    }
}

rule ("[lifeweaver/dash.opy]: Disable Dash") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        (Event Player).Lifeweaver_dash_charges == 0;
        Is In Air(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Jump));
        Wait Until(Or(Is On Ground(Event Player), Compare((Event Player).Lifeweaver_dash_charges, !=, 0)), 99999);
        Allow Button(Event Player, Button(Jump));
    }
}

rule ("[lifeweaver/dash.opy]: Silly charge Bug fix") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        (Event Player).Lifeweaver_dash_charges > 2;
    }
    actions {
        Set Player Variable(Event Player, Lifeweaver_dash_charges, 2);
    }
}

rule ("[lifeweaver/dash.opy]: Silly charge Bug fix 2") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        (Event Player).Lifeweaver_dash_charges < 0;
    }
    actions {
        Set Player Variable(Event Player, Lifeweaver_dash_charges, 0);
    }
}

rule ("[lifeweaver/grasp.opy] Set grasp cooldown to 10s when target is above 75%hp") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        If(Compare(Health(First Of(Sorted Array(Filtered Array(All Living Players(Team Of(Event Player)), And(And(And(And(Compare(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)), <=, 50), Has Spawned(Current Array Element)), Compare(Distance Between(Event Player, Current Array Element), <=, 30)), Compare(Current Array Element, !=, Event Player)), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element))))), >=, Multiply(Max Health(First Of(Sorted Array(Filtered Array(All Living Players(Team Of(Event Player)), And(And(And(And(Compare(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)), <=, 50), Has Spawned(Current Array Element)), Compare(Distance Between(Event Player, Current Array Element), <=, 30)), Compare(Current Array Element, !=, Event Player)), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element))))), 0.75)));
            Wait Until(Not(Is Using Ability 2(Event Player)), 99999);
            Set Ability Cooldown(Event Player, Button(Ability 2), 10);
    }
}

rule ("[lifeweaver/init.opy]: Initialize Lifeweaver") {
    event {
        Subroutine;
        initLifeweaver;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 37.5);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 25);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2000);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 1.25);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).Lifeweaver_petal_charges, Up)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(1.92, World Vector Of(Right, Event Player, Rotation)), Multiply(-2.05, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, Lifeweaver_petal_hud, Last Text ID);
        Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).Lifeweaver_dash_charges, Up)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(2.535, World Vector Of(Right, Event Player, Rotation)), Multiply(-2.05, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, Lifeweaver_dash_hud, Last Text ID);
        Create In-World Text(Event Player, Custom String("{0} {1}", Round To Integer((Event Player).Lifeweaver_petal_charges, Up), Ability Icon String(Hero(Lifeweaver), Button(Ability 1))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(-0.22, World Vector Of(Right, Event Player, Rotation)), Multiply(-0.6, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 1.3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, Lifeweaver_petal_centre_hud, Last Text ID);
        Create In-World Text(Event Player, Custom String("{0} {1}", Round To Integer((Event Player).Lifeweaver_dash_charges, Up), Ability Icon String(Hero(Lifeweaver), Button(Jump))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(0.22, World Vector Of(Right, Event Player, Rotation)), Multiply(-0.6, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 1.3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, Lifeweaver_leap_centre_target, Last Text ID);
        Set Player Variable(Event Player, Lifeweaver_petal_charges, 2);
        Set Player Variable(Event Player, Lifeweaver_dash_charges, 2);
        Set Max Ammo(Event Player, 0, 5);
        Set Ammo(Event Player, 0, 5);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[lifeweaver/init.opy]: Reduce Lifeweaver melee damage") {
    event {
        Player Dealt Damage;
        All;
        Lifeweaver;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Divide(Event Damage, First Of((Event Player).macro_pvar))));
    }
}

rule ("[lifeweaver/init.opy]: Reduce Tree of Life duration") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Wait(11, Ignore Condition);
        Press Button(Event Player, Button(Ultimate));
    }
}

rule ("[lifeweaver/init.opy]: Clean up lifeweaver") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Lifeweaver);
    }
    actions {
        Destroy In-World Text((Event Player).Lifeweaver_petal_hud);
        Destroy In-World Text((Event Player).Lifeweaver_dash_hud);
        Destroy In-World Text((Event Player).Lifeweaver_healing_hud);
        Destroy In-World Text((Event Player).Lifeweaver_petal_centre_hud);
        Destroy In-World Text((Event Player).Lifeweaver_leap_centre_target);
    }
}

rule ("[lucio/ampitup.opy]: begin ally tracking") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Player Variable(Remove From Array(Players Within Radius(Event Player, 12, Team Of(Event Player), Surfaces), Event Player), Within_speed_radius, True);
        Wait(0.125, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[lucio/ampitup.opy]: decrease speed for allies") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).Within_speed_radius == True;
    }
    actions {
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 6.25);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait(0.125, Ignore Condition);
        Modify Player Variable(Event Player, MoveSpeed, Add, 6.25);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Set Player Variable(Event Player, Within_speed_radius, False);
    }
}

rule ("[lucio/ampitup.opy]: decrease speed for Lucio") {
    event {
        Ongoing - Each Player;
        All;
        Lúcio;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 6.25);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait(3, Ignore Condition);
        Modify Player Variable(Event Player, MoveSpeed, Add, 6.25);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

rule ("[lucio/init.opy]: initLucio()") {
    event {
        Subroutine;
        initLucio;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 200\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2940);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.444);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Start Scaling Player(Event Player, 0.96, True);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[lucio/init.opy]: Correct Lucio melee damage") {
    event {
        Player Dealt Damage;
        All;
        Lúcio;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[lucio/init.opy]: Correct Sonic Amplifier damage") {
    event {
        Player Dealt Damage;
        All;
        Lúcio;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.909), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[mauga/cardiac.opy]: Cardiac Use Ability") {
    event {
        Ongoing - Each Player;
        All;
        Mauga;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Add Health Pool To Player(Event Player, Health, 150, False, True);
        Set Player Variable(Event Player, Mauga_Overdrive_Health, Last Created Health Pool);
        Modify Player Variable(Event Player, DamageRecieved, Add, 40);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Wait(3, Ignore Condition);
        Remove Health Pool From Player((Event Player).Mauga_Overdrive_Health);
        Modify Player Variable(Event Player, DamageRecieved, Subtract, 40);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
    }
}

rule ("[mauga/cardiac.opy]: Mauga Heal Others") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Using Ability 2(Players On Hero(Hero(Mauga), Team Of(Event Player))) == True;
        Distance Between(Event Player, Players On Hero(Hero(Mauga), Team Of(Event Player))) <= 10.5;
    }
    actions {
        Start Heal Over Time(Event Player, Players On Hero(Hero(Mauga), Team Of(Event Player)), 3, 40);
        Set Player Variable(Event Player, Cardiac_overdrive_active, Last Heal Over Time ID);
        Wait Until(Not(Is Using Ability 2(Players On Hero(Hero(Mauga), Team Of(Event Player)))), 3);
        Stop Heal Over Time((Event Player).Cardiac_overdrive_active);
    }
}

rule ("[mauga/cage.opy]: Reduce Cage Fight duration") {
    event {
        Ongoing - Each Player;
        All;
        Mauga;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Wait(6, Ignore Condition);
        Press Button(Event Player, Button(Ultimate));
    }
}

rule ("[mauga/init.opy]: initMauga()") {
    event {
        Subroutine;
        initMauga;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 21);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 50);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2650);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.75);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, balance_change_check, False);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[mauga/init.opy]: Increase Mauga melee damage") {
    event {
        Player Dealt Damage;
        All;
        Mauga;
    }
    conditions {
        Array Contains(Array(Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

disabled rule ("[mei/endothermic.opy]: AOE Damage Mei") {
    event {
        Player Dealt Damage;
        All;
        Mei;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Play Effect(All Players(All Teams), Bad Explosion, Color(Sky Blue), Victim, 2);
        Play Effect(All Players(All Teams), Ring Explosion, Color(Aqua), Victim, 5);
        Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Sky Blue), Event Player, 40);
        Damage(Players Within Radius(Victim, 5, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers), Attacker, 25);
    }
}

rule ("[mei/wall.opy]: Wall cooldown seconds Mei") {
    event {
        Ongoing - Each Player;
        All;
        Mei;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait Until(Or(Is Button Held(Event Player, Button(Primary Fire)), Is Button Held(Event Player, Button(Secondary Fire))), 99999);
        If(Is Button Held(Event Player, Button(Primary Fire)));
            Wait Until(Not(Is Using Ability 2(Event Player)), 99999);
            Set Ability Cooldown(Event Player, Button(Ability 2), 10);
    }
}

rule ("[mei/cryo_freeze.opy]: OW1 Cryo-Freeze healing set to 80 otherwise for tank mei set to 120") {
    event {
        Ongoing - Each Player;
        All;
        Mei;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Healing Received(Event Player, 80);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999986991104);
        Set Healing Received(Event Player, 100);
    }
}

rule ("[mei/init.opy]: initMei()") {
    event {
        Subroutine;
        initMei;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 10);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1610);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.882);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, max_health_scaler, 0.8);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

disabled rule ("[mei/init.opy]: Initialize Mei TANK") {
    event {
        Subroutine;
        initMei;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 70);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2800);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.66);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Start Scaling Player(Event Player, 1.15, True);
        Set Player Variable(Event Player, hero_initialized, True);
        Set Player Variable(Event Player, max_health_scaler, 1.1);
    }
}

rule ("[mei/init.opy]: Reduce Headshot damage taken Mei") {
    event {
        Player Took Damage;
        All;
        Mei;
    }
    conditions {
        Event Was Critical Hit == True;
    }
    actions {
        Heal(Event Player, Null, Multiply(Event Damage, 0.3));
    }
}

rule ("[mei/init.opy]: Increase Mei other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        Mei;
    }
    conditions {
        Array Contains(Array(Button(Primary Fire), Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[mercy/valkyrie]: Mercy give one rez charge") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, Mercy_Rez_charges, 1);
        Wait Until(Not(Is Using Ultimate(Event Player)), 16);
        Set Player Variable(Event Player, Mercy_Rez_charges, Null);
    }
}

rule ("[mercy/ressurect.opy]: Mercy rez") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Is Button Held(Event Player, Button(Ultimate)) == True;
        Is Alive(Event Player) == True;
        Count Of(Remove From Array(Players Within Radius(Event Player, 5.5, Team Of(Event Player), Surfaces), All Living Players(All Teams))) > 0;
        (Event Player).Mercy_Rez_charges == 1;
    }
    actions {
        Set Player Variable(Event Player, MercyUltTrack, 0);
        Set Ultimate Charge(Event Player, 0);
        Destroy HUD Text((Event Player).RezHUD);
        Set Player Variable(Event Player, RezHUD, Null);
        Communicate(Event Player, Hello);
        "Set rez target"
        Set Player Variable(Event Player, RezTarget, First Of(Sorted Array(Remove From Array(Players Within Radius(Event Player, 5.5, Team Of(Event Player), Surfaces), All Living Players(Team Of(Event Player))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Event Player, Current Array Element)))));
        "Show rez in killfeed (skews mercy's elims and target's deaths by 1, but whatever)"
        Resurrect((Event Player).RezTarget);
        Set Status((Event Player).RezTarget, Null, Phased Out, 0.1);
        Set Player Health((Event Player).RezTarget, 0.01);
        Kill((Event Player).RezTarget, Event Player);
        Wait(0.016, Ignore Condition);
        "Real rez"
        Resurrect((Event Player).RezTarget);
        Set Status((Event Player).RezTarget, Null, Phased Out, 2.25);
        Set Status((Event Player).RezTarget, Null, Frozen, 1.5);
        Set Player Health((Event Player).RezTarget, Max Health((Event Player).RezTarget));
        Play Effect(All Players(All Teams), Good Pickup Effect, Color(Yellow), (Event Player).RezTarget, 5);
        Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), (Event Player).RezTarget, 110);
        Set Ammo((Event Player).RezTarget, 0, Max Ammo((Event Player).RezTarget, 0));
        Set Ammo((Event Player).RezTarget, 1, Max Ammo((Event Player).RezTarget, 1));
        "0.75s recovery"
        Disallow Button(Event Player, Button(Primary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Disallow Button(Event Player, Button(Melee));
        Disallow Button(Event Player, Button(Ability 2));
        "Disable target abilities for 0.75s movement window in invuln"
        Disallow Button((Event Player).RezTarget, Button(Ability 1));
        Disallow Button((Event Player).RezTarget, Button(Ability 2));
        Disallow Button((Event Player).RezTarget, Button(Primary Fire));
        Disallow Button((Event Player).RezTarget, Button(Secondary Fire));
        Disallow Button((Event Player).RezTarget, Button(Ultimate));
        Disallow Button((Event Player).RezTarget, Button(Melee));
        "End recovery"
        Wait(0.5, Ignore Condition);
        Allow Button(Event Player, Button(Primary Fire));
        Allow Button(Event Player, Button(Secondary Fire));
        Allow Button(Event Player, Button(Melee));
        Allow Button(Event Player, Button(Ability 2));
        "End of target invuln, enable abilities"
        Wait(1.75, Ignore Condition);
        Allow Button((Event Player).RezTarget, Button(Ability 1));
        Allow Button((Event Player).RezTarget, Button(Ability 2));
        Allow Button((Event Player).RezTarget, Button(Primary Fire));
        Allow Button((Event Player).RezTarget, Button(Secondary Fire));
        Allow Button((Event Player).RezTarget, Button(Ultimate));
        Allow Button((Event Player).RezTarget, Button(Melee));
        Set Player Variable(Event Player, RezTarget, Null);
        Set Player Variable(Event Player, Mercy_Rez_charges, Null);
    }
}

rule ("[mercy/ressurect.opy]: Mercy rez HUD") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        (Event Player).RezHUD == Null;
        Is Using Ultimate(Event Player) == True;
        (Event Player).Mercy_Rez_charges == 1;
    }
    actions {
        Create HUD Text(If-Then-Else(And(Is Alive(Event Player), Compare(Count Of(Remove From Array(Players Within Radius(Event Player, 5.5, Team Of(Event Player), Surfaces), All Living Players(All Teams))), >, 0)), Event Player, Null), Custom String("Resurrect {0}", Hero Icon String(Hero Of(First Of(Sorted Array(Remove From Array(Players Within Radius(Event Player, 5.5, Team Of(Event Player), Surfaces), All Living Players(Team Of(Event Player))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Event Player, Current Array Element))))))), Null, Null, Top, 0, Color(Yellow), Null, Null, Visible To and String, Default Visibility);
        Set Player Variable(Event Player, RezHUD, Last Text ID);
    }
}

rule ("[mercy/imbue.opy]: Mercy imbue target icon") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        (Event Player).ImbueTargetIcon == Null;
    }
    actions {
        Create In-World Text(If-Then-Else(And(Compare(First Of(Sorted Array(Filtered Array(Players Within Radius(Event Player, 20.5, Team Of(Event Player), Surfaces And Enemy Barriers), And(And(Is In View Angle(Event Player, Position Of(Current Array Element), Add(2.5, Divide(120, Distance Between(Event Player, Current Array Element)))), Compare(Current Array Element, !=, Event Player)), Is Alive(Current Array Element))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element))))), !=, Null), Not(Is In Alternate Form(Event Player))), Event Player, Null), Custom String("+"), Add(Eye Position(First Of(Sorted Array(Filtered Array(Players Within Radius(Event Player, 20.5, Team Of(Event Player), Surfaces And Enemy Barriers), And(And(Is In View Angle(Event Player, Position Of(Current Array Element), Add(2.5, Divide(120, Distance Between(Event Player, Current Array Element)))), Compare(Current Array Element, !=, Event Player)), Is Alive(Current Array Element))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element)))))), Vector(0, 1, 0)), 2, Do Not Clip, Visible To Position String and Color, If-Then-Else(Is Firing Secondary(Event Player), Color(Blue), Color(Yellow)), Default Visibility);
        Set Player Variable(Event Player, ImbueTargetIcon, Last Text ID);
    }
}

rule ("[mercy/imbue.opy]: Mercy imbue") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Or(Compare(First Of(Sorted Array(Filtered Array(Remove From Array(Remove From Array(Players Within Radius(Event Player, 20.5, Team Of(Event Player), Surfaces And Enemy Barriers), Event Player), All Dead Players(Team Of(Event Player))), Is In View Angle(Event Player, Position Of(Current Array Element), Add(2.5, Divide(120, Distance Between(Event Player, Current Array Element))))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element))))), !=, Null), Is In Alternate Form(Event Player)) == True;
    }
    actions {
        "Vanilla rez cd hero setting needs to be changed if cooldown is changed so icon matches"
        Set Ability Cooldown(Event Player, Button(Ability 2), 15);
        Set Ability 2 Enabled(Event Player, True);
        Destroy In-World Text((Event Player).ImbueTargetIcon);
        Set Player Variable(Event Player, ImbueTargetIcon, Null);
        "eventPlayer.ImbueSecondary = true if eventPlayer.isFiringSecondaryFire() else false"
        Set Player Variable(Event Player, ImbueSecondary, If-Then-Else(Or(Is Firing Secondary(Event Player), Is In Alternate Form(Event Player)), 1, Null));
        If(Is In Alternate Form(Event Player));
            Set Player Variable(Event Player, ImbueTarget, Event Player);
            Set Player Variable(Event Player, ImbueSecondary, 2);
        Else;
            "Set target"
            Set Player Variable(Event Player, ImbueTarget, First Of(Sorted Array(Filtered Array(Players Within Radius(Event Player, 20.5, Team Of(Event Player), Surfaces And Enemy Barriers), And(And(Is In View Angle(Event Player, Position Of(Current Array Element), Add(2.5, Divide(120, Distance Between(Event Player, Current Array Element)))), Compare(Current Array Element, !=, Event Player)), Is Alive(Current Array Element))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element))))));
            Big Message((Event Player).ImbueTarget, If-Then-Else((Event Player).ImbueSecondary, Custom String("Damage Imbued"), Custom String("Heal Imbued")));
        End;
        "Duration"
        Set Player Variable(Event Player, ImbueDuration, 5);
        Chase Player Variable At Rate(Event Player, ImbueDuration, 0, 1, Destination and Rate);
        Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Event Player, 80);
        Create Beam Effect(If-Then-Else(Compare((Event Player).ImbueTarget, !=, Null), All Players(All Teams), Null), Bad Beam, Event Player, (Event Player).ImbueTarget, If-Then-Else(Is Firing Secondary(Event Player), Color(Blue), Color(Yellow)), Visible To Position and Radius);
        Set Player Variable(Event Player, ImbueBeam, Last Created Entity);
        Play Effect(All Players(All Teams), Ring Explosion, If-Then-Else((Event Player).ImbueSecondary, If-Then-Else(Compare(Team Of(Event Player), ==, Team 1), Color(Team 1), Color(Team 2)), Color(Yellow)), (Event Player).ImbueTarget, 8);
        "Destroy beam and sparkle"
        Wait(0.2, Ignore Condition);
        Destroy Effect((Event Player).ImbueBeam);
        "Wait = cooldown - 0.3 (stops vanilla rez being usable the frame cooldown ends); rez cooldown needs to be changed in hero settings if cooldown is changed so icon matches"
        Wait Until(Or(Or(Is Dead(Event Player), Compare(Ability Cooldown(Event Player, Button(Ability 2)), <=, 0.3)), Compare(Hero Of(Event Player), !=, Hero(Mercy))), 14.7);
        Abort If(Compare(Hero Of(Event Player), !=, Hero(Mercy)));
        Set Ability 2 Enabled(Event Player, False);
    }
}

rule ("[mercy/imbue.opy]: Mercy imbue AOE") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).ImbueDuration > 0;
        (Event Player).ImbueTarget != Null;
    }
    actions {
        "Aura visuals"
        Create Effect(All Players(If-Then-Else((Event Player).ImbueSecondary, All Teams, Team Of(Event Player))), Ring, If-Then-Else((Event Player).ImbueSecondary, If-Then-Else(Compare(Team Of(Event Player), ==, Team 1), Color(Team 1), Color(Team 2)), Color(Yellow)), (Event Player).ImbueTarget, If-Then-Else((Event Player).ImbueSecondary, 8, 10), Visible To Position and Radius);
        Set Player Variable(Event Player, ImbueAOERing, Last Created Entity);
        If((Event Player).ImbueSecondary);
            Create Effect(All Players(Team Of(Event Player)), Energy Sound, Color(White), (Event Player).ImbueTarget, 80, Visible To Position and Radius);
        Else;
            Create Effect(All Players(Team Of(Event Player)), Sparkles Sound, Color(White), (Event Player).ImbueTarget, 80, Visible To Position and Radius);
        End;
        Set Player Variable(Event Player, ImbueAOESound, Last Created Entity);
        "AoE"
        While(And(Is Alive((Event Player).ImbueTarget), Compare((Event Player).ImbueDuration, >, 0)));
            "30 dps for 3 seconds"
            If((Event Player).ImbueSecondary);
                If(And(Compare((Event Player).ImbueSecondary, ==, 2), Not(Is In Alternate Form(Event Player))));
                    Break;
                End;
                Start Damage Over Time(Players Within Radius((Event Player).ImbueTarget, 8, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers), Event Player, 0.5, Divide(30, First Of((Event Player).macro_pvar)));
            Else;
                Heal((Event Player).ImbueTarget, Event Player, Divide(4, Value In Array((Event Player).macro_pvar, 1)));
                Heal(Remove From Array(Players Within Radius((Event Player).ImbueTarget, 10, Team Of(Event Player), Surfaces And Enemy Barriers), (Event Player).ImbueTarget), Event Player, Divide(6, Value In Array((Event Player).macro_pvar, 1)));
            End;
            Wait Until(Or(Is Dead((Event Player).ImbueTarget), Compare((Event Player).ImbueDuration, ==, 0)), 0.5);
        End;
        Destroy Effect((Event Player).ImbueAOERing);
        Destroy Effect((Event Player).ImbueAOESound);
        Stop Chasing Player Variable(Event Player, ImbueDuration);
        Set Player Variable(Event Player, ImbueTarget, Null);
    }
}

rule ("[mercy/init.opy]: initMercy()") {
    event {
        Subroutine;
        initMercy;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 200\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2000);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 1.1);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 1, 0.917);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Ammo(Event Player, 0, 20);
        Set Max Ammo(Event Player, 0, 20);
        Set Ability 2 Enabled(Event Player, False);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[mercy/init.opy]: Reduce Valkyrie healing and force self-healing") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Stop All Heal Over Time(Event Player);
        Start Heal Over Time(Event Player, Null, 15, 20);
        Heal(Event Player, Null, 50);
        Set Healing Dealt(Event Player, 138.462);
        Wait(2, Ignore Condition);
        Set Healing Dealt(Event Player, 92.308);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
    }
}

rule ("[mercy/init.opy]: Mercy swap hero") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) != Hero(Mercy);
        Has Spawned(Event Player) == True;
    }
    actions {
        Allow Button(Event Player, Button(Ultimate));
        Destroy HUD Text((Event Player).RezHUD);
        Destroy In-World Text((Event Player).ImbueTargetIcon);
        Set Player Variable(Event Player, MercyUltTrack, 0);
        Destroy Effect((Event Player).ImbueAOERing);
        Destroy Effect((Event Player).ImbueAOESound);
        Destroy Effect((Event Player).ImbueBeam);
        Destroy Effect((Event Player).ImbueSparkle);
        Set Player Variable(Event Player, ImbueTargetIcon, Null);
        Set Player Variable(Event Player, RezHUD, Null);
        Set Player Variable(Event Player, ImbueTarget, Null);
    }
}

rule ("[moira/coalescence.opy]: Prevent fading during Coalescence") {
    event {
        Ongoing - Each Player;
        All;
        Moira;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 82.353);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[moira/init.opy]: initMoira()") {
    event {
        Subroutine;
        initMoira;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 200\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2800);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.923);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[moira/init.opy]: Increase Moira other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        Moira;
    }
    conditions {
        Is Using Ultimate(Event Player) == False;
        Array Contains(Array(Button(Melee), Button(Ability 2)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[orisa/energy_javelin.opy]: Increase damage from 60 to 65") {
    event {
        Player Dealt Damage;
        All;
        Orisa;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Event Player, 5);
    }
}

rule ("[orisa/terra_surge.opy]: Reduce Terra Surge base damage and add bonus overhealth") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Add Health Pool To Player(Event Player, Health, 181, False, True);
        Set Player Variable(Event Player, terra_overhealth_id, Last Created Health Pool);
        Set Damage Dealt(Event Player, 80);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Remove Health Pool From Player((Event Player).terra_overhealth_id);
    }
}

rule ("[orisa/terra_surge.opy]: Increase Terra Surge damage") {
    event {
        Player Dealt Damage;
        All;
        Orisa;
    }
    conditions {
        Event Ability == Button(Ultimate);
        "do not include wind-up damage"
        Event Damage >= 50;
    }
    actions {
        Damage(Victim, Attacker, Subtract(100, Event Damage));
    }
}

rule ("[orisa/fortify.opy]: -10% damage reduction and shorter cooldown = 10s") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        "I don't know where this value comes from or how to calculate it"
        Damage(Event Player, Null, 125.7);
        Set Player Variable(Event Player, Orisa_fortified, True);
        Modify Player Variable(Event Player, MoveSpeed, Add, 10);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Modify Player Variable(Event Player, DamageRecieved, Add, 30);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), Event Player, 8);
        Create Effect(All Players(All Teams), Ring, Color(Orange), Event Player, 8, Visible To Position and Radius);
        Set Player Variable(Event Player, Orisa_ring_effect, Last Created Entity);
        Wait Until(Not(Is Using Ability 1(Event Player)), 99999);
        Set Ability Cooldown(Event Player, Button(Ability 1), 10);
        Modify Player Variable(Event Player, DamageRecieved, Subtract, 30);
        Destroy Effect((Event Player).Orisa_ring_effect);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 10);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Set Player Variable(Event Player, Orisa_fortified, Null);
    }
}

rule ("[orisa/fortify.opy]: Orisa Fortify others by 20%") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Using Ability 1(Players On Hero(Hero(Orisa), Team Of(Event Player))) == True;
        Distance Between(Event Player, Players On Hero(Hero(Orisa), Team Of(Event Player))) < 8;
    }
    actions {
        Modify Player Variable(Event Player, DamageRecieved, Subtract, 20);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Wait Until(Or(Compare(Distance Between(Event Player, Players On Hero(Hero(Orisa), Team Of(Event Player))), >, 8), Not(Is Using Ability 1(Players On Hero(Hero(Orisa), Team Of(Event Player))))), 99999);
        Modify Player Variable(Event Player, DamageRecieved, Add, 20);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
    }
}

rule ("[orisa/fortify.opy]: Orisa cancel fortify after 3s") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait(3, Ignore Condition);
        Press Button(Event Player, Button(Ability 1));
    }
}

rule ("[orisa/fortify.opy]: Orisa cancel spin after 1s") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 100);
        Wait Until(Not(Is Using Ability 2(Event Player)), 1);
        Press Button(Event Player, Button(Ability 2));
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[orisa/spin.opy]: Movementspeed increase during Spin") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 2(Event Player)), 99999);
        Modify Player Variable(Event Player, MoveSpeed, Add, 35);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait(1, Ignore Condition);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 35);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

rule ("[orisa/heat.opy]: subtract ammo generate heat") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Update Every Frame(Is Firing Primary(Event Player)) == True;
    }
    actions {
        Modify Player Variable(Event Player, Orisa_Ammo, Subtract, 1);
        Modify Player Variable(Event Player, Orisa_heat, Add, 4);
        Wait(0.1, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[orisa/heat.opy]: ammo refresh") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).Orisa_Ammo <= 0;
    }
    actions {
        Set Ammo(Event Player, 0, 0);
        Chase Player Variable At Rate(Event Player, Orisa_Ammo, 100, 33, Destination and Rate);
        Set Primary Fire Enabled(Event Player, False);
        "damage(getPlayersInRadius(eventPlayer + Vector.UP, 6, getOppositeTeam(eventPlayer.getTeam()), LosCheck.SURFACES_AND_ENEMY_BARRIERS), eventPlayer, eventPlayer.Orisa_heat / eventPlayer.macro_pvar[0])"
        Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), Event Player, 8);
        Start Damage Over Time(Players Within Radius(Add(Event Player, Up), 8, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers), Event Player, 3, Divide(Divide((Event Player).Orisa_heat, 2.5), First Of((Event Player).macro_pvar)));
        Set Status(Players Within Radius(Event Player, 8, Opposite Team Of(Team Of(Event Player)), Surfaces), Event Player, Burning, 3);
        Wait(1, Ignore Condition);
        Wait Until(Compare((Event Player).Orisa_Ammo, >=, 100), 99999);
        Set Player Variable(Event Player, Orisa_heat, 0);
        Set Primary Fire Enabled(Event Player, True);
        Stop Chasing Player Variable(Event Player, Orisa_Ammo);
    }
}

rule ("[orisa/heat.opy]: reload") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Button Held(Event Player, Button(Reload)) == True;
    }
    actions {
        Set Player Variable(Event Player, Orisa_Ammo, 0);
    }
}

rule ("[orisa/heat.opy]: lock heat at 100") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).Orisa_heat > 100;
    }
    actions {
        Set Player Variable(Event Player, Orisa_heat, 100);
    }
}

rule ("[orisa/heat.opy]: Heat animation 100") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        (Event Player).Orisa_heat > 90;
    }
    actions {
        Set Status(Event Player, Null, Burning, 9999);
        Start Damage Over Time(Event Player, Event Player, 9999, 20);
        Set Player Variable(Event Player, Orisa_Overheating, Last Damage Over Time ID);
        Wait Until(Compare((Event Player).Orisa_heat, <=, 89), 99999);
        Clear Status(Event Player, Burning);
        Stop Damage Over Time((Event Player).Orisa_Overheating);
        Set Player Variable(Event Player, Orisa_Overheating, Null);
    }
}

disabled rule ("[orisa/heat.opy]: burn during fortify") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Start Damage Over Time(Players Within Radius(Add(Event Player, Up), 8, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers), Event Player, 1, Divide(Divide((Event Player).Orisa_heat, 2.5), First Of((Event Player).macro_pvar)));
        Set Status(Players Within Radius(Event Player, 8, Opposite Team Of(Team Of(Event Player)), Surfaces), Event Player, Burning, 1);
        Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), Event Player, 8);
        Wait(1, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[orisa/heat.opy]: heat refresh") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Firing Primary(Event Player) == False;
    }
    actions {
        Wait(1, Abort When False);
        Chase Player Variable At Rate(Event Player, Orisa_heat, 0, 25, Destination and Rate);
        Wait Until(Is Firing Primary(Event Player), 99999);
        Stop Chasing Player Variable(Event Player, Orisa_heat);
    }
}

rule ("[orisa/init.opy]: initOrisa()") {
    event {
        Subroutine;
        initOrisa;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 121);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1814);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.858);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Knockback Dealt(Event Player, 82);
        Set Player Variable(Event Player, Orisa_Ammo, 100);
        Create Progress Bar In-World Text(Event Player, (Event Player).Orisa_heat, Custom String("Heat"), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(-0.7, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 0.7, Do Not Clip, Color(Orange), Color(Orange), Visible To Position Values and Color, Default Visibility);
        Set Player Variable(Event Player, Orisa_Heat_HUD, Last Text ID);
        Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).Orisa_Ammo, Up)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(3.35, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.5, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 2, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, Orisa_Ammo_HUD, Last Text ID);
        "if not eventPlayer.isDuplicatingAHero():\nsetBaseDamage(eventPlayer, ADJ_ORISA_JAVELIN_DIRECT_DAMAGE / OW2_ORISA_JAVELIN_DIRECT_DAMAGE)"
        Set Player Variable(Event Player, balance_change_check, True);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[orisa/init.opy]: Correct Orisa Spin, Melee damage") {
    event {
        Player Dealt Damage;
        All;
        Orisa;
    }
    conditions {
        Array Contains(Array(Button(Ability 1), Button(Ability 2), Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[orisa/init.opy]: Correct Orisa Javelin damage") {
    event {
        Player Dealt Damage;
        All;
        Orisa;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.929, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[orisa/init.opy]: Clean up Orisa") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Orisa);
    }
    actions {
        Destroy Effect((Event Player).Orisa_ring_effect);
        Set Player Variable(Event Player, Orisa_Ammo, Null);
        Destroy Progress Bar In-World Text((Event Player).Orisa_Heat_HUD);
        Destroy In-World Text((Event Player).Orisa_Ammo_HUD);
    }
}

rule ("[pharah/init.opy]: initPharah()") {
    event {
        Subroutine;
        initPharah;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2100);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[ramattra/nemesis_form.opy]: Correct Nemesis Form armor and movement speed") {
    event {
        Ongoing - Each Player;
        All;
        Ramattra;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Start Scaling Player(Event Player, 0.97, True);
        Set Damage Dealt(Event Player, 92.308);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 16.6);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        "for some reason the addHealthPool function doesn't read constants as usable numbers"
        Add Health Pool To Player(Event Player, Armor, 11, True, False);
        Set Player Variable(Event Player, Nemesis_armor, Last Created Health Pool);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999986991104);
        Modify Player Variable(Event Player, MoveSpeed, Add, 16.6);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Stop Scaling Player(Event Player);
        Remove Health Pool From Player((Event Player).Nemesis_armor);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[ramattra/nemesis_form.opy]: Increase other forms of damage (in nemesis)") {
    event {
        Player Dealt Damage;
        All;
        Ramattra;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        "This condition stops pummel from applying the damage increase"
        Event Damage < 60;
    }
    actions {
        Damage(Victim, Null, Divide(Subtract(Divide(Event Damage, 0.923), Event Damage), 0.923));
    }
}

rule ("[ramattra/init.opy]: initRamattra()") {
    event {
        Subroutine;
        initRamattra;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 166);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 12);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2016);
        Call Subroutine(removeTankPassive);
        "eventPlayer.macro_pvar[0] = 1\neventPlayer.setDamageDealt(100 * eventPlayer.macro_pvar[0])"
        Set Player Variable(Event Player, max_health_scaler, 0.632);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[reaper/init.opy]: initReaper()") {
    event {
        Subroutine;
        initReaper;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1900);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.981);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 1, 1.2);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[reaper/init.opy]: Increase Reaper melee damage") {
    event {
        Player Dealt Damage;
        All;
        Reaper;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[reaper/init.opy]: Reduce Death Blossom damage") {
    event {
        Ongoing - Each Player;
        All;
        Reaper;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 91.892);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, 98.148);
    }
}

rule ("[reinhardt/firestrike.opy]: Force single firestrike") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 2(Event Player)), 0.9);
        "Every time rein uses firestrike, reset the resource to 0"
        Set Ability Charge(Event Player, Button(Ability 2), 0);
        Wait(6, Ignore Condition);
        Set Ability Charge(Event Player, Button(Ability 2), 2);
    }
}

rule ("[reinhardt/firestrike.opy]: decrease Firestrike damage (early animation)") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 83.333);
        Wait(1, Ignore Condition);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[reinhardt/pin.opy]: Slow Reinhardt after pin") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 1(Event Player)), 99999);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 50);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait(1, Ignore Condition);
        Modify Player Variable(Event Player, MoveSpeed, Add, 50);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

rule ("[reinhardt/charge.opy]: Correct Charge damage") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        "Checks for pin vs boop damage (+ 1 because apparently 50.0 > 50 == true for whatever reason)"
        If(Compare(Event Damage, >, 51));
            Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
        Else;
            Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[reinhardt/shatter.opy]: Correct Earthshatter damage") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Event Ability == Button(Ultimate);
        Event Was Critical Hit == False;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[reinhardt/shatter.opy]: Correct Earthshatter critical damage") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Event Ability == Button(Ultimate);
        Event Was Critical Hit == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[reinhardt/init.opy]: initReinhardt()") {
    event {
        Subroutine;
        initReinhardt;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 0\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1460);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.85);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Knockback Received(Event Player, 93.333);
        Stop Forcing Throttle(Event Player);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[roadhog/pigpen.opy]: Cancel Pigpen Animation") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait(0.08, Ignore Condition);
        Cancel Primary Action(Event Player);
    }
}

rule ("[roadhog/pigpen.opy]: Target Teammate") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
    }
    actions {
        Set Player Variable(Event Player, Roadhog_vape_target, First Of(Sorted Array(Filtered Array(All Living Players(Team Of(Event Player)), And(And(And(And(Compare(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)), <=, 30), Has Spawned(Current Array Element)), Compare(Distance Between(Event Player, Current Array Element), <=, 30)), Compare(Current Array Element, !=, Event Player)), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)))));
        Wait(0.16, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[roadhog/pigpen.opy]: Target Teammate HUD and allow Vape") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        (Event Player).Roadhog_vape_target != Null;
    }
    actions {
        "targeting hud"
        Create In-World Text(If-Then-Else(And(Compare((Event Player).Roadhog_vape_target, !=, Null), Compare(Ability Cooldown(Event Player, Button(Ability 2)), ==, 0)), Event Player, Null), Custom String(" \n\n\n\n\n\n     ︿\n〈      〉\n     ﹀ "), Add((Event Player).Roadhog_vape_target, Vector(0, 0.7, 0)), 2, Do Not Clip, Visible To Position and String, Custom Color(55, 230, 255, 210), Default Visibility);
        Set Player Variable(Event Player, Roadhog_targeting_hud, Last Text ID);
        Allow Button(Event Player, Button(Ability 2));
    }
}

rule ("[roadhog/pigpen.opy]: Disallow Vape") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        (Event Player).Roadhog_vape_target == Null;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 2));
        Destroy In-World Text((Event Player).Roadhog_targeting_hud);
    }
}

rule ("[roadhog/pigpen.opy]: Confirm Target") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Player Variable((Event Player).Roadhog_vape_target, Roadhog_vape_confirmed, True);
    }
}

rule ("[roadhog/pigpen.opy]: Buff Teammate and play effects") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).Roadhog_vape_confirmed == True;
    }
    actions {
        Set Player Variable(Event Player, Roadhog_vape_confirmed, False);
        Create Effect(Remove From Array(All Players(All Teams), Event Player), Cloud, Color(Yellow), Event Player, 0.9, Visible To Position and Radius);
        Set Player Variable(Event Player, Roadhog_vape_effect, Last Created Entity);
        Set Player Variable(Players On Hero(Hero(Roadhog), Team Of(Event Player)), Roadhog_vape_target, Null);
        Set Player Variable(Event Player, Roadhog_vape_hud_icon, True);
        Big Message(Event Player, Custom String("VAPED"));
        Play Effect(All Players(All Teams), Explosion Sound, Color(White), Event Player, 80);
        Start Heal Over Time(Event Player, Players On Hero(Hero(Roadhog), Team Of(Event Player)), 3, 55);
        Modify Player Variable(Event Player, DamageRecieved, Subtract, 40);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Wait(3, Ignore Condition);
        Modify Player Variable(Event Player, DamageRecieved, Add, 40);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Destroy Effect((Event Player).Roadhog_vape_effect);
        Set Player Variable(Event Player, Roadhog_vape_hud_icon, Null);
    }
}

rule ("[roadhog/breather.opy]: Adjust Breather efficacy") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Healing Dealt(Event Player, 222.222);
        Wait(0.8, Ignore Condition);
        Set Healing Dealt(Event Player, 48.387);
        Wait Until(Not(Is Firing Secondary(Event Player)), 999999986991104);
        Set Healing Dealt(Event Player, 100);
    }
}

rule ("[roadhog/wholehog.opy]: Disable abilities during wholehog") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Melee Enabled(Event Player, False);
        Set Secondary Fire Enabled(Event Player, False);
        Set Ability 1 Enabled(Event Player, False);
        Set Ability 2 Enabled(Event Player, False);
        Set Damage Dealt(Event Player, 100);
        Set Knockback Dealt(Event Player, 100);
    }
}

rule ("[roadhog/wholehog.opy]: Enable abilities after wholehog") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Set Melee Enabled(Event Player, True);
        Set Secondary Fire Enabled(Event Player, True);
        Set Ability 1 Enabled(Event Player, True);
        Set Ability 2 Enabled(Event Player, True);
        Stop Holding Button(Event Player, Button(Primary Fire));
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Knockback Dealt(Event Player, 35);
    }
}

rule ("[roadhog/wholehog.opy]: Force autofire while in wholehog") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Is Button Held(Event Player, Button(Primary Fire)) == False;
    }
    actions {
        Start Holding Button(Event Player, Button(Primary Fire));
    }
}

rule ("[roadhog/primary.opy]: true damage") {
    event {
        Player Dealt Damage;
        All;
        Roadhog;
    }
    conditions {
        Button(Primary Fire) == Event Ability;
    }
    actions {
        Damage(Victim, Event Player, Divide(10, First Of((Event Player).macro_pvar)));
        Wait(0.625, Ignore Condition);
    }
}

rule ("[roadhog/init.opy]: initRoadhog()") {
    event {
        Subroutine;
        initRoadhog;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 550\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2380);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.831);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Ammo(Event Player, 0, 6);
        Set Max Ammo(Event Player, 0, 6);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[roadhog/init.opy]: Correct other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        Roadhog;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Ability 1)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[roadhog/init.opy]: Clean up Roadhog") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Roadhog);
    }
    actions {
        Set Player Variable(Event Player, Roadhog_vape_target, Null);
        Destroy In-World Text((Event Player).Roadhog_targeting_hud);
    }
}

rule ("[sigma/kinetic_grasp.opy]: Reduce Kinetic Grasp overhealth") {
    event {
        Ongoing - Each Player;
        All;
        Sigma;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait(1.2, Abort When False);
        Set Player Variable(Event Player, hp_exiting_grasp, Health(Event Player));
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999986991104);
        Damage(Event Player, Null, Multiply(0.3, Subtract(Health(Event Player), (Event Player).hp_exiting_grasp)));
    }
}

rule ("[sigma/init.opy]: initSigma()") {
    event {
        Subroutine;
        initSigma;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 3.6);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 14.325);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2275);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.75);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, balance_change_check, 0);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[sigma/init.opy]: Reduce Accretion stun duration") {
    event {
        Player Dealt Damage;
        All;
        Sigma;
    }
    conditions {
        Has Status(Victim, Knocked Down) == True;
    }
    actions {
        Wait(0.5, Ignore Condition);
        Clear Status(Victim, Knocked Down);
    }
}

rule ("[sigma/init.opy]: Increase Sigma other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        Sigma;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Primary Fire)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[sigma/init.opy]: Increase Gravitic Flux damage") {
    event {
        Ongoing - Each Player;
        All;
        Sigma;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 100);
        "waitUntil(not eventPlayer.isUsingUltimate(), 999999986991104)"
        Wait Until(Or(Is Button Held(Event Player, Button(Primary Fire)), Not(Is Using Ultimate(Event Player))), 10);
        Wait(1.7, Ignore Condition);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[sojourn/primary.opy] Increased primary damage") {
    event {
        Player Dealt Damage;
        All;
        Sojourn;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        If(Event Was Critical Hit);
            Damage(Victim, Event Player, 3);
        Else;
            Damage(Victim, Event Player, 1.5);
    }
}

rule ("[sojourn/orb.opy] Increased disruptor shot damage") {
    event {
        Player Dealt Damage;
        All;
        Sojourn;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Damage(Victim, Event Player, 5.2);
    }
}

rule ("[sojourn/ultimate.opy] 200 damage in ult") {
    event {
        Player Dealt Damage;
        All;
        Sojourn;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Event Ability == Button(Ultimate);
    }
    actions {
        If(Event Was Critical Hit);
            Damage(Victim, Event Player, Multiply(Event Damage, 0.4));
    }
}

rule ("[sojourn/init.opy]: initSojourn()") {
    event {
        Subroutine;
        initSojourn;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 0\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2100);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.834);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[soldier/init.opy]: initSoldier()") {
    event {
        Subroutine;
        initSoldier;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 200\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2310);
        Set Player Variable At Index(Event Player, macro_pvar, 1, 0.875);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Ammo(Event Player, 0, 30);
        Set Max Ammo(Event Player, 0, 30);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[soldier/init.opy]: Increase Heavy Pulse Rifle damage") {
    event {
        Player Dealt Damage;
        All;
        Soldier: 76;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 1.053), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[sombra/virus.opy]: Sombra Virus Cancel") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait(0.04, Ignore Condition);
        Cancel Primary Action(Event Player);
    }
}

rule ("[sombra/virus.opy]: Target Teammate") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions {
        Set Player Variable(Event Player, Sombra_virus_target, First Of(Sorted Array(Filtered Array(All Living Players(Team Of(Event Player)), And(And(And(And(Compare(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)), <=, 30), Has Spawned(Current Array Element)), Compare(Distance Between(Event Player, Current Array Element), <=, 20)), Compare(Current Array Element, !=, Event Player)), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)))));
        Wait(0.16, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[sombra/virus.opy]: Target Teammate HUD and allow Virus") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        (Event Player).Sombra_virus_target != Null;
    }
    actions {
        "targeting hud"
        Create In-World Text(If-Then-Else(And(Compare((Event Player).Sombra_virus_target, !=, Null), Compare(Ability Cooldown(Event Player, Button(Ability 1)), ==, 0)), Event Player, Null), Custom String(" \n\n\n\n\n\n     ︿\n〈      〉\n     ﹀ "), Add((Event Player).Sombra_virus_target, Vector(0, 0.7, 0)), 2, Do Not Clip, Visible To Position and String, Custom Color(55, 230, 255, 210), Default Visibility);
        Set Player Variable(Event Player, Sombra_targeting_hud, Last Text ID);
        Allow Button(Event Player, Button(Ability 1));
    }
}

rule ("[sombra/virus.opy]: Disallow Virus") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        (Event Player).Sombra_virus_target == Null;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 1));
        Destroy In-World Text((Event Player).Sombra_targeting_hud);
    }
}

rule ("[sombra/virus.opy]: Confirm Target") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable((Event Player).Sombra_virus_target, Sombra_virus_confirmed, True);
    }
}

rule ("[sombra/virus.opy]: Buff Teammate and play effects") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).Sombra_virus_confirmed == True;
    }
    actions {
        Set Player Variable(Event Player, Sombra_virus_confirmed, False);
        Big Message(Event Player, Custom String("HACKED"));
        Set Player Variable(Players On Hero(Hero(Sombra), Team Of(Event Player)), Sombra_virus_target, Null);
        Create In-World Text(All Players(All Teams), Ability Icon String(Hero(Sombra), Button(Ultimate)), Add(Event Player, Vector(0, 2.5, 0)), 2, Clip Against Surfaces, Visible To Position and String, Color(Purple), Default Visibility);
        Set Player Variable(Event Player, Sombra_hack_effect, Last Text ID);
        Set Player Variable(Event Player, Sombra_hack_icon, True);
        Start Heal Over Time(Event Player, Players On Hero(Hero(Sombra), Team Of(Event Player)), 5, 30);
        Play Effect(All Players(All Teams), Good Pickup Effect, Color(Purple), Event Player, 90);
        Play Effect(All Players(All Teams), Ring Explosion, Color(Purple), Add(Event Player, Up), 4);
        Play Effect(All Players(All Teams), Buff Explosion Sound, Color(White), Event Player, 80);
        Modify Player Variable(Event Player, MoveSpeed, Add, 30);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait(5, Ignore Condition);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 30);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Destroy In-World Text((Event Player).Sombra_hack_effect);
        Set Player Variable(Event Player, Sombra_hack_icon, Null);
    }
}

rule ("[sombra/translocator.opy]: Sombra Invis Increase move Speed") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        (Event Player).Sombra_invisible == True;
    }
    actions {
        Modify Player Variable(Event Player, MoveSpeed, Add, 10);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait Until(Compare((Event Player).Sombra_invisible, ==, False), 99999);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 10);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

disabled rule ("[sombra/translocator.opy] Sombra stealth damage cancel count damage") {
    event {
        Player Took Damage;
        All;
        Sombra;
    }
    conditions {
        (Event Player).stealth_timer > 0;
        (Event Player).stealth_timer <= 5;
    }
    actions {
        "eventPlayer.Sombra_invis_damage += eventDamage\nif eventPlayer.Sombra_invis_damage >= 40:"
        Set Status(Event Player, Null, Rooted, 0.001);
        Set Player Variable(Event Player, stealth_timer, 0);
        Set Player Variable(Event Player, Sombra_invisible, False);
    }
}

disabled rule ("[sombra/translocator.opy]: When Translocator is used, begin tracking how long Sombra is in stealth") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Sombra);
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        "eventPlayer.Sombra_invis_damage = 0"
        Set Player Variable(Event Player, stealth_timer, 5.5);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999986991104);
        Set Player Variable(Event Player, Sombra_invisible, True);
        Chase Player Variable At Rate(Event Player, stealth_timer, 0, 1, None);
        "Sombra can't break stealth during the cast time of stealth"
        Wait(0.5, Restart When True);
        "Wait until Sombra exits Stealth"
        Wait Until(Or(Or(Or(Or(Or(Or(Or(Or(Is True For Any(Array(Has Status(Event Player, Asleep), Has Status(Event Player, Frozen), Has Status(Event Player, Hacked), Has Status(Event Player, Knocked Down), Has Status(Event Player, Stunned), Has Status(Event Player, Rooted)), Current Array Element), Compare((Event Player).Sombra_invisible, ==, False)), Is Firing Primary(Event Player)), And(Is Button Held(Event Player, Button(Primary Fire)), Not(Is Firing Secondary(Event Player)))), And(Compare(Ability Cooldown(Event Player, Button(Ability 1)), ==, 0), Is Button Held(Event Player, Button(Ability 1)))), Is Button Held(Event Player, Button(Melee))), Is Meleeing(Event Player)), Is Using Ultimate(Event Player)), And(Compare(Value In Array((Event Player).stealth_pvar, 1), ==, 100), Is Button Held(Event Player, Button(Ultimate)))), 5);
        Set Player Variable(Event Player, Sombra_invisible, False);
        Stop Chasing Player Variable(Event Player, stealth_timer);
        Abort If(Compare((Event Player).stealth_timer, <=, 0));
        If(Global.NEGATIVE_STATUS_PREVENTS_REFUND);
            Abort If(Is True For Any(Array(Has Status(Event Player, Asleep), Has Status(Event Player, Frozen), Has Status(Event Player, Hacked), Has Status(Event Player, Knocked Down), Has Status(Event Player, Stunned), Has Status(Event Player, Rooted)), Current Array Element));
        End;
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Ability 2)), >, 0), 1);
        "printLog(\"Current Translocator Cooldown: {0} | Target Translocator Cooldown: {1}\".format(eventPlayer.getAbilityCooldown(Button.ABILITY_2), eventPlayer._stealth_max_cooldown - 5 + (eventPlayer.stealth_timer * (1 - STEALTH_REFUND_FRACTION))))"
        Set Ability Cooldown(Event Player, Button(Ability 2), Add(Subtract(First Of((Event Player).stealth_pvar), 5), Multiply((Event Player).stealth_timer, Subtract(1, Global.STEALTH_REFUND_FRACTION))));
    }
}

rule ("[sombra/translocator.opy]: Sombra stealth refund variables") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable(STEALTH_REFUND_FRACTION, Divide(Workshop Setting Integer(Custom String("Gameplay Settings"), Custom String("Percent of Stealth Timer Remaining Refunded Towards Translocator Cooldown"), 40, 0, 100, 0), 100));
        Set Global Variable(NEGATIVE_STATUS_PREVENTS_REFUND, Workshop Setting Toggle(Custom String("Gameplay Settings"), Custom String("Negative Status Effects Cancelling Stealth Prevents Translocator Cooldown Refund"), True, 1));
        Set Global Variable(MINIMUM_TRANSLOCATOR_COOLDOWN, 4);
    }
}

rule ("[sombra/translocator.opy]: When Translocator is used, begin tracking how long Sombra is in stealth") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Sombra);
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        "eventPlayer.Sombra_invis_damage = 0"
        Set Player Variable(Event Player, stealth_timer, 4.82);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999986991104);
        Set Player Variable(Event Player, Sombra_invisible, True);
        Chase Player Variable At Rate(Event Player, stealth_timer, 0, 1, None);
        "Sombra can't break stealth during the cast time of stealth\nwait(0.5, Wait.RESTART_WHEN_TRUE)\nWait until Sombra exits Stealth"
        Wait Until(Or(Or(Or(Or(Or(Or(Or(Or(Is True For Any(Array(Has Status(Event Player, Asleep), Has Status(Event Player, Frozen), Has Status(Event Player, Hacked), Has Status(Event Player, Knocked Down), Has Status(Event Player, Stunned), Has Status(Event Player, Rooted)), Current Array Element), Compare((Event Player).Sombra_invisible, ==, False)), Is Firing Primary(Event Player)), And(Is Button Held(Event Player, Button(Primary Fire)), Not(Is Firing Secondary(Event Player)))), And(Compare(Ability Cooldown(Event Player, Button(Ability 1)), ==, 0), Is Button Held(Event Player, Button(Ability 1)))), Is Button Held(Event Player, Button(Melee))), Is Meleeing(Event Player)), Is Using Ultimate(Event Player)), And(Compare(Value In Array((Event Player).stealth_pvar, 1), ==, 100), Is Button Held(Event Player, Button(Ultimate)))), 4.82);
        Set Player Variable(Event Player, Sombra_invisible, False);
        Stop Chasing Player Variable(Event Player, stealth_timer);
        Abort If(Compare((Event Player).stealth_timer, <=, 0));
        If(Global.NEGATIVE_STATUS_PREVENTS_REFUND);
            Abort If(Is True For Any(Array(Has Status(Event Player, Asleep), Has Status(Event Player, Frozen), Has Status(Event Player, Hacked), Has Status(Event Player, Knocked Down), Has Status(Event Player, Stunned), Has Status(Event Player, Rooted)), Current Array Element));
        End;
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Ability 2)), >, 0), 1);
        "printLog(\"Current Translocator Cooldown: {0} | Target Translocator Cooldown: {1}\".format(eventPlayer.getAbilityCooldown(Button.ABILITY_2), eventPlayer._stealth_max_cooldown - 5 + (eventPlayer.stealth_timer * (1 - STEALTH_REFUND_FRACTION))))"
        Set Ability Cooldown(Event Player, Button(Ability 2), Add(Subtract(First Of((Event Player).stealth_pvar), 5), Multiply((Event Player).stealth_timer, Subtract(1, Global.STEALTH_REFUND_FRACTION))));
    }
}

rule ("[sombra/translocator.opy] Sombra stealth self cancel") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        (Event Player).stealth_timer <= 5;
        (Event Player).stealth_timer > 0;
        Is Button Held(Event Player, Button(Ability 2)) == True;
        (Event Player).Sombra_invisible == True;
    }
    actions {
        Set Status(Event Player, Null, Rooted, 0.001);
        Set Player Variable(Event Player, Sombra_invisible, False);
        "printLog(\"Current Translocator Cooldown: {0} | Target Translocator Cooldown: {1}\".format(eventPlayer.getAbilityCooldown(Button.ABILITY_2), eventPlayer._stealth_max_cooldown - 5 + (eventPlayer.stealth_timer * (1 - STEALTH_REFUND_FRACTION))))"
        Set Ability Cooldown(Event Player, Button(Ability 2), Add(Subtract(First Of((Event Player).stealth_pvar), 5), Multiply((Event Player).stealth_timer, Subtract(1, Global.STEALTH_REFUND_FRACTION))));
        Set Player Variable(Event Player, stealth_timer, 0);
    }
}

rule ("[sombra/translocator.opy]: Set max stealth cooldown observed") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Sombra);
        Ability Cooldown(Event Player, Button(Ability 2)) > First Of((Event Player).stealth_pvar);
    }
    actions {
        Set Player Variable At Index(Event Player, stealth_pvar, 0, Round To Integer(Ability Cooldown(Event Player, Button(Ability 2)), To Nearest));
    }
}

rule ("[sombra/stealth.opy]: Sombra stealth took damage") {
    event {
        Player Took Damage;
        All;
        Sombra;
    }
    conditions {
        (Event Player).Sombra_invisible == True;
    }
    actions {
        Set Player Variable(Event Player, Sombra_invis_damage, True);
        Wait(1.3, Restart When True);
        Set Player Variable(Event Player, Sombra_invis_damage, False);
    }
}

rule ("[sombra/stealth.opy]: Sombra stealth reveal slow") {
    event {
        Player Took Damage;
        All;
        Sombra;
    }
    conditions {
        (Event Player).Sombra_invis_damage == True;
        (Event Player).Sombra_invisible == True;
    }
    actions {
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 47.5);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait Until(Or(Not((Event Player).Sombra_invisible), Not((Event Player).Sombra_invis_damage)), 100000000);
        Modify Player Variable(Event Player, MoveSpeed, Add, 47.5);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

rule ("[sombra/opportunist.opy] Remove 20% damage increase") {
    event {
        Player Dealt Damage;
        All;
        Sombra;
    }
    conditions {
        Has Status(Victim, Hacked) == True;
    }
    actions {
        Heal(Victim, Null, Divide(Event Damage, 6));
    }
}

rule ("[sombra/emp.opy]: Heal damage EMP does and prevent extra hack time from triggering") {
    event {
        Player Dealt Damage;
        All;
        Sombra;
    }
    conditions {
        Event Ability == Button(Ultimate);
    }
    actions {
        Heal(Victim, Null, Event Damage);
        Wait(3, Ignore Condition);
        Clear Status(Victim, Hacked);
    }
}

rule ("[sombra/init.opy]: initSombra()") {
    event {
        Subroutine;
        initSombra;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 200\neventPlayer.custom_hp_pvar[1] = null\neventPlayer.custom_hp_pvar[2] = null\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2800);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.875);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, Sombra_invisible, False);
        Create In-World Text(Event Player, Custom String("{0} {1}", Count Of(Filtered Array(All Living Players(Team Of(Event Player)), And(And(Compare(Distance Between(Event Player, Current Array Element), <=, 15), Is In Line of Sight(Event Player, Current Array Element, Enemy Barriers Block LOS)), Compare(Hero Of(Current Array Element), !=, Hero(Sombra))))), Icon String(Plus)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(-0.3, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 1.8, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, Sombra_hud, Last Text ID);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[sombra/init.opy]: Increase Sombra melee damage") {
    event {
        Player Dealt Damage;
        All;
        Sombra;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[sombra/init.opy]: Clean up Sombra") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Sombra);
    }
    actions {
        Set Player Variable(Event Player, Sombra_virus_target, Null);
        Destroy In-World Text((Event Player).Sombra_targeting_hud);
        Destroy Effect((Event Player).Sombra_healing_ring);
        Destroy In-World Text((Event Player).Sombra_hud);
        Destroy HUD Text(Value In Array((Event Player).Explaination_Hud, 3));
    }
}

rule ("[symmetra/init.opy]: initSymmetra()") {
    event {
        Subroutine;
        initSymmetra;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 5.25);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 12.5);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1680);
        Set Player Variable(Event Player, max_health_scaler, 0.75);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[symmetra/init.opy]: Correct Photon projector damage") {
    event {
        Player Dealt Damage;
        All;
        Symmetra;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.05), Event Damage));
    }
}

rule ("[torbjorn/turret.opy]: turret damage increase") {
    event {
        Player Dealt Damage;
        All;
        Torbjörn;
    }
    conditions {
        Button(Ability 1) == Event Ability;
    }
    actions {
        Damage(Victim, Event Player, Divide(1, First Of((Event Player).macro_pvar)));
    }
}

rule ("[torbjorn/init.opy]: initTorbjorn()") {
    event {
        Subroutine;
        initTorbjorn;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 16.725);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2142);
        Set Ammo(Event Player, 0, 18);
        Set Max Ammo(Event Player, 0, 18);
        Set Player Variable(Event Player, overhealth_check, False);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[torbjorn/init.opy]: Increase Rivet Gun alternate fire ammo cost") {
    event {
        Ongoing - Each Player;
        All;
        Torbjörn;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Ammo(Event Player, 0, Subtract(Ammo(Event Player, 0), 1));
    }
}

rule ("[torbjorn/init.opy]: Increase Overload overhealth") {
    event {
        Ongoing - Each Player;
        All;
        Torbjörn;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Add Health Pool To Player(Event Player, Health, 22.3, False, True);
        Set Player Variable(Event Player, overload_overhealth, Last Created Health Pool);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999986991104);
        Remove Health Pool From Player((Event Player).overload_overhealth);
    }
}

rule ("[tracer/init.opy]: initTracer()") {
    event {
        Subroutine;
        initTracer;
    }
    actions {
        "eventPlayer.setHealingReceived(0)\neventPlayer.addHealthPool(Health.NORMAL, 1, true)\neventPlayer.addHealthPool(Health.ARMOR, 1, true)\neventPlayer.addHealthPool(Health.SHIELDS, 1, true)\neventPlayer.removeAllHealthPools()\n__end__()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1250);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.964);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Start Scaling Player(Event Player, 0.96, True);
        Set Player Variable(Event Player, max_health_scaler, 0.857);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[tracer/init.opy]: Correct melee and Pulse Bomb damage") {
    event {
        Player Dealt Damage;
        All;
        Tracer;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Ultimate)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[venture/excavator.opy]: Prepare Smart Excavator damage increase") {
    event {
        Ongoing - Each Player;
        All;
        Venture;
    }
    conditions {
        Is Firing Primary(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, is_firing_excavator, True);
        Wait(0.3, Ignore Condition);
        Set Player Variable(Event Player, is_firing_excavator, False);
    }
}

rule ("[venture/excavator.opy]: Correct Smart Excavator damage") {
    event {
        Player Dealt Damage;
        All;
        Venture;
    }
    conditions {
        (Event Player).is_firing_excavator != False;
        Is Using Ability 1(Event Player) == False;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.8), Event Damage), First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, is_firing_excavator, False);
    }
}

rule ("[venture/drill_dash.opy]: Correct Drill Dash damage") {
    event {
        Player Dealt Damage;
        All;
        Venture;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.444), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[venture/clobber.opy]: Correct Venture melee damage") {
    event {
        Player Dealt Damage;
        All;
        Venture;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        "damage(victim, attacker, ((eventDamage/eventPlayer._base_damage_scalar) * (ADJ_VENTURE_CLOBBER_DAMAGE / OW2_VENTURE_CLOBBER_DAMAGE) - eventDamage)/eventPlayer._base_damage_scalar)"
        Set Player Variable(Event Player, clobber_cooldown_accelerator, Ability Cooldown(Event Player, Button(Ability 1)));
        Set Ability Cooldown(Event Player, Button(Ability 1), Subtract((Event Player).clobber_cooldown_accelerator, 0.5));
    }
}

rule ("[venture/burrow.opy]: Burrow speed decrease and dash cooldown 0") {
    event {
        Ongoing - Each Player;
        All;
        Venture;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait Until(Is On Ground(Event Player), 7);
        Wait(0.6, Abort When False);
        If(And(Compare(Ability Cooldown(Event Player, Button(Secondary Fire)), !=, 0), Not(Is Firing Secondary(Event Player))));
            Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
        End;
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 70);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait Until(Not(Is Using Ability 1(Event Player)), 99999);
        Modify Player Variable(Event Player, MoveSpeed, Add, 70);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        If(And(Compare(Ability Cooldown(Event Player, Button(Secondary Fire)), !=, 0), Not(Is Firing Secondary(Event Player))));
            Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
    }
}

rule ("[venture/burrow.opy]: Burrow speed increase when dashing") {
    event {
        Ongoing - Each Player;
        All;
        Venture;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Modify Player Variable(Event Player, MoveSpeed, Add, 110);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait Until(Not(Is Firing Secondary(Event Player)), 99999);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 110);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

rule ("[venture/burrow.opy]: Correct Burrow damage") {
    event {
        Player Dealt Damage;
        All;
        Venture;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.55), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[venture/burrow.opy]: Burrow Knockup") {
    event {
        Player Dealt Damage;
        All;
        Venture;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Apply Impulse(Victim, Up, 10, To World, Cancel Contrary Motion);
        Set Status(Event Player, Null, Rooted, 0.3);
    }
}

rule ("[venture/tectonic_shock.opy]: Tectonic Shock logic") {
    event {
        Player Dealt Damage;
        All;
        Venture;
    }
    conditions {
        Event Ability == Button(Ultimate);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.73), Event Damage), First Of((Event Player).macro_pvar)));
        Apply Impulse(Victim, Up, 8, To World, Cancel Contrary Motion);
        Set Status(Event Player, Null, Rooted, 0.3);
    }
}

rule ("[venture/init.opy]: initVenture()") {
    event {
        Subroutine;
        initVenture;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 100);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 50);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1550);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.429);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Knockback Dealt(Event Player, 80);
        Set Ammo(Event Player, 0, 6);
        Set Max Ammo(Event Player, 0, 6);
        Set Player Variable(Event Player, max_health_scaler, 0.833);
        Start Scaling Player(Event Player, 1.18, True);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[venture/init.opy]: Reduce Headshot damage taken Venture") {
    event {
        Player Took Damage;
        All;
        Venture;
    }
    conditions {
        Event Was Critical Hit == True;
    }
    actions {
        Heal(Event Player, Null, Multiply(Event Damage, 0.3));
    }
}

rule ("[widowmaker/weapon.opy]: Widowmaker scope glint") {
    event {
        Ongoing - Each Player;
        All;
        Widowmaker;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        "Without aiming at widow check"
        Create Effect(Filtered Array(All Players(Opposite Team Of(Team Of(Event Player))), And(Compare(Distance Between(Event Player, Current Array Element), >=, 3), Is In View Angle(Event Player, Eye Position(Current Array Element), 15))), Good Aura, Color(White), Eye Position(Event Player), 0.45, Visible To Position and Radius);
        Set Player Variable(Event Player, WidowScopeGlint_effect, Last Created Entity);
        Wait Until(Not(Is Firing Secondary(Event Player)), 100000000);
        Destroy Effect((Event Player).WidowScopeGlint_effect);
    }
}

rule ("[widowmaker/weapon.opy]: beam") {
    event {
        Ongoing - Each Player;
        All;
        Widowmaker;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Wait(0.9, Abort When False);
        Create Beam Effect(All Players(Opposite Team Of(Team Of(Event Player))), Bad Beam, Add(Eye Position(Event Player), World Vector Of(Vector(0, -0.14, 0), Event Player, Rotation)), Ray Cast Hit Position(Eye Position(Event Player), Add(Eye Position(Event Player), Multiply(Facing Direction Of(Event Player), 70)), All Players(All Teams), Event Player, True), Color(Red), Visible To Position and Radius);
        Set Player Variable(Event Player, Widowmaker_beam_effect, Last Created Entity);
        Wait Until(Not(Is Firing Secondary(Event Player)), 99999);
        Destroy Effect((Event Player).Widowmaker_beam_effect);
        Set Player Variable(Event Player, Widowmaker_beam_effect, Null);
    }
}

rule ("[widowmaker/weapon.opy]: force fire after 5s") {
    event {
        Ongoing - Each Player;
        All;
        Widowmaker;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Has Spawned(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 87.5);
        Set Player Variable(Event Player, Widow_maxscope_duration, 100);
        Create Progress Bar In-World Text(Event Player, (Event Player).Widow_maxscope_duration, Custom String("Focus"), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(0.3, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 0.7, Do Not Clip, Color(White), Color(White), Visible To Position Values and Color, Default Visibility);
        Set Player Variable(Event Player, Widow_Focus_HUD, Last Text ID);
        Chase Player Variable At Rate(Event Player, Widow_maxscope_duration, 0, 25, Destination and Rate);
        Wait Until(Or(Not(Is Firing Secondary(Event Player)), Is Button Held(Event Player, Button(Primary Fire))), 4);
        If(Is Button Held(Event Player, Button(Primary Fire)));
            Press Button(Event Player, Button(Secondary Fire));
        Else If(Is Firing Secondary(Event Player));
            Press Button(Event Player, Button(Primary Fire));
            Press Button(Event Player, Button(Secondary Fire));
        End;
        Stop Chasing Player Variable(Event Player, Widow_maxscope_duration);
        Destroy Progress Bar In-World Text((Event Player).Widow_Focus_HUD);
        Set Secondary Fire Enabled(Event Player, False);
        Wait(0.34, Ignore Condition);
        Set Secondary Fire Enabled(Event Player, True);
    }
}

rule ("[widowmaker/weapon.opy]: unscope / reset") {
    event {
        Ongoing - Each Player;
        All;
        Widowmaker;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Firing Secondary(Event Player)), 99999);
        Stop Chasing Player Variable(Event Player, Widow_maxscope_duration);
        Destroy Progress Bar In-World Text((Event Player).Widow_Focus_HUD);
        Set Player Variable(Event Player, Widow_Focus_HUD, Null);
        Set Player Variable(Event Player, Widow_maxscope_duration, Null);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[widowmaker/grapple.opy]: Grapple kick") {
    event {
        Ongoing - Each Player;
        All;
        Widowmaker;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait(0.2, Ignore Condition);
        Wait Until(Or(Not(Is Using Ability 1(Event Player)), Is Button Held(Event Player, Button(Ability 1))), 6);
        If(Is Button Held(Event Player, Button(Ability 1)));
            Start Holding Button(Event Player, Button(Jump));
            Wait(0.1, Ignore Condition);
            Press Button(Event Player, Button(Melee));
            Play Effect(All Players(All Teams), Ring Explosion, Color(White), Event Player, 3);
            Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Event Player, 50);
            Apply Impulse(Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))), And(And(Compare(Distance Between(Event Player, Current Array Element), <=, 3), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS)), Compare(Current Array Element, !=, Event Player))), Vector(0, 10, 0), 5, To World, Incorporate Contrary Motion);
            Apply Impulse(Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))), And(And(Compare(Distance Between(Event Player, Current Array Element), <=, 3), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS)), Compare(Current Array Element, !=, Event Player))), Direction Towards(Event Player, Add(Eye Position(Event Player), Multiply(Facing Direction Of(Event Player), 30))), 20, To World, Incorporate Contrary Motion);
            Damage(Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))), And(Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS), Compare(Distance Between(Event Player, Current Array Element), <=, 3))), Event Player, 25);
        End;
        Stop Holding Button(Event Player, Button(Jump));
    }
}

rule ("[widowmaker/init.opy]: initWidowmaker()") {
    event {
        Subroutine;
        initWidowmaker;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 200\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 0\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1540);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

disabled rule ("[widowmaker/init.opy]: Reduce Scoped Shot damage") {
    event {
        Ongoing - Each Player;
        All;
        Widowmaker;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 87.5);
        Wait Until(Not(Is Firing Secondary(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[winston/primal.opy]: Remove bonus Primal Rage health") {
    event {
        Ongoing - Each Player;
        All;
        Winston;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Call Subroutine(clearCustomHp);
        Add Health Pool To Player(Event Player, Armor, 15, True, False);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Call Subroutine(clearCustomHp);
        Call Subroutine(applyCustomHp);
    }
}

rule ("[winston/primal.opy]: Reduce Primal Rage damage") {
    event {
        Ongoing - Each Player;
        All;
        Winston;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 80);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        "revert damage back after Primal Rage concludes"
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[winston/primal.opy]: Correct Jump Pack damage during Primal Rage") {
    event {
        Player Dealt Damage;
        All;
        Winston;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Event Ability == Button(Ability 1);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, 0.8), Event Damage), 0.8));
    }
}

rule ("[winston/init.opy]: initWinston()") {
    event {
        Subroutine;
        initWinston;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 46.175);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 15.4);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1650);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.821);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, max_health_scaler, 0.923);
        Set Max Ammo(Event Player, 0, 100);
        Set Ammo(Event Player, 0, 100);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[winston/init.opy]: Correct Jump Pack, Melee, Primal Rage damage") {
    event {
        Player Dealt Damage;
        All;
        Winston;
    }
    conditions {
        Is Using Ultimate(Event Player) == False;
        Array Contains(Array(Button(Ability 1), Button(Melee), Button(Secondary Fire)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[wreckingball/grapple.opy]: Force Grappling Hook cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Wrecking Ball;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Secondary Fire)), >, 0), 999999986991104);
        If(Compare(Ability Cooldown(Event Player, Button(Secondary Fire)), <=, 1));
            Set Ability Cooldown(Event Player, Button(Secondary Fire), 1.92);
    }
}

rule ("[wreckingball/grapple.opy]: Increase Fireball impact damage") {
    event {
        Player Dealt Damage;
        All;
        Wrecking Ball;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.833, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[wreckingball/shields.opy]: Remove Adaptive Shields overhealth transfer") {
    event {
        Ongoing - Each Player;
        All;
        Wrecking Ball;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 2));
        Set Ability 2 Enabled(Event Player, False);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999986991104);
        Call Subroutine(enableAllAbilities);
        Allow Button(Event Player, Button(Ability 2));
    }
}

rule ("[wreckingball/shields.opy]: Increase Adaptive Shield base overhealth gain") {
    event {
        Ongoing - Each Player;
        All;
        Wrecking Ball;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Add Health Pool To Player(Event Player, Health, 100, False, True);
        Set Player Variable(Event Player, adaptive_overhealth_id, Last Created Health Pool);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999986991104);
        Remove Health Pool From Player((Event Player).adaptive_overhealth_id);
        Set Player Variable(Event Player, adaptive_overhealth_id, Null);
    }
}

rule ("[wreckingball/piledriver.opy]: Increase Piledriver / Quadcannon damage") {
    event {
        Player Dealt Damage;
        All;
        Wrecking Ball;
    }
    conditions {
        Array Contains(Array(Button(Primary Fire), Button(Crouch)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.8, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[wreckingball/init.opy]: initWreckingBall()") {
    event {
        Subroutine;
        initWreckingBall;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 175);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 12.5);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1540);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.788);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Ammo(Event Player, 0, 80);
        Set Max Ammo(Event Player, 0, 80);
        Set Player Variable(Event Player, max_health_scaler, 0.5);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[wreckingball/init.opy]: Correct fireball, melee damage") {
    event {
        Player Dealt Damage;
        All;
        Wrecking Ball;
    }
    conditions {
        Array Contains(Array(Button(Ability 1), Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[zarya/self_bubble.opy]: showSelfBubbleCD()") {
    event {
        Subroutine;
        showSelfBubbleCD;
    }
    actions {
        If(Compare((Event Player).self_bubble_cd_text, ==, Null));
            Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).self_bubble_cooldown, Up)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(1.99, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.9, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
            Set Player Variable(Event Player, self_bubble_cd_text, Last Text ID);
            Create In-World Text(Event Player, Custom String("{0} {1}", Round To Integer((Event Player).self_bubble_cooldown, Up), Ability Icon String(Hero(Zarya), Button(Ability 1))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(0.2, World Vector Of(Right, Event Player, Rotation)), Multiply(-0.36, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 1.3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
            Set Player Variable(Event Player, zarya_self_bubble_centre_hud, Last Text ID);
        End;
    }
}

rule ("[zarya/self_bubble.opy]: hideSelfBubbleCD()") {
    event {
        Subroutine;
        hideSelfBubbleCD;
    }
    actions {
        Destroy In-World Text((Event Player).self_bubble_cd_text);
        Set Player Variable(Event Player, self_bubble_cd_text, Null);
        Destroy In-World Text((Event Player).zarya_self_bubble_centre_hud);
        Set Player Variable(Event Player, zarya_self_bubble_centre_hud, Null);
    }
}

rule ("[zarya/self_bubble.opy]: OW1 zarya self bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        (Event Player).HeroCoreActive == Null;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 1));
        Set Ability Charge(Event Player, Button(Ability 1), 2);
        "wait bubble duration"
        Wait Until(Not(Is Using Ability 1(Event Player)), 2);
        Set Ability 1 Enabled(Event Player, False);
        Set Player Variable(Event Player, self_bubble_cooldown, 9);
        Allow Button(Event Player, Button(Ability 1));
        Chase Player Variable At Rate(Event Player, self_bubble_cooldown, 0, 1, None);
    }
}

rule ("[zarya/self_bubble.opy]: Disable self bubble if on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).self_bubble_cooldown > 0;
        (Event Player).HeroCoreActive == Null;
    }
    actions {
        Set Ability 1 Enabled(Event Player, False);
        Call Subroutine(showSelfBubbleCD);
    }
}

rule ("[zarya/self_bubble.opy]: Enable self bubble if not on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).hero_setup == Hero(Zarya);
        (Event Player).self_bubble_cooldown <= 0;
        (Event Player).HeroCoreActive == Null;
    }
    actions {
        Set Ability 1 Enabled(Event Player, True);
        Call Subroutine(hideSelfBubbleCD);
    }
}

rule ("[zarya/ally_bubble.opy]: showAllyBubbleCD()") {
    event {
        Subroutine;
        showAllyBubbleCD;
    }
    actions {
        If(Compare((Event Player).ally_bubble_cd_text, ==, Null));
            Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).ally_bubble_cooldown, Up)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(2.3, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.9, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
            Set Player Variable(Event Player, ally_bubble_cd_text, Last Text ID);
            Create In-World Text(Event Player, Custom String("{0} {1}", Round To Integer((Event Player).ally_bubble_cooldown, Up), Ability Icon String(Hero(Zarya), Button(Ability 2))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(0.2, World Vector Of(Right, Event Player, Rotation)), Multiply(-0.48, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 1.3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
            Set Player Variable(Event Player, zarya_ally_bubble_centre_hud, Last Text ID);
        End;
    }
}

rule ("[zarya/ally_bubble.opy]: hideAllyBubbleCD()") {
    event {
        Subroutine;
        hideAllyBubbleCD;
    }
    actions {
        Destroy In-World Text((Event Player).ally_bubble_cd_text);
        Set Player Variable(Event Player, ally_bubble_cd_text, Null);
        Destroy In-World Text((Event Player).zarya_ally_bubble_centre_hud);
        Set Player Variable(Event Player, zarya_ally_bubble_centre_hud, Null);
    }
}

rule ("[zarya/ally_bubble.opy]: OW1 zarya ally bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Ability Charge(Event Player, Button(Ability 2), 2);
        Set Ability 2 Enabled(Event Player, False);
        "waitUntil(not eventPlayer.isUsingAbility2(), ADJ_ZARYA_BUBBLE_DURATION) # wait bubble duration\nwait bubble duration"
        Wait(2, Ignore Condition);
        Set Player Variable(Event Player, ally_bubble_cooldown, 8);
        Chase Player Variable At Rate(Event Player, ally_bubble_cooldown, 0, 1, None);
    }
}

rule ("[zarya/ally_bubble.opy]: Disable ally bubble if on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).ally_bubble_cooldown > 0;
    }
    actions {
        Set Ability 2 Enabled(Event Player, False);
        Call Subroutine(showAllyBubbleCD);
    }
}

rule ("[zarya/ally_bubble.opy]: Enable ally bubble if not on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).ally_bubble_cooldown <= 0;
    }
    actions {
        Set Ability 2 Enabled(Event Player, True);
        Call Subroutine(hideAllyBubbleCD);
    }
}

rule ("[zarya/init.opy]: initZarya()") {
    event {
        Subroutine;
        initZarya;
    }
    actions {
        "eventPlayer.custom_hp_pvar[0] = 200\neventPlayer.custom_hp_pvar[1] = 0\neventPlayer.custom_hp_pvar[2] = 200\napplyCustomHp()"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2100);
        Call Subroutine(removeTankPassive);
        Set Player Variable(Event Player, self_bubble_cooldown, 0);
        Set Player Variable(Event Player, ally_bubble_cooldown, 0);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.895);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, max_health_scaler, 1);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[zarya/init.opy]: Clean up Zarya") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Zarya);
    }
    actions {
        Call Subroutine(hideSelfBubbleCD);
        Call Subroutine(hideAllyBubbleCD);
    }
}

rule ("[zarya/init.opy]: Increase Particle Cannon alternate fire damage") {
    event {
        Player Dealt Damage;
        All;
        Zarya;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.909), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[zarya/init.opy]: Correct Zarya Melee damage") {
    event {
        Player Dealt Damage;
        All;
        Zarya;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[zenyatta/init.opy]: initZenyatta()") {
    event {
        Subroutine;
        initZenyatta;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 33.45);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2200);
        Set Ammo(Event Player, 0, 20);
        Set Max Ammo(Event Player, 0, 20);
        Set Knockback Dealt(Event Player, 4);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("player died") {
    event {
        Player Died;
        All;
        All;
    }
    actions {
        Set Player Variable(Event Player, Hanzo_Marked_icon, Null);
        Destroy In-World Text((Event Player).Hanzo_Marked_effect);
        Set Player Variable(Event Player, Hanzo_Marked_effect, Null);
        If(Compare(Hero Of(Event Player), ==, Hero(Orisa)));
            Set Player Variable(Event Player, Orisa_heat, 0);
            Set Player Variable(Event Player, Orisa_Ammo, 100);
    }
}

<<<<<<<< HEAD:settings.txt
rule ("[sombra/emp.opy]: Heal damage EMP does and prevent extra hack time from triggering") {
    event {
        Player Dealt Damage;
        All;
        Sombra;
    }
    conditions {
        Event Ability == Button(Ultimate);
    }
    actions {
        Heal(Victim, Null, Event Damage);
        Wait(3, Ignore Condition);
        Clear Status(Victim, Hacked);
    }
}

rule ("[mcree/combat_roll.opy]: remove 30% damage reducion from roll") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Modify Player Variable(Event Player, DamageRecieved, Add, 30);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Wait Until(Not(Is Using Ability 1(Event Player)), 3);
        Modify Player Variable(Event Player, DamageRecieved, Subtract, 30);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
    }
}

disabled rule ("[mei/init.opy]: initMei()") {
    event {
        Subroutine;
        initMei;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 250);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1610);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.882);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, max_health_scaler, 1.1);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[echo/ultimate.opy]: Sub for HUD") {
    event {
        Subroutine;
        EchoCopy;
    }
    actions {
        Set Player Variable(Event Player, EchoUltSeconds, 100);
        Chase Player Variable At Rate(Event Player, EchoUltSeconds, 0, 6.25, Destination and Rate);
        Create Progress Bar In-World Text(Event Player, (Event Player).EchoUltSeconds, Custom String("{0} {1}", Ability Icon String(Hero(Echo), Button(Ultimate)), Round To Integer(Divide((Event Player).EchoUltSeconds, 6.25), Up)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(-1, World Vector Of(Right, Event Player, Rotation)), Multiply(-0.25, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 0.75, Do Not Clip, Color(White), Color(White), Visible To Position Values and Color, Default Visibility);
        Set Player Variable(Event Player, EchoHUD, Last Text ID);
    }
}

rule ("[echo/init.opy]: Clean up Echo") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Echo);
    }
    actions {
        Destroy Progress Bar In-World Text((Event Player).EchoHUD);
        Stop Chasing Player Variable(Event Player, EchoUltSeconds);
        Set Player Variable(All Players(Team Of(Event Player)), Echo_Copy, False);
        Set Player Variable(Event Player, EchoHUD, Null);
        Set Player Variable(Event Player, EchoUltSeconds, Null);
    }
}

rule ("[ana/nade.opy]: Increase Biotic Grenade damage") {
    event {
        Player Dealt Damage;
        All;
        Ana;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.8, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[soldier/init.opy]: Increase Heavy Pulse Rifle damage") {
    event {
        Player Dealt Damage;
        All;
        Soldier: 76;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 1.053), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

disabled rule ("Mercy track ult charge that would have been gained from custom abilities") {
    event {
        Player Dealt Healing;
        All;
        Mercy;
    }
    conditions {
        Event Ability != Button(Primary Fire);
        Healee != Event Player;
        Is Game In Progress == True;
        Ultimate Charge Percent(Event Player) < 100;
    }
    actions {
        Modify Player Variable(Event Player, MercyUltTrack, Add, Event Healing);
    }
}

disabled rule ("Mercy ult add") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).MercyUltTrack >= Divide(Value In Array((Event Player).ult_charge_pvar, 1), 100);
    }
    actions {
        Set Ultimate Charge(Event Player, Add(Ultimate Charge Percent(Event Player), Round To Integer(Divide((Event Player).MercyUltTrack, Divide(Value In Array((Event Player).ult_charge_pvar, 1), 100)), Down)));
        Modify Player Variable(Event Player, MercyUltTrack, Subtract, Multiply(Round To Integer(Divide((Event Player).MercyUltTrack, Divide(Value In Array((Event Player).ult_charge_pvar, 1), 100)), Down), Divide(Value In Array((Event Player).ult_charge_pvar, 1), 100)));
        Wait(0.2, Ignore Condition);
    }
}

rule ("Mercy rez HUD") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Ultimate Charge Percent(Event Player) >= 100;
        (Event Player).RezHUD == Null;
    }
    actions {
        Create HUD Text(If-Then-Else(And(Is Alive(Event Player), Compare(Count Of(Remove From Array(Players Within Radius(Event Player, 5.5, Team Of(Event Player), Surfaces), All Living Players(All Teams))), >, 0)), Event Player, Null), Custom String("Resurrect {0}", Hero Icon String(Hero Of(First Of(Sorted Array(Remove From Array(Players Within Radius(Event Player, 5.5, Team Of(Event Player), Surfaces), All Living Players(Team Of(Event Player))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Event Player, Current Array Element))))))), Null, Null, Top, 0, Color(Yellow), Null, Null, Visible To and String, Default Visibility);
        Set Player Variable(Event Player, RezHUD, Last Text ID);
    }
}

rule ("Mercy imbue target icon") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        (Event Player).ImbueTargetIcon == Null;
    }
    actions {
        Create In-World Text(If-Then-Else(And(Compare(First Of(Sorted Array(Filtered Array(Players Within Radius(Event Player, 20.5, Team Of(Event Player), Surfaces And Enemy Barriers), And(And(Is In View Angle(Event Player, Position Of(Current Array Element), Add(2, Divide(60, Distance Between(Event Player, Current Array Element)))), Compare(Current Array Element, !=, Event Player)), Is Alive(Current Array Element))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element))))), !=, Null), Not(Is In Alternate Form(Event Player))), Event Player, Null), Custom String("+"), Add(Eye Position(First Of(Sorted Array(Filtered Array(Players Within Radius(Event Player, 20.5, Team Of(Event Player), Surfaces And Enemy Barriers), And(And(Is In View Angle(Event Player, Position Of(Current Array Element), Add(2.5, Divide(60, Distance Between(Event Player, Current Array Element)))), Compare(Current Array Element, !=, Event Player)), Is Alive(Current Array Element))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element)))))), Vector(0, 1, 0)), 2, Do Not Clip, Visible To Position String and Color, If-Then-Else(Is Firing Secondary(Event Player), Color(Blue), Color(Yellow)), Default Visibility);
        Set Player Variable(Event Player, ImbueTargetIcon, Last Text ID);
    }
}

rule ("Mercy imbue") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Is In Alternate Form(Event Player) == False;
        Is Button Held(Event Player, Button(Ability 2)) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        First Of(Sorted Array(Filtered Array(Remove From Array(Remove From Array(Players Within Radius(Event Player, 20.5, Team Of(Event Player), Surfaces And Enemy Barriers), Event Player), All Dead Players(Team Of(Event Player))), Is In View Angle(Event Player, Position Of(Current Array Element), Add(2.5, Divide(60, Distance Between(Event Player, Current Array Element))))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element))))) != Null;
    }
    actions {
        "Vanilla rez cd hero setting needs to be changed if cooldown is changed so icon matches"
        Set Ability Cooldown(Event Player, Button(Ability 2), 15);
        Set Ability 2 Enabled(Event Player, True);
        Destroy In-World Text((Event Player).ImbueTargetIcon);
        Set Player Variable(Event Player, ImbueTargetIcon, Null);
        Set Player Variable(Event Player, ImbueSecondary, If-Then-Else(Is Firing Secondary(Event Player), True, False));
        "Set target"
        Set Player Variable(Event Player, ImbueTarget, First Of(Sorted Array(Filtered Array(Players Within Radius(Event Player, 20.5, Team Of(Event Player), Surfaces And Enemy Barriers), And(And(Is In View Angle(Event Player, Position Of(Current Array Element), Add(2.5, Divide(60, Distance Between(Event Player, Current Array Element)))), Compare(Current Array Element, !=, Event Player)), Is Alive(Current Array Element))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element))))));
        "Duration"
        Set Player Variable(Event Player, ImbueDuration, 5);
        Chase Player Variable At Rate(Event Player, ImbueDuration, 0, 1, Destination and Rate);
        Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Event Player, 80);
        Create Beam Effect(If-Then-Else(Compare((Event Player).ImbueTarget, !=, Null), All Players(All Teams), Null), Bad Beam, Event Player, (Event Player).ImbueTarget, If-Then-Else(Is Firing Secondary(Event Player), Color(Blue), Color(Yellow)), Visible To Position and Radius);
        Set Player Variable(Event Player, ImbueBeam, Last Created Entity);
        Play Effect(All Players(All Teams), Ring Explosion, If-Then-Else((Event Player).ImbueSecondary, If-Then-Else(Compare(Team Of(Event Player), ==, Team 1), Color(Team 1), Color(Team 2)), Color(Yellow)), (Event Player).ImbueTarget, 8);
        "Destroy beam and sparkle"
        Wait(0.2, Ignore Condition);
        Destroy Effect((Event Player).ImbueBeam);
        "Wait = cooldown - 0.3 (stops vanilla rez being usable the frame cooldown ends); rez cooldown needs to be changed in hero settings if cooldown is changed so icon matches"
        Wait Until(Or(Or(Is Dead(Event Player), Compare(Ability Cooldown(Event Player, Button(Ability 2)), <=, 0.3)), Compare(Hero Of(Event Player), !=, Hero(Mercy))), 14.7);
        Abort If(Compare(Hero Of(Event Player), !=, Hero(Mercy)));
        Set Ability 2 Enabled(Event Player, False);
    }
}

rule ("Mercy imbue AOE") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).ImbueDuration > 0;
        (Event Player).ImbueTarget != Null;
    }
    actions {
        "Aura visuals"
        Create Effect(All Players(If-Then-Else((Event Player).ImbueSecondary, All Teams, Team Of(Event Player))), Ring, If-Then-Else((Event Player).ImbueSecondary, If-Then-Else(Compare(Team Of(Event Player), ==, Team 1), Color(Team 1), Color(Team 2)), Color(Yellow)), (Event Player).ImbueTarget, If-Then-Else((Event Player).ImbueSecondary, 8, 10), Visible To Position and Radius);
        Set Player Variable(Event Player, ImbueAOERing, Last Created Entity);
        If((Event Player).ImbueSecondary);
            Create Effect(All Players(Team Of(Event Player)), Energy Sound, Color(White), (Event Player).ImbueTarget, 80, Visible To Position and Radius);
        Else;
            Create Effect(All Players(Team Of(Event Player)), Sparkles Sound, Color(White), (Event Player).ImbueTarget, 90, Visible To Position and Radius);
        End;
        Set Player Variable(Event Player, ImbueAOESound, Last Created Entity);
        "AoE"
        While(And(Is Alive((Event Player).ImbueTarget), Compare((Event Player).ImbueDuration, >, 0)));
            "20 dps for 3 seconds"
            If((Event Player).ImbueSecondary);
                Start Damage Over Time(Players Within Radius((Event Player).ImbueTarget, 8, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers), Event Player, 0.5, 20);
            Else;
                Heal(Players Within Radius((Event Player).ImbueTarget, 10, Team Of(Event Player), Surfaces And Enemy Barriers), Event Player, 7.5);
            End;
            Wait Until(Or(Is Dead((Event Player).ImbueTarget), Compare((Event Player).ImbueDuration, ==, 0)), 0.5);
        End;
        Destroy Effect((Event Player).ImbueAOERing);
        Destroy Effect((Event Player).ImbueAOESound);
        Stop Chasing Player Variable(Event Player, ImbueDuration);
        Set Player Variable(Event Player, ImbueTarget, Null);
    }
}

rule ("Mercy rez") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Ultimate Charge Percent(Event Player) == 100;
        Is Button Held(Event Player, Button(Ultimate)) == True;
        Is Alive(Event Player) == True;
        Count Of(Remove From Array(Players Within Radius(Event Player, 5.5, Team Of(Event Player), Surfaces), All Living Players(All Teams))) > 0;
    }
    actions {
        Set Player Variable(Event Player, MercyUltTrack, 0);
        Set Ultimate Charge(Event Player, 0);
        Destroy HUD Text((Event Player).RezHUD);
        Set Player Variable(Event Player, RezHUD, Null);
        Communicate(Event Player, Hello);
        "Set rez target"
        Set Player Variable(Event Player, RezTarget, First Of(Sorted Array(Remove From Array(Players Within Radius(Event Player, 5.5, Team Of(Event Player), Surfaces), All Living Players(Team Of(Event Player))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Event Player, Current Array Element)))));
        "Show rez in killfeed (skews mercy's elims and target's deaths by 1, but whatever)"
        Resurrect((Event Player).RezTarget);
        Set Status((Event Player).RezTarget, Null, Phased Out, 0.1);
        Set Player Health((Event Player).RezTarget, 0.01);
        Kill((Event Player).RezTarget, Event Player);
        Wait(0.016, Ignore Condition);
        "Real rez"
        Resurrect((Event Player).RezTarget);
        Set Status((Event Player).RezTarget, Null, Phased Out, 2.25);
        Set Status((Event Player).RezTarget, Null, Frozen, 1.5);
        Set Player Health((Event Player).RezTarget, Max Health((Event Player).RezTarget));
        Play Effect(All Players(All Teams), Good Pickup Effect, Color(Yellow), (Event Player).RezTarget, 5);
        Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), (Event Player).RezTarget, 110);
        "0.75s recovery"
        Disallow Button(Event Player, Button(Primary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Disallow Button(Event Player, Button(Melee));
        Disallow Button(Event Player, Button(Ability 2));
        "Disable target abilities for 0.75s movement window in invuln"
        Disallow Button((Event Player).RezTarget, Button(Ability 1));
        Disallow Button((Event Player).RezTarget, Button(Ability 2));
        Disallow Button((Event Player).RezTarget, Button(Primary Fire));
        Disallow Button((Event Player).RezTarget, Button(Secondary Fire));
        Disallow Button((Event Player).RezTarget, Button(Ultimate));
        Disallow Button((Event Player).RezTarget, Button(Melee));
        "End recovery"
        Wait(0.5, Ignore Condition);
        Allow Button(Event Player, Button(Primary Fire));
        Allow Button(Event Player, Button(Secondary Fire));
        Allow Button(Event Player, Button(Melee));
        Allow Button(Event Player, Button(Ability 2));
        "End of target invuln, enable abilities"
        Wait(1.75, Ignore Condition);
        Allow Button((Event Player).RezTarget, Button(Ability 1));
        Allow Button((Event Player).RezTarget, Button(Ability 2));
        Allow Button((Event Player).RezTarget, Button(Primary Fire));
        Allow Button((Event Player).RezTarget, Button(Secondary Fire));
        Allow Button((Event Player).RezTarget, Button(Ultimate));
        Allow Button((Event Player).RezTarget, Button(Melee));
        Set Player Variable(Event Player, RezTarget, Null);
    }
}

rule ("Mercy swap hero") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) != Hero(Mercy);
        Has Spawned(Event Player) == True;
    }
    actions {
        Allow Button(Event Player, Button(Ultimate));
        Destroy HUD Text((Event Player).RezHUD);
        Destroy In-World Text((Event Player).ImbueTargetIcon);
        Set Player Variable(Event Player, MercyUltTrack, 0);
        Destroy Effect((Event Player).ImbueAOERing);
        Destroy Effect((Event Player).ImbueAOESound);
        Destroy Effect((Event Player).ImbueBeam);
        Destroy Effect((Event Player).ImbueSparkle);
        Set Player Variable(Event Player, ImbueTargetIcon, Null);
        Set Player Variable(Event Player, RezHUD, Null);
        Set Player Variable(Event Player, ImbueTarget, Null);
    }
}

rule ("Overrun logic") {
    event {
        Ongoing - Each Player;
        All;
        Mauga;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Stop Chasing Player Variable(Event Player, MaugaOverHP);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 15);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait(0.32, Ignore Condition);
        Wait Until(Or(Or(Not(Is Using Ability 1(Event Player)), Is Button Held(Event Player, Button(Primary Fire))), Is Button Held(Event Player, Button(Jump))), 99999);
        Modify Player Variable(Event Player, MoveSpeed, Add, 15);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        If(Or(Is Button Held(Event Player, Button(Primary Fire)), Is Button Held(Event Player, Button(Jump))));
            Wait Until(Not(Is Using Ability 1(Event Player)), 2.6);
            Set Ability Cooldown(Event Player, Button(Ability 1), 6);
    }
}

rule ("Overrun subtract damage taken") {
    event {
        Player Took Damage;
        All;
        Mauga;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Modify Player Variable(Event Player, MaugaOverHP, Subtract, Multiply(Event Damage, 2));
        If(Is Using Ability 2(Event Player));
            Modify Player Variable(Event Player, MaugaOverHP, Subtract, Multiply(Event Damage, 1.4));
    }
}

rule ("Overrun break shield") {
    event {
        Ongoing - Each Player;
        All;
        Mauga;
    }
    conditions {
        (Event Player).MaugaOverHP <= 0;
    }
    actions {
        If(Is Using Ability 1(Event Player));
            Press Button(Event Player, Button(Ability 1));
        End;
        Set Status(Event Player, Null, Stunned, 0.2);
        Wait(0.5, Ignore Condition);
        Set Ability 1 Enabled(Event Player, False);
        Set Ability Cooldown(Event Player, Button(Ability 1), 8);
        Set Player Variable(Event Player, MaugaOverHP, 0);
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Ability 1)), ==, 0), 8);
        Set Ability 1 Enabled(Event Player, True);
    }
}

rule ("Overrun recharge shield") {
    event {
        Ongoing - Each Player;
        All;
        Mauga;
    }
    conditions {
        (Event Player).MaugaOverHP != 200;
        Is Using Ability 1(Event Player) == False;
    }
    actions {
        If(Not(Is Using Ability 1(Event Player)));
            Wait(2, Abort When False);
            Chase Player Variable At Rate(Event Player, MaugaOverHP, 200, 50, Destination and Rate);
    }
}

rule ("Overrun check for stomp") {
    event {
        Ongoing - Each Player;
        All;
        Mauga;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait(3, Abort When False);
        Wait Until(Not(Is Using Ability 1(Event Player)), 1);
        Set Ability Cooldown(Event Player, Button(Ability 1), 6);
    }
}

rule ("[sombra/translocator.opy] Sombra stealth self cancel") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        (Event Player).stealth_timer <= 5;
        (Event Player).stealth_timer > 0;
        Is Button Held(Event Player, Button(Ability 2)) == True;
        (Event Player).Sombra_invisible == True;
    }
    actions {
        Set Status(Event Player, Null, Rooted, 0.001);
        Set Player Variable(Event Player, Sombra_invisible, False);
        "printLog(\"Current Translocator Cooldown: {0} | Target Translocator Cooldown: {1}\".format(eventPlayer.getAbilityCooldown(Button.ABILITY_2), eventPlayer._stealth_max_cooldown - 5 + (eventPlayer.stealth_timer * (1 - STEALTH_REFUND_FRACTION))))"
        Set Ability Cooldown(Event Player, Button(Ability 2), Add(Subtract(First Of((Event Player).stealth_pvar), 5), Multiply((Event Player).stealth_timer, Subtract(1, Global.STEALTH_REFUND_FRACTION))));
        Set Player Variable(Event Player, stealth_timer, 0);
    }
}

rule ("destroy all huds and effects between rounds") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Between Rounds == True;
    }
    actions {
        Destroy All Progress Bar In-World Text;
        Destroy All In-World Text;
        Destroy All Effects;
        Destroy All Progress Bar HUD Text;
        Destroy All HUD Text;
    }
}

rule ("Doomfist punch track") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, DoomPunchTrack, False);
        Wait Until(Or(Not(Is Button Held(Event Player, Button(Secondary Fire))), Not(Is Firing Secondary(Event Player))), 1.6);
        Set Player Variable(Event Player, DoomPunchTrack, True);
    }
}

rule ("Reinhardt charge track") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, ReinChargeTrack, True);
        Wait Until(Not(Is Using Ability 1(Event Player)), 5);
        Set Player Variable(Event Player, ReinChargeTrack, False);
    }
}

rule ("Mauga overrun knockdown") {
    event {
        Player Dealt Damage;
        All;
        Mauga;
    }
    conditions {
        Event Ability == Button(Ability 1);
        Or(Or(And(Compare(Hero Of(Victim), ==, Hero(Reinhardt)), (Victim).ReinChargeTrack), And(And(Compare(Hero Of(Victim), ==, Hero(Doomfist)), Is Firing Secondary(Victim)), (Victim).DoomPunchTrack)), And(And(Compare(Hero Of(Victim), ==, Hero(Brigitte)), Is Firing Secondary(Victim)), Is Firing Primary(Victim))) == True;
        Absolute Value(Angle Difference(Horizontal Facing Angle Of(Event Player), Multiply(Horizontal Facing Angle Of(Victim), -1))) <= 90;
    }
    actions {
        Cancel Primary Action(Event Player);
        Set Status(Event Player, Victim, Knocked Down, 1.7);
        Set Status(Victim, Event Player, Knocked Down, 1.7);
        Wait(0.09, Ignore Condition);
        Apply Impulse(Victim, Multiply(Velocity Of(Victim), -1), 0.001, To World, Cancel Contrary Motion);
    }
}

rule ("[orisa/init.opy]: Correct Orisa Spin, Melee damage") {
    event {
        Player Dealt Damage;
        All;
        Orisa;
    }
    conditions {
        Array Contains(Array(Button(Ability 1), Button(Ability 2), Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[orisa/init.opy]: Correct Orisa Javelin damage") {
    event {
        Player Dealt Damage;
        All;
        Orisa;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.929, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[status/hud.opy]: Display buffs from Roadhog and Sombra") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Or((Event Player).Roadhog_vape_hud_icon, (Event Player).Sombra_hack_icon) == True;
    }
    actions {
        Create HUD Text(Event Player, Null, Null, Custom String(" \r\n\r\n\r\n\r"), Left, 1, Null, Null, Color(White), Visible To and String, Visible Never);
        Set Player Variable(Event Player, Status_Effect_Spectator_HUD, Last Text ID);
        Create HUD Text(Event Player, Null, Null, Custom String(" \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                                                           {0} {1}", If-Then-Else(Compare((Event Player).Roadhog_vape_hud_icon, ==, True), Ability Icon String(Hero(Roadhog), Button(Secondary Fire)), Custom String(" ")), If-Then-Else(Compare((Event Player).Sombra_hack_icon, ==, True), Ability Icon String(Hero(Sombra), Button(Ultimate)), Custom String(" "))), Left, 2, Null, Null, Color(White), Visible To and String, Default Visibility);
        Set Player Variable(Event Player, Status_effect_hud, Last Text ID);
        Wait(5, Ignore Condition);
        Destroy HUD Text((Event Player).Status_effect_hud);
        Destroy HUD Text((Event Player).Status_Effect_Spectator_HUD);
    }
}

rule ("[ana/sleep.opy]: Cleanse the sleep on tanks on damage") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        Has Status(Event Player, Knocked Down) == True;
        (Event Player).Ana_Sleepdart_Target == True;
    }
    actions {
        If(Compare(Ability Cooldown(Players On Hero(Hero(Ana), Opposite Team Of(Team Of(Event Player))), Button(Ability 1)), !=, 0));
            Clear Status(Event Player, Knocked Down);
            Set Player Variable(Event Player, Ana_Sleepdart_Target, Null);
    }
}

rule ("[lifeweaver/healing.opy]: Lifeweaver Healing cooldown") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).Lifeweaver_healing_cd == True;
    }
    actions {
        Wait(4, Abort When False);
        Set Player Variable(Event Player, Lifeweaver_healing_cd, Null);
    }
}

rule ("[juno/init.opy]: Correct Pulsar Torpedo healing over time") {
    event {
        Player Dealt Healing;
        All;
        Juno;
    }
    conditions {
        Event Healing > 69;
    }
    actions {
        Start Damage Over Time(Healee, Null, 2.4, 10);
    }
}

rule ("[mei/init.opy]: Initialize Mei TANK") {
    event {
        Subroutine;
        initMei;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 400);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2800);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.66);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Start Scaling Player(Event Player, 1.15, True);
        Set Player Variable(Event Player, hero_initialized, True);
        Set Player Variable(Event Player, max_health_scaler, 1.1);
    }
}

rule ("[mei/init.opy]: Reduce Headshot damage taken Mei") {
    event {
        Player Took Damage;
        All;
        Mei;
    }
    conditions {
        Event Was Critical Hit == True;
    }
    actions {
        Heal(Event Player, Null, Multiply(Event Damage, 0.3));
    }
}

rule ("[mei/endothermic.opy]: AOE Damage Mei") {
    event {
        Player Dealt Damage;
        All;
        Mei;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Play Effect(All Players(All Teams), Bad Explosion, Color(Sky Blue), Victim, 2);
        Play Effect(All Players(All Teams), Ring Explosion, Color(Aqua), Victim, 5);
        Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Sky Blue), Event Player, 40);
        Damage(Players Within Radius(Victim, 5, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers), Attacker, 25);
    }
}

rule ("[junkerqueen/init.opy]: Shout indicator") {
    event {
        Ongoing - Each Player;
        All;
        Junker Queen;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Between Rounds == False;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0} {1}", Count Of(Filtered Array(All Living Players(Team Of(Event Player)), And(And(Compare(Distance Between(Event Player, Current Array Element), <=, 15), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS)), Compare(Hero Of(Current Array Element), !=, Hero(Junker Queen))))), Ability Icon String(Hero(Junker Queen), Button(Ability 1))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(-0.5, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 2, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, JQ_Shout_Hud, Last Text ID);
        Wait Until(Is Using Ability 1(Event Player), 99999);
        Destroy In-World Text((Event Player).JQ_Shout_Hud);
        Set Player Variable(Event Player, JQ_Shout_Hud, Null);
    }
}

rule ("[junkerqueen/init.opy]: Clean up JQ") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Junker Queen);
    }
    actions {
        Destroy In-World Text((Event Player).JQ_Shout_Hud);
    }
}

rule ("hazard reveal enemies") {
    event {
        Player Dealt Damage;
        All;
        Hazard;
    }
    conditions {
        Has Status(Victim, Rooted) == True;
        Event Ability == Button(Ultimate);
        (Victim).Hazard_Downpour_Target == Null;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0} {1}m", Ability Icon String(Hero(Hazard), Button(Ultimate)), Round To Integer(Distance Between(Event Player, Victim), Up)), Add(Victim, Vector(0, 2.5, 0)), 1.5, Do Not Clip, Visible To Position and String, Color(White), Default Visibility);
        Set Player Variable(Victim, Hazard_Downpour_effect, Last Text ID);
        Set Player Variable(Victim, Hazard_Downpour_Target, True);
    }
}

rule ("hazard reset reveal enemies") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).Hazard_Downpour_Target == True;
    }
    actions {
        Wait(2.5, Ignore Condition);
        Destroy In-World Text((Event Player).Hazard_Downpour_effect);
        Set Player Variable(Event Player, Hazard_Downpour_Target, Null);
        Set Player Variable(Event Player, Hazard_Downpour_effect, Null);
    }
}

disabled rule ("[freja/init.opy]: initFreja()") {
    event {
        Subroutine;
        initFreja;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1900);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.667);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Start Scaling Player(Event Player, 0.96, True);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

disabled rule ("[freja/init.opy]: Correct Freja other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

disabled rule ("[freja/init.opy]: Correct Freja secondary impact damage") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
        Wait(3, Ignore Condition);
    }
}

rule ("[mccree/fanthehammer.opy]: Increase Fan the hammer damage to 40") {
    event {
        Player Dealt Damage;
        All;
        Cassidy;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.8, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[ashe/dynamite.opy]: Decreased dynamite damage by healing until timeout or cleansed = 85 damage") {
    event {
        Player Dealt Damage;
        All;
        Ashe;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Start Heal Over Time(Victim, Null, 5, 2);
        Set Player Variable(Victim, Ashe_Dynamite_Healing_ID, Last Healing Modification ID);
        Wait Until(Has Status(Victim, Phased Out), 5);
        Stop Heal Over Time((Victim).Ashe_Dynamite_Healing_ID);
        Set Player Variable(Victim, Ashe_Dynamite_Healing_ID, Null);
    }
}
========
>>>>>>>> origin/health_pool_update:workshop_code.txt
