settings
{
	main
	{
		Mode Name: "6v6 Adjustments + Realth 1.15.9"
	}
	lobby
	{
		Map Rotation: After A Game
		Max Spectators: 12
		Max Team 1 Players: 6
		Max Team 2 Players: 6
		Pause Game On Player Disconnect: Yes
		Return To Lobby: After A Game
	}
	modes
	{
		Assault
		{
			enabled maps
			{
			}
			Capture Speed Modifier: 120%
			Competitive Rules: On
			Enable Perks: Off
		}
		disabled Clash
		{
			Capture Speed Modifier: 45%
		}
		Control
		{
			enabled maps
			{
				Lijiang Tower
			}
			Competitive Rules: On
			Enable Perks: Off
		}
		Escort
		{
			enabled maps
			{
			}
			Competitive Rules: On
			Enable Perks: Off
		}
		Flashpoint
		{
			enabled maps
			{
			}
			Competitive Rules: On
			Enable Perks: Off
			Scoring Speed Modifier: 85%
		}
		Hybrid
		{
			enabled maps
			{
			}
			Competitive Rules: On
			Enable Perks: Off
		}
		Push
		{
			enabled maps
			{
			}
			Competitive Rules: On
			Enable Perks: Off
			TS-1 Push Speed Modifier: 100%
		}
		General
		{
			Game Mode Start: Immediately
			Random Hero Role Limit Per Team: 2
			Spawn Health Packs: Enabled
			Tank Role Passive Health Bonus: Disabled
            Team Overlay: Enabled
		}
	}
	heroes
	{
		General
		{
			Passive Health Regeneration: Off
			Ana
			{
				Ammunition Clip Size Scalar: 80%
				Biotic Grenade Cooldown Time: 86%
				Sleep Dart Cooldown Time: 86%
				Ultimate Generation Nano Boost: 100%
			}
			Ashe
			{
				Health: 80%
				Ultimate Generation B.O.B.: 109%
			}
			Baptiste
			{
				Health: 80%
				Ultimate Generation Amplification Matrix: 105%
			}
			Bastion
			{
				Reconfigure Cooldown Time: 100%
				Ultimate Generation Configuration: Artillery: 96%
			}
			Brigitte
			{
				Health: 100%
				Repair Pack Cooldown Time: 100%
				Ultimate Generation Rally: 103%
			}
			Cassidy
			{
				Ultimate Generation Deadeye: 107%
			}
			D.Va
			{
				Defense Matrix Maximum Time: 67%
				Defense Matrix Recharge Rate: 90%
				Health: 86%
				Ultimate Generation Self-Destruct: 110%
			}
			Doomfist
			{
				Health: 63%
				Power Block Cooldown Time: 114%
				Seismic Slam Cooldown Time: 100%
				Ultimate Generation Meteor Strike: 113%
			}
			Echo
			{
				Focusing Beam Cooldown Time: 125%
				Ultimate Generation Duplicate: 98%
			}
			Genji
			{
				Ultimate Duration: 50%
				Ultimate Generation Dragonblade: 145%
			}
			Hanzo
			{
				Storm Arrows Cooldown Time: 125%
				Storm Arrows Quantity: 5
				Ultimate Generation Dragonstrike: 110%
			}
			Illari
			{
				Ammunition Clip Size Scalar: 85%
				Healing Pylon Cooldown Time: 114%
				Health: 80%
				Solar Energy Maximum: 86%
				Ultimate Generation Captive Sun: 121%
			}
			Junker Queen
			{
				Carnage Cooldown Time: 88%
				Commanding Shout Cooldown Time: 108%
				Health: 71%
				Ultimate Generation Rampage: 117%
			}
			Junkrat
			{
				Concussion Mine Cooldown Time: 100%
				Ultimate Generation RIP-Tire: 109%
			}
			Juno
			{
				Glide Boost Cooldown Time: 133%
				Hyper Ring Cooldown Time: 136%
				Pulsar Torpedoes Cooldown Time: 100%
				Ultimate Generation Orbital Ray: 110%
			}
			Kiriko
			{
				Protection Suzu Cooldown Time: 93%
				Swift Step Cooldown Time: 100%
				Ultimate Generation Kitsune Rush: 105%
			}
			Lifeweaver
			{
				Ammunition Clip Size Scalar: 80%
				Petal Platform Cooldown Time: 100%
				Petal Platform Health: 83%
				Rejuvenating Dash Cooldown Time: 0%
				Rejuvenating Dash Healing: 45%
				Tree of Life Health: 75%
				Ultimate Generation Tree of Life: 110%
			}
			Lúcio
			{
				Soundwave Cooldown Time: 105%
				Soundwave Knockback Scalar: 100%
				Ultimate Generation Sound Barrier: 90%
			}
			Mauga
			{
				Ammunition Clip Size Scalar: 100%
				Cardiac Overdrive Cooldown Time: 84%
				Cardiac Overdrive Healing: 0%
				Health: 125%
				Incendiary Chaingun Ignite Damage: 223%
				Incendiary Chaingun Ignite Duration: 75%
				Overrun Cooldown Time: 40%
				Ultimate Generation Cage Fight: 108%
			}
			Mei
			{
				Cryo-Freeze Cooldown Time: 50%
				Health: 110%
				Ultimate Generation Blizzard: 120%
				Weapon Freeze Rate Scalar: 130%
			}
			Mercy
			{
				Guardian Angel Cooldown Time: 73%
				Resurrect Cooldown Time: 50%
				Sympathetic Recovery: Off
				Ultimate Generation Valkyrie: 111%
			}
			Moira
			{
				Ultimate Generation Coalescence: 104%
			}
			Orisa
			{
				Energy Javelin Cooldown Time: 117%
				Fortify Cooldown Time: 79%
				Javelin Spin Cooldown Time: 75%
				Ultimate Generation Terra Surge: 119%
			}
			Pharah
			{
				Ultimate Generation Barrage: 105%
			}
			Ramattra
			{
				Health: 63%
				Nemesis Form Cooldown Time: 100%
				Ravenous Vortex Cooldown Time: 82%
				Ultimate Duration: 100%
				Ultimate Generation Annihilation: 114%
				Void Barrier Omnic Form Cooldown Time: 81%
			}
			Reaper
			{
				Shadow Step Cooldown Time: 80%
				Ultimate Generation Death Blossom: 98%
			}
			Reinhardt
			{
				Barrier Field Recharge Rate: 88%
				Charge Cooldown Time: 143%
				Health: 107%
				Ultimate Generation Earthshatter: 123%
			}
			Roadhog
			{
				Chain Hook Cooldown Time: 117%
				Pig Pen Cooldown Time: 75%
				Take a Breather Cooldown Time: 480%
				Take a Breather Maximum Time: 89%
				Take a Breather Recharge Rate: 500%
				Ultimate Generation Whole Hog: 110%
			}
			Sigma
			{
				Experimental Barrier Recharge Rate: 94%
				Kinetic Grasp Cooldown Time: 108%
				Ultimate Generation Gravitic Flux: 101%
			}
			Sojourn
			{
				Power Slide Cooldown Time: 75%
				Ultimate Generation Overclock: 110%
			}
			Soldier: 76
			{
				Ultimate Generation Tactical Visor: 119%
			}
			Sombra
			{
				Hack Cooldown Time: 134%
				Translocator Cooldown Time: 100%
				Ultimate Generation EMP: 62%
				Virus Cooldown Time: 100%
			}
			Symmetra
			{
				Health: 75%
				Ultimate Generation Photon Barrier: 121%
			}
			Torbjörn
			{
				Health: 89%
				Ultimate Generation Molten Core: 110%
			}
			Tracer
			{
				Health: 86%
				Recall Cooldown Time: 103%
				Ultimate Generation Pulse Bomb: 110%
			}
			Venture
			{
				Burrow Duration Scalar: 50%
				Ultimate Generation Tectonic Shock: 137%
			}
			Widowmaker
			{
				Ultimate Generation Infra-Sight: 101%
				Venom Mine Cooldown Time: 80%
			}
			Winston
			{
				Health: 92%
				Jump Pack Cooldown Time: 120%
				Ultimate Generation Primal Rage: 138%
			}
			Wrecking Ball
			{
				Grappling Claw Knockback Scalar: 85%
				Health: 50%
				Piledriver Cooldown Time: 125%
				Ultimate Generation Minefield: 120%
			}
			Zarya
			{
				Particle Barrier Cooldown Time: 109%
				Ultimate Generation Graviton Surge: 119%
			}
			Zenyatta
			{
				Ultimate Generation Transcendence: 104%
			}
			disabled heroes
			{
				Freja
			}
		}
	}
	workshop
	{
		Activation Hold Time: 5.5
		Calculate DPS over seconds: 10
		Damage Role Cap: 2
		debug mode: Off
		Support Role Cap: 2
		Tank Role Cap: 2
	}
}
variables {
    global:
        0: ADJ_TANK_ULT_NEGATION_PERCENT
        1: DEBUG_MODE
        3: enable_regeneration
        4: ADJ_REGEN_HPS
        5: ADJ_REGEN_TIMER
        6: ANTI_CRASH_ACTIVATE_PERCENT
        7: ANTI_CRASH_HOLD_TIME
        8: ANTI_CRASH_DEACTIVATE_PERCENT
        9: AllTankHeroes
        10: AllDpsHeroes
        11: AllSupportHeroes
        12: AllRoles
        13: NEGATIVE_STATUS_PREVENTS_REFUND
        14: STEALTH_REFUND_FRACTION
        15: MINIMUM_TRANSLOCATOR_COOLDOWN
        16: dpsTime
        17: bot
    player:
        0: within_shout_radius
        1: hero_setup
        2: hero_switch_pvar
        3: overhealth_check
        4: balance_change_check
        5: macro_pvar
        6: DamageRecieved
        7: MoveSpeed
        8: max_health_scaler
        9: Status_effect_hud
        10: zarya_self_bubble_centre_hud
        11: zarya_ally_bubble_centre_hud
        12: Ana_Sleepdart_Target
        13: HeroCoreActive
        14: regen_passive_id
        15: self_heal_pvar
        16: custom_hp_pvar
        17: baptiste_balance_change_check
        18: Baptiste_hud
        19: sentry_healing_id
        20: bash_cooldown
        21: punched_victims
        22: wall_impacted_victims
        23: self_destruct_charge
        24: ult_charge_pvar
        25: orbital_ray_x
        26: orbital_ray_z
        27: orbital_ray_final_x
        28: orbital_ray_final_z
        29: hero_initialized
        30: terra_overhealth_id
        31: remainingAntiDuration
        32: hp_exiting_grasp
        33: overload_overhealth
        34: primal_pvar
        35: adaptive_overhealth_id
        36: self_bubble_cd_text
        37: self_bubble_cooldown
        38: ally_bubble_cd_text
        39: ally_bubble_cooldown
        40: AllowedHeroes
        41: Roadhog_vape_target
        42: Roadhog_targeting_hud
        43: Roadhog_vape_confirmed
        44: Roadhog_vape_effect
        45: Roadhog_vape_hud_icon
        46: Explaination_Hud
        47: JQ_Shout_Hud
        48: Cardiac_overdrive_active
        49: Hazard_Downpour_effect
        50: Mauga_Overdrive_Health
        51: Hazard_Downpour_Target
        52: Ashe_Dynamite_Healing_ID
        53: Status_Effect_Spectator_HUD
        55: Lifeweaver_petal_charges
        56: Lifeweaver_petal_hud
        57: Lifeweaver_dash_charges
        58: Lifeweaver_dash_hud
        59: Lifeweaver_healing_hud
        60: Lifeweaver_healing_cd
        61: Lifeweaver_petal_centre_hud
        62: Lifeweaver_leap_centre_target
        64: Orisa_ring_effect
        65: is_firing_excavator
        66: clobber_cooldown_accelerator
        67: Sombra_invisible
        68: Sombra_hud
        69: Sombra_virus_target
        70: Sombra_targeting_hud
        71: Sombra_virus_confirmed
        72: Sombra_hack_effect
        73: Sombra_hack_icon
        74: Sombra_healing_ring
        75: stealth_timer
        76: Sombra_invis_damage
        77: stealth_pvar
        78: WidowScopeGlint_effect
        79: Bastion_healing_meter
        80: BastionHealingSpamProtection
        81: Bastion_healing_id
        82: Bastion_healing_effect
        83: Bastion_healing_sound
        84: Bastion_healing_meter_hud
        85: HanzoDrawAura
        86: damage
        87: time
        88: textID
        89: position
        90: Echo_Copy
        91: EchoHUD
        92: ImbueBeam
        93: ImbueTarget
        94: ImbueDuration
        95: MaugaOverHP
        97: ImbueAOERing
        98: MaugaShieldBarHUD
        99: RezHUD
        100: ImbueSparkle
        101: ImbueAOESound
        102: MercyUltTrack
        103: RezTarget
        105: ImbueTargetIcon
        106: EchoUltSeconds
        107: MaugaShieldNumberHUD
        108: DoomPunchTrack
        109: ReinChargeTrack
        110: ImbueSecondary
}
subroutines {
    0: resetHero
    1: resetStats
    2: resetStatuses
    3: disableAllAbilities
    4: enableAllAbilities
    5: clearCustomHp
    6: applyCustomHp
    7: resetUltCharge
    8: initHero
    9: removeTankPassive
    10: initAna
    11: initAshe
    12: initBaptiste
    13: initBastion
    14: initBrigitte
    15: initDoomfist
    16: initDva
    17: initEcho
    18: initGenji
    19: initHanzo
    20: initIllari
    21: initJunkerQueen
    22: initJunkrat
    23: initJuno
    24: initKiriko
    25: initLucio
    26: initMccree
    27: initMercy
    28: initMoira
    29: initPharah
    30: initRamattra
    31: initReaper
    32: initReinhardt
    33: initRoadhog
    34: initSigma
    35: initSojourn
    36: initSoldier
    37: initTorbjorn
    38: initTracer
    39: initWidowmaker
    40: initWinston
    41: initWreckingBall
    42: showSelfBubbleCD
    43: hideSelfBubbleCD
    44: showAllyBubbleCD
    45: hideAllyBubbleCD
    46: initZarya
    47: initZenyatta
    48: initMauga
    49: initLifeweaver
    50: initOrisa
    51: initVenture
    52: initMei
    53: initSombra
    54: initSymmetra
    55: initHazard
    56: EchoCopy
    57: initFreja
}
rule ("Initialize global variables") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable(ADJ_TANK_ULT_NEGATION_PERCENT, Workshop Setting Integer(Custom String("Passive"), Custom String("Tank - Ultimate Charge Negation Percent"), 15, 0, NaN, 0));
    }
}

rule ("[utilities/custom_hp.opy]: clearCustomHp()") {
    event {
        Subroutine;
        clearCustomHp;
    }
    actions {
        Remove All Health Pools From Player(Event Player);
        Wait(0.016, Ignore Condition);
        "DO NOT REMOVE THIS LINE"
        Set Max Health(Event Player, 99.999);
        "DO NOT REMOVE THIS LINE"
        Wait(0.016, Ignore Condition);
        Set Max Health(Event Player, 100);
    }
}

rule ("[utilities/custom_hp.opy]: applyCustomHp()") {
    event {
        Subroutine;
        applyCustomHp;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 3, 0);
        "loop MAX_HP_ITER_COUNT times if hp is incorrect"
        While(And(Or(Or(Compare(Absolute Value(Subtract(Max Health Of Type(Event Player, Health), First Of((Event Player).custom_hp_pvar))), >, 0.01), Compare(Absolute Value(Subtract(Max Health Of Type(Event Player, Armor), Value In Array((Event Player).custom_hp_pvar, 1))), >, 0.01)), Compare(Absolute Value(Subtract(Max Health Of Type(Event Player, Shields), Value In Array((Event Player).custom_hp_pvar, 2))), >, 0.01)), Compare(Value In Array((Event Player).custom_hp_pvar, 3), <, 10)));
            Set Healing Received(Event Player, 0);
            Set Player Health(Event Player, 1);
            Add Health Pool To Player(Event Player, Health, 1, True, True);
            Add Health Pool To Player(Event Player, Armor, 1, True, True);
            Add Health Pool To Player(Event Player, Shields, 1, True, True);
            Set Status(Event Player, Null, Invincible, 999999986991104);
            Remove All Health Pools From Player(Event Player);
            "wait(0.064)"
            Wait(0.016, Ignore Condition);
            Wait Until(Compare(Max Health(Event Player), <=, 1), 1);
            "Apply custom health pool to player"
            If(Compare(First Of((Event Player).custom_hp_pvar), >, 0));
                Add Health Pool To Player(Event Player, Health, Max(1, Subtract(First Of((Event Player).custom_hp_pvar), 1)), True, True);
            End;
            If(Compare(Value In Array((Event Player).custom_hp_pvar, 1), >, 0));
                Add Health Pool To Player(Event Player, Armor, Max(1, Value In Array((Event Player).custom_hp_pvar, 1)), True, True);
            End;
            If(Compare(Value In Array((Event Player).custom_hp_pvar, 2), >, 0));
                Add Health Pool To Player(Event Player, Shields, Max(1, Value In Array((Event Player).custom_hp_pvar, 2)), True, True);
            End;
            Set Healing Received(Event Player, 100);
            Heal(Event Player, Null, 999999986991104);
            Clear Status(Event Player, Invincible);
            Wait(0.016, Ignore Condition);
            Modify Player Variable At Index(Event Player, custom_hp_pvar, 3, Add, 1);
        End;
    }
}

rule ("[passives/tank/ult_charge.opy]: resetUltCharge()") {
    event {
        Subroutine;
        resetUltCharge;
    }
    actions {
        Set Player Variable At Index(Event Player, ult_charge_pvar, 0, 0);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 0);
        Wait Until(Compare(Ultimate Charge Percent(Event Player), >, 0), 1);
        Set Ultimate Charge(Event Player, 0);
    }
}

rule ("[passives/tank/ult_charge.opy]: Remember missing ult charge from damaging tank") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Array Contains(All Tank Heroes, Hero Of(Victim)) == True;
        Is Using Ultimate(Event Player) == False;
        Victim != Event Player;
    }
    actions {
        Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Add, Multiply(Divide(Subtract(40, Global.ADJ_TANK_ULT_NEGATION_PERCENT), 100), Event Damage));
    }
}

disabled rule ("[passives/tank/ult_charge.opy]: Remember missing ult charge from healing tank") {
    event {
        Player Dealt Healing;
        All;
        All;
    }
    conditions {
        Array Contains(All Tank Heroes, Hero Of(Healee)) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Add, Multiply(Divide(Subtract(40, Global.ADJ_TANK_ULT_NEGATION_PERCENT), 100), Event Healing));
    }
}

rule ("[passives/tank/ult_charge.opy]: Compensate missing ultimate percentage") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Event Player).ult_charge_pvar) > Multiply(0.01, Value In Array((Event Player).ult_charge_pvar, 1));
        "guard to protect ult resetting accidentally"
        Value In Array((Event Player).ult_charge_pvar, 1) > 0;
    }
    actions {
        Set Player Variable At Index(Event Player, ult_charge_pvar, 2, Round To Integer(Multiply(100, Divide(Add(Multiply(Divide(Ultimate Charge Percent(Event Player), 100), Value In Array((Event Player).ult_charge_pvar, 1)), First Of((Event Player).ult_charge_pvar)), Value In Array((Event Player).ult_charge_pvar, 1))), Up));
        Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Subtract, Subtract(Multiply(Divide(Value In Array((Event Player).ult_charge_pvar, 2), 100), Value In Array((Event Player).ult_charge_pvar, 1)), Multiply(Divide(Ultimate Charge Percent(Event Player), 100), Value In Array((Event Player).ult_charge_pvar, 1))));
        Set Ultimate Charge(Event Player, Value In Array((Event Player).ult_charge_pvar, 2));
    }
}

rule ("[passives/tank/ult_charge.opy]: Reset ult compensation after using ult") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, ult_charge_pvar, 0, 0);
    }
}

rule ("[passives/tank/ult_charge.opy]: Remember missing ult charge from healing tank (+ workshop healing ultcharge)") {
    event {
        Player Dealt Healing;
        All;
        All;
    }
    conditions {
        "@Condition healee.getHero() in getTankHeroes() == true"
        Or(Or(Or(Or(Array Contains(All Tank Heroes, Hero Of(Healee)), And(Compare(Hero Of(Event Player), ==, Hero(Sombra)), Not(Event Was Health Pack))), And(Compare(Hero Of(Event Player), ==, Hero(Mercy)), Compare(Event Ability, !=, Button(Primary Fire)))), And(Compare(Healee, !=, Event Player), Compare(Hero Of(Event Player), ==, Hero(Roadhog)))), Compare(Hero Of(Event Player), ==, Hero(Mauga))) == True;
        Is Using Ultimate(Event Player) == False;
        Ultimate Charge Percent(Event Player) < 100;
    }
    actions {
        If(Or(And(Compare(Hero Of(Event Player), ==, Hero(Sombra)), Not(Event Was Health Pack)), Or(Or(And(Compare(Hero Of(Event Player), ==, Hero(Mercy)), Compare(Event Ability, !=, Button(Primary Fire))), And(Compare(Healee, !=, Event Player), Compare(Hero Of(Event Player), ==, Hero(Roadhog)))), Compare(Hero Of(Event Player), ==, Hero(Mauga)))));
            Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Add, Event Healing);
        Else If(Array Contains(All Tank Heroes, Hero Of(Healee)));
            Modify Player Variable At Index(Event Player, ult_charge_pvar, 0, Add, Multiply(Divide(Subtract(40, Global.ADJ_TANK_ULT_NEGATION_PERCENT), 100), Event Healing));
    }
}

rule ("[utilities/hero_init.opy]: initHero()") {
    event {
        Subroutine;
        initHero;
    }
    actions {
        If(True);
            Skip(Value In Array(Array(82, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80), Add(1, Index Of Array Value(Array(Hero(Ana), Hero(Ashe), Hero(Baptiste), Hero(Bastion), Hero(Brigitte), Hero(Doomfist), Hero(D.Va), Hero(Echo), Hero(Genji), Hero(Hanzo), Hero(Illari), Hero(Junker Queen), Hero(Junkrat), Hero(Juno), Hero(Kiriko), Hero(Lifeweaver), Hero(Lúcio), Hero(Mauga), Hero(Cassidy), Hero(Mei), Hero(Mercy), Hero(Moira), Hero(Orisa), Hero(Pharah), Hero(Ramattra), Hero(Reaper), Hero(Reinhardt), Hero(Roadhog), Hero(Sigma), Hero(Sojourn), Hero(Soldier: 76), Hero(Sombra), Hero(Symmetra), Hero(Torbjörn), Hero(Tracer), Hero(Venture), Hero(Widowmaker), Hero(Winston), Hero(Wrecking Ball), Hero(Zarya), Hero(Zenyatta)), (Event Player).hero_setup))));
            Call Subroutine(initAna);
        Else;
            Call Subroutine(initAshe);
        Else;
            Call Subroutine(initBaptiste);
        Else;
            Call Subroutine(initBastion);
        Else;
            Call Subroutine(initBrigitte);
        Else;
            Call Subroutine(initDoomfist);
        Else;
            Call Subroutine(initDva);
        Else;
            Call Subroutine(initEcho);
        Else;
            Call Subroutine(initGenji);
        Else;
            Call Subroutine(initHanzo);
        Else;
            Call Subroutine(initIllari);
        Else;
            Call Subroutine(initJunkerQueen);
        Else;
            Call Subroutine(initJunkrat);
        Else;
            Call Subroutine(initJuno);
        Else;
            Call Subroutine(initKiriko);
        Else;
            Call Subroutine(initLifeweaver);
        Else;
            Call Subroutine(initLucio);
        Else;
            Call Subroutine(initMauga);
        Else;
            Call Subroutine(initMccree);
        Else;
            Call Subroutine(initMei);
        Else;
            Call Subroutine(initMercy);
        Else;
            Call Subroutine(initMoira);
        Else;
            Call Subroutine(initOrisa);
        Else;
            Call Subroutine(initPharah);
        Else;
            Call Subroutine(initRamattra);
        Else;
            Call Subroutine(initReaper);
        Else;
            Call Subroutine(initReinhardt);
        Else;
            Call Subroutine(initRoadhog);
        Else;
            Call Subroutine(initSigma);
        Else;
            Call Subroutine(initSojourn);
        Else;
            Call Subroutine(initSoldier);
        Else;
            Call Subroutine(initSombra);
        Else;
            Call Subroutine(initSymmetra);
        Else;
            Call Subroutine(initTorbjorn);
        Else;
            Call Subroutine(initTracer);
        Else;
            Call Subroutine(initVenture);
        Else;
            Call Subroutine(initWidowmaker);
        Else;
            Call Subroutine(initWinston);
        Else;
            Call Subroutine(initWreckingBall);
        Else;
            Call Subroutine(initZarya);
        Else;
            Call Subroutine(initZenyatta);
        Else;
            Call Subroutine(initHazard);
        Else;
        Else;
        End;
        If(Not((Event Player).hero_initialized));
            Big Message(Event Player, Custom String("warning: {0} not initialized properly!", (Event Player).hero_setup));
        End;
    }
}

rule ("[utilities/reset.opy]: resetHero()") {
    event {
        Subroutine;
        resetHero;
    }
    actions {
        Call Subroutine(clearCustomHp);
        Call Subroutine(disableAllAbilities);
        Call Subroutine(resetStats);
        Start Rule(resetUltCharge, Restart Rule);
        Call Subroutine(enableAllAbilities);
        Set Player Variable(Event Player, hero_initialized, False);
    }
}

rule ("[utilities/hero_reset.opy]: enableAllAbilities()") {
    event {
        Subroutine;
        enableAllAbilities;
    }
    actions {
        Allow Button(Event Player, Button(Primary Fire));
        Allow Button(Event Player, Button(Secondary Fire));
        Allow Button(Event Player, Button(Ability 1));
        Allow Button(Event Player, Button(Ability 2));
        Allow Button(Event Player, Button(Ultimate));
        Allow Button(Event Player, Button(Melee));
        Allow Button(Event Player, Button(Jump));
        Allow Button(Event Player, Button(Crouch));
        Allow Button(Event Player, Button(Reload));
        Allow Button(Event Player, Button(Interact));
        Set Primary Fire Enabled(Event Player, True);
        Set Secondary Fire Enabled(Event Player, True);
        Set Ability 1 Enabled(Event Player, True);
        Set Ability 2 Enabled(Event Player, True);
        Set Ultimate Ability Enabled(Event Player, True);
        Set Melee Enabled(Event Player, True);
        Set Jump Enabled(Event Player, True);
        Set Crouch Enabled(Event Player, True);
        Set Reload Enabled(Event Player, True);
    }
}

rule ("[utilities/hero_reset.opy]: disableAllAbilities()") {
    event {
        Subroutine;
        disableAllAbilities;
    }
    actions {
        Disallow Button(Event Player, Button(Primary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Disallow Button(Event Player, Button(Ability 1));
        Disallow Button(Event Player, Button(Ability 2));
        Disallow Button(Event Player, Button(Ultimate));
        Disallow Button(Event Player, Button(Melee));
        Disallow Button(Event Player, Button(Jump));
        Disallow Button(Event Player, Button(Crouch));
        Disallow Button(Event Player, Button(Reload));
        Disallow Button(Event Player, Button(Interact));
        Set Primary Fire Enabled(Event Player, False);
        Set Secondary Fire Enabled(Event Player, False);
        Set Ability 1 Enabled(Event Player, False);
        Set Ability 2 Enabled(Event Player, False);
        Set Ultimate Ability Enabled(Event Player, False);
        Set Melee Enabled(Event Player, False);
        Set Jump Enabled(Event Player, False);
        Set Crouch Enabled(Event Player, False);
        Set Reload Enabled(Event Player, False);
    }
}

rule ("[utilities/hero_reset.opy]: resetStats()") {
    event {
        Subroutine;
        resetStats;
    }
    actions {
        Set Player Variable At Index(Event Player, macro_pvar, 0, 1);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Damage Received(Event Player, 100);
        Set Projectile Speed(Event Player, 100);
        Set Projectile Gravity(Event Player, 100);
        Set Player Variable At Index(Event Player, macro_pvar, 1, 1);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Healing Received(Event Player, 100);
        Set Knockback Received(Event Player, 100);
        Set Knockback Dealt(Event Player, 100);
        "eventPlayer.setGravity(100)\neventPlayer.setJumpVerticalSpeed(100) # might be responsible for jump bug"
        Set Player Variable At Index(Event Player, macro_pvar, 2, 1);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 2)));
        Stop Scaling Player(Event Player);
        Stop Scaling Barriers(Event Player);
        "prevent wholehog from keeping primary fire held"
        Stop Holding Button(Event Player, Button(Primary Fire));
        Set Player Variable(Event Player, max_health_scaler, 1);
        Stop All Damage Over Time(Event Player);
        Stop All Heal Over Time(Event Player);
        Set Player Variable(Event Player, DamageRecieved, 100);
        Set Player Variable(Event Player, MoveSpeed, 100);
    }
}

rule ("[utilities/hero_reset.opy]: resetStatuses()") {
    event {
        Subroutine;
        resetStatuses;
    }
    actions {
        Clear Status(Event Player, Asleep);
        Clear Status(Event Player, Burning);
        Clear Status(Event Player, Frozen);
        Clear Status(Event Player, Hacked);
        Clear Status(Event Player, Invincible);
        Clear Status(Event Player, Knocked Down);
        Clear Status(Event Player, Phased Out);
        Clear Status(Event Player, Rooted);
        Clear Status(Event Player, Stunned);
        Clear Status(Event Player, Unkillable);
    }
}

rule ("[utilities/hero_reset.opy]: Stop DoT/HoT on death") {
    event {
        Player Died;
        All;
        All;
    }
    actions {
        Stop All Damage Over Time(Event Player);
        Stop All Heal Over Time(Event Player);
    }
}

rule ("[utilities/hero_switch.opy]: detect hero switch") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        First Of((Event Player).hero_switch_pvar) != Hero Of(Event Player);
    }
    actions {
        Set Player Variable At Index(Event Player, hero_switch_pvar, 1, True);
        Wait(0.016, Ignore Condition);
        Set Player Variable At Index(Event Player, hero_switch_pvar, 0, Hero Of(Event Player));
        "eventPlayer._hero_id = heroID(eventPlayer._last_hero_played)"
        Set Player Variable At Index(Event Player, hero_switch_pvar, 1, False);
    }
}

rule ("[utilities/hero_switch.opy]: Initialize hero on hero switch") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Value In Array((Event Player).hero_switch_pvar, 1) != False;
    }
    actions {
        Wait Until(Has Spawned(Event Player), 999999986991104);
        Wait Until(Not(Value In Array((Event Player).hero_switch_pvar, 1)), 999999986991104);
        Set Player Variable(Event Player, hero_setup, Hero Of(Event Player));
        Call Subroutine(resetHero);
        Call Subroutine(initHero);
    }
}

rule ("[utilities/hero_switch.opy]: Reinitialize hero on new round") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Between Rounds == True;
    }
    actions {
        Wait Until(Not(Is Between Rounds), 999999986991104);
        Call Subroutine(resetHero);
        Call Subroutine(initHero);
    }
}

rule ("Copyright (c) 2024 Overwatch 1 Emulator & 6v6 Adjustments. See github.com/6v6-Adjustments/6v6-adjustments for license to use this code.") {
    event {
        Ongoing - Global;
    }
    actions {
        Disable Inspector Recording;
    }
}

rule ("[utilities/global.opy] Initialize player variables") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    actions {
        Set Player Variable(Event Player, within_shout_radius, False);
        Set Player Variable(Event Player, DamageRecieved, 100);
        Set Player Variable(Event Player, MoveSpeed, 100);
        Set Player Variable(Event Player, Echo_Copy, False);
    }
}

rule ("[utilities/anti_crash.opy]: Activate anti crash") {
    event {
        Ongoing - Global;
    }
    conditions {
        Server Load > Global.ANTI_CRASH_ACTIVATE_PERCENT;
    }
    actions {
        Wait(Global.ANTI_CRASH_HOLD_TIME, Abort When False);
        Small Message(All Players(All Teams), Custom String("Crash protection in progress..."));
        Set Slow Motion(1);
        Wait Until(Compare(Server Load, <, Global.ANTI_CRASH_DEACTIVATE_PERCENT), 999999986991104);
        Set Slow Motion(100);
    }
}

rule ("[role_lock.opy]: Global/set all Heroes") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable(AllTankHeroes, Array(Hero(D.Va), Hero(Doomfist), Hero(Junker Queen), Hero(Mauga), Hero(Orisa), Hero(Ramattra), Hero(Reinhardt), Hero(Roadhog), Hero(Sigma), Hero(Venture), Hero(Winston), Hero(Wrecking Ball), Hero(Zarya), Hero(Hazard), Hero(Mei)));
        Set Global Variable(AllDpsHeroes, Array(Hero(Ashe), Hero(Bastion), Hero(Cassidy), Hero(Echo), Hero(Genji), Hero(Hanzo), Hero(Junkrat), Hero(Pharah), Hero(Reaper), Hero(Sojourn), Hero(Soldier: 76), Hero(Torbjörn), Hero(Tracer), Hero(Widowmaker), Hero(Symmetra)));
        Set Global Variable(AllSupportHeroes, Array(Hero(Ana), Hero(Baptiste), Hero(Brigitte), Hero(Illari), Hero(Juno), Hero(Kiriko), Hero(Lifeweaver), Hero(Lúcio), Hero(Mercy), Hero(Moira), Hero(Sombra), Hero(Zenyatta)));
    }
}

rule ("[role_lock.opy]: Role Limits") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable(AllRoles, Array(Workshop Setting Integer(Custom String("Roles"), Custom String("Tank Role Cap"), 0, 0, 6, 0), Workshop Setting Integer(Custom String("Roles"), Custom String("Damage Role Cap"), 0, 0, 6, 1), Workshop Setting Integer(Custom String("Roles"), Custom String("Support Role Cap"), 0, 0, 6, 2)));
    }
}

rule ("[role_lock.opy]: Player Init") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    actions {
        Set Player Variable(Event Player, AllowedHeroes, All Heroes);
    }
}

rule ("[role_lock.opy]: Tank") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllTankHeroes, Hero Of(Current Array Element))), Event Player)) >= First Of(Global.AllRoles);
        First Of(Global.AllRoles) > 0;
    }
    actions {
        If(Compare((Event Player).Echo_Copy, ==, False));
            Modify Player Variable(Event Player, AllowedHeroes, Remove From Array By Value, Global.AllTankHeroes);
            Set Player Allowed Heroes(Event Player, (Event Player).AllowedHeroes);
            Wait Until(Compare(Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllTankHeroes, Hero Of(Current Array Element))), Event Player)), <, First Of(Global.AllRoles)), 99999);
            Modify Player Variable(Event Player, AllowedHeroes, Append To Array, Global.AllTankHeroes);
            Set Player Allowed Heroes(Event Player, (Event Player).AllowedHeroes);
    }
}

rule ("[role_lock.opy]: Damage") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllDpsHeroes, Hero Of(Current Array Element))), Event Player)) >= Value In Array(Global.AllRoles, 1);
        Value In Array(Global.AllRoles, 1) > 0;
    }
    actions {
        If(Compare((Event Player).Echo_Copy, ==, False));
            Modify Player Variable(Event Player, AllowedHeroes, Remove From Array By Value, Global.AllDpsHeroes);
            Set Player Allowed Heroes(Event Player, (Event Player).AllowedHeroes);
            Wait Until(Compare(Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllDpsHeroes, Hero Of(Current Array Element))), Event Player)), <, Value In Array(Global.AllRoles, 1)), 99999);
            Modify Player Variable(Event Player, AllowedHeroes, Append To Array, Global.AllDpsHeroes);
            Set Player Allowed Heroes(Event Player, (Event Player).AllowedHeroes);
    }
}

rule ("[role_lock.opy]: Support") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllSupportHeroes, Hero Of(Current Array Element))), Event Player)) >= Value In Array(Global.AllRoles, 2);
        Value In Array(Global.AllRoles, 2) > 0;
    }
    actions {
        If(Compare((Event Player).Echo_Copy, ==, False));
            Modify Player Variable(Event Player, AllowedHeroes, Remove From Array By Value, Global.AllSupportHeroes);
            Set Player Allowed Heroes(Event Player, (Event Player).AllowedHeroes);
            Wait Until(Compare(Count Of(Remove From Array(Filtered Array(All Players(Team Of(Event Player)), Array Contains(Global.AllSupportHeroes, Hero Of(Current Array Element))), Event Player)), <, Value In Array(Global.AllRoles, 2)), 99999);
            Modify Player Variable(Event Player, AllowedHeroes, Append To Array, Global.AllSupportHeroes);
            Set Player Allowed Heroes(Event Player, (Event Player).AllowedHeroes);
    }
}

rule ("[role_lock.opy]: Skip Assemble Heroes") {
    event {
        Ongoing - Global;
    }
    conditions {
        Is Assembling Heroes == True;
    }
    actions {
        Wait(1, Ignore Condition);
        Set Match Time(1);
        Wait Until(Not(Is Assembling Heroes), 99999);
        Set Match Time(60);
    }
}

rule ("[passives/healing.opy]: Track Health != 100% stop healing then start healing after 5s") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        Global.enable_regeneration == True;
    }
    actions {
        Stop Heal Over Time((Event Player).regen_passive_id);
        Set Player Variable(Event Player, self_heal_pvar, False);
        Wait(Global.ADJ_REGEN_TIMER, Restart When True);
        Set Player Variable(Event Player, self_heal_pvar, True);
    }
}

rule ("[passives/healing.opy]: Healing passive amount and ID") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).self_heal_pvar != False;
        Global.enable_regeneration == True;
    }
    actions {
        Start Heal Over Time(Event Player, Null, 16200, Global.ADJ_REGEN_HPS);
        Set Player Variable(Event Player, regen_passive_id, Last Heal Over Time ID);
    }
}

rule ("[passives/healing.opy]: If health = max health stop healing") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Health(Event Player) == Max Health(Event Player);
        Global.enable_regeneration == True;
    }
    actions {
        Stop Heal Over Time((Event Player).regen_passive_id);
    }
}

rule ("[passives/tank/knockback.opy]: removeTankPassive()") {
    event {
        Subroutine;
        removeTankPassive;
    }
    actions {
        Set Knockback Received(Event Player, 130);
    }
}

rule ("[passives/damage/damage_passive.opy]: Remove DPS Passive") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        Array Contains(All Damage Heroes, Hero Of(Attacker)) == True;
        Attacker != Victim;
    }
    actions {
        If(Array Contains(All Tank Heroes, Hero Of(Victim)));
            Set Healing Received(Event Player, 112.5);
        Else;
            Set Healing Received(Event Player, 125);
        End;
        Wait(0.5, Ignore Condition);
        Wait(2.5, Restart When True);
        Set Healing Received(Event Player, 100);
    }
}

rule ("[debug_mode.opy]: Global init") {
    event {
        Ongoing - Global;
    }
    conditions {
        Global.DEBUG_MODE == True;
    }
    actions {
        "By Lotto"
        Set Global Variable(dpsTime, Workshop Setting Integer(Custom String("Dev Tools"), Custom String("Calculate DPS over seconds"), 20, 1, 200, 1));
        Create HUD Text(All Players(All Teams), Null, Null, Custom String("[{0}] -- Start/reset the DPS calculation.", Input Binding String(Button(Interact))), Left, 0, Null, Null, Color(Green), Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Null, Custom String("[Crouch] + [Jump] -- Spawn a bot."), Left, 1, Null, Null, Color(Turquoise), Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Null, Custom String("[Crouch] + [Melee] -- Remove all bots."), Left, 2, Null, Null, Color(Orange), Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Null, Custom String("Hold [Melee] -- Change Hero."), Left, 3, Null, Null, Color(Rose), Visible To and String, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Null, Custom String(" "), Left, 4, Null, Null, Color(White), Visible To and String, Default Visibility);
    }
}

rule ("[debug_mode.opy]: Player init") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Global.DEBUG_MODE == True;
    }
    actions {
        Chase Player Variable At Rate(Event Player, time, 0, 1, Destination and Rate);
        Create HUD Text(Event Player, (Event Player).damage, Custom String("Total damage"), Null, Left, 5, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
        Create HUD Text(Event Player, Divide((Event Player).damage, Subtract(Global.dpsTime, (Event Player).time)), Custom String("DPS"), Null, Left, 6, Color(Red), Color(White), Color(White), Visible To and String, Default Visibility);
        Create HUD Text(Event Player, (Event Player).time, Custom String("Time"), Null, Left, 7, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
    }
}

rule ("[debug_mode.opy]: Player Dealt Damage") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Victim != Attacker;
        Global.DEBUG_MODE == True;
    }
    actions {
        "Inspired by a damage numbers mode by Darwin"
        Destroy In-World Text((Event Player).textID);
        Set Player Variable(Event Player, position, Eye Position(Victim));
        Create In-World Text(Event Player, Event Damage, (Event Player).position, Add(0.85, Divide(Event Damage, 30)), Clip Against Surfaces, Visible To Position and String, Color(White), Default Visibility);
        Set Player Variable(Event Player, textID, Last Text ID);
        Chase Player Variable At Rate(Event Player, position, Add(Eye Position(Victim), Up), 0.9, None);
        Skip If(Compare((Event Player).time, ==, 0), 1);
        Modify Player Variable(Event Player, damage, Add, Event Damage);
        //lbl_0:
    }
}

rule ("[debug_mode.opy]: Start") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Button Held(Event Player, Button(Interact)) == True;
        Global.DEBUG_MODE == True;
    }
    actions {
        Set Player Variable(Event Player, time, Global.dpsTime);
        Set Player Variable(Event Player, damage, 0);
    }
}

rule ("[debug_mode.opy]: Spawn bot") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Button Held(Event Player, Button(Crouch)) == True;
        Is Button Held(Event Player, Button(Jump)) == True;
        Global.DEBUG_MODE == True;
    }
    actions {
        Create Dummy Bot(Hero(Ana), Opposite Team Of(Team Of(Event Player)), -1, Position Of(Event Player), Facing Direction Of(Event Player));
        Set Global Variable(bot, Last Created Entity);
        Wait(0.1, Ignore Condition);
        Set Max Health(Global.bot, 1000);
        Start Heal Over Time(Global.bot, Null, 16200, 500);
    }
}

rule ("[debug_mode.opy]: Remove all bots") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Button Held(Event Player, Button(Crouch)) == True;
        Is Button Held(Event Player, Button(Melee)) == True;
        Global.DEBUG_MODE == True;
    }
    actions {
        Destroy All Dummy Bots;
        Destroy In-World Text((Event Player).textID);
    }
}

rule ("[debug_mode.opy]: Change hero") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Button Held(Event Player, Button(Melee)) == True;
        Global.DEBUG_MODE == True;
    }
    actions {
        Wait(1, Abort When False);
        Set Player Variable(Event Player, position, Position Of(Event Player));
        Set Player Allowed Heroes(Event Player, Remove From Array(All Heroes, Hero Of(Event Player)));
        Wait(0.1, Ignore Condition);
        Set Player Allowed Heroes(Event Player, All Heroes);
        Destroy In-World Text((Event Player).textID);
        Wait Until(Has Spawned(Event Player), 16200);
        Teleport(Event Player, (Event Player).position);
    }
}

rule ("[ana/sleep.opy]: Sleep tanks as long as other heroes") {
    event {
        Player Dealt Damage;
        All;
        Ana;
    }
    conditions {
        Event Ability == Button(Ability 1);
        Array Contains(All Tank Heroes, Hero Of(Victim)) == True;
    }
    actions {
        Wait Until(Has Status(Victim, Asleep), 999999986991104);
        Wait(0.2, Ignore Condition);
        "Sleeping someone on top of sleep doesnt work anymore"
        Set Status(Victim, Attacker, Knocked Down, 4.8);
        Set Player Variable(Victim, Ana_Sleepdart_Target, True);
    }
}

rule ("[ana/nade.opy]: Increase Biotic Grenade healing") {
    event {
        Player Dealt Healing;
        All;
        Ana;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Heal(Healee, Healer, Subtract(Divide(Multiply(Event Healing, 1.334), Value In Array((Event Player).macro_pvar, 1)), Event Healing));
    }
}

rule ("[ashe/init.opy]: initAshe()") {
    event {
        Subroutine;
        initAshe;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2240);
        Set Player Variable(Event Player, max_health_scaler, 0.8);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

disabled rule ("[ashe/init.opy]: Correct Viper damage") {
    event {
        Player Dealt Damage;
        All;
        Ashe;
    }
    conditions {
        Array Contains(Button(Primary Fire), Event Ability) == True;
        Is Firing Secondary(Event Player) == False;
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.143), Event Damage));
    }
}

rule ("[baptiste/init.opy]: initBaptiste()") {
    event {
        Subroutine;
        initBaptiste;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2440);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.96);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 1, 0.7);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Player Variable(Event Player, baptiste_balance_change_check, True);
        Set Player Variable(Event Player, max_health_scaler, 0.8);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[baptiste/init.opy]: Increase Baptiste melee damage") {
    event {
        Player Dealt Damage;
        All;
        Baptiste;
    }
    conditions {
        Array Contains(Array(Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[baptiste/init.opy]: Increase Biotic Launcher healing") {
    event {
        Player Dealt Healing;
        All;
        Baptiste;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Event Healing < 35;
        (Event Player).baptiste_balance_change_check != False;
    }
    actions {
        Set Player Variable(Event Player, baptiste_balance_change_check, False);
        Heal(Healee, Healer, Subtract(Multiply(Divide(Event Healing, Value In Array((Event Player).macro_pvar, 1)), 1.75), Event Healing));
        Wait(0.15, Ignore Condition);
        Set Player Variable(Event Player, baptiste_balance_change_check, True);
    }
}

rule ("[baptiste/init.opy]: Healing indicator") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Between Rounds == False;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0} {1}", Count Of(Filtered Array(All Living Players(Team Of(Event Player)), And(And(Compare(Distance Between(Event Player, Current Array Element), <=, 12), Is In Line of Sight(Event Player, Current Array Element, Enemy Barriers Block LOS)), Compare(Hero Of(Current Array Element), !=, Hero(Baptiste))))), Ability Icon String(Hero(Baptiste), Button(Ability 1))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(-0.35, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 2, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, Baptiste_hud, Last Text ID);
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Ability 1)), !=, 0), 99999);
        Destroy In-World Text((Event Player).Baptiste_hud);
    }
}

rule ("[baptiste/regen_burst.opy]: Correct regenerative burst hps") {
    event {
        Player Dealt Healing;
        All;
        Baptiste;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        "self healing"
        If(Compare(Healee, ==, Healer));
            Heal(Healee, Healer, Subtract(Multiply(Divide(Event Healing, Value In Array((Event Player).macro_pvar, 1)), 3.75), Event Healing));
        Else;
            Heal(Healee, Healer, Subtract(Multiply(Divide(Event Healing, Value In Array((Event Player).macro_pvar, 1)), 2.125), Event Healing));
    }
}

rule ("[baptiste/regen_burst.opy]: Remove initial burst healing from Regenerative Burst and set cooldown for duplicate") {
    event {
        Ongoing - Each Player;
        All;
        Baptiste;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Healing Dealt(Event Player, 0);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999986991104);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
    }
}

rule ("[baptiste/init.opy]: Clean up Baptiste") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Baptiste);
    }
    actions {
        Destroy In-World Text((Event Player).Baptiste_hud);
    }
}

rule ("[bastion/init.opy]: initBastion()") {
    event {
        Subroutine;
        initBastion;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 225);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 75);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2300);
        Start Scaling Player(Event Player, 0.96, True);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[bastion/selfrepair.opy] Heal and drain meter") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == True;
        Has Status(Event Player, Knocked Down) == False;
        Has Status(Event Player, Asleep) == False;
        Has Status(Event Player, Frozen) == False;
        Has Status(Event Player, Stunned) == False;
    }
    actions {
        If(And(Compare((Event Player).Bastion_healing_meter, >=, 5), Compare((Event Player).BastionHealingSpamProtection, ==, False)));
            Stop Chasing Player Variable(Event Player, Bastion_healing_meter);
            Chase Player Variable At Rate(Event Player, Bastion_healing_meter, 0, 25, Destination and Rate);
            Start Heal Over Time(Event Player, Event Player, 9999, 50);
            Set Player Variable(Event Player, Bastion_healing_id, Last Heal Over Time ID);
            Disallow Button(Event Player, Button(Primary Fire));
            Disallow Button(Event Player, Button(Secondary Fire));
            Disallow Button(Event Player, Button(Ability 1));
            Disallow Button(Event Player, Button(Ultimate));
    }
}

rule ("[bastion/selfrepair.opy] Stop heal and refill meter") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == False;
    }
    actions {
        Stop Chasing Player Variable(Event Player, Bastion_healing_meter);
        Chase Player Variable At Rate(Event Player, Bastion_healing_meter, 100, 15, Destination and Rate);
        Stop Heal Over Time((Event Player).Bastion_healing_id);
        Allow Button(Event Player, Button(Primary Fire));
        Allow Button(Event Player, Button(Secondary Fire));
        Allow Button(Event Player, Button(Ability 1));
        Allow Button(Event Player, Button(Ultimate));
        Destroy Effect((Event Player).Bastion_healing_effect);
        Destroy Effect((Event Player).Bastion_healing_sound);
    }
}

rule ("[bastion/selfrepair.opy] Disallow Heal if heal meter 0") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).Bastion_healing_meter == 0;
    }
    actions {
        Start Holding Button(Event Player, Button(Ability 2));
        Stop Holding Button(Event Player, Button(Ability 2));
        Press Button(Event Player, Button(Ability 2));
        Disallow Button(Event Player, Button(Ability 2));
    }
}

rule ("[bastion/selfrepair.opy] Allow Heal if heal meter >= 25") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).Bastion_healing_meter >= 25;
    }
    actions {
        Allow Button(Event Player, Button(Ability 2));
    }
}

rule ("[bastion/selfrepair.opy] Create hud") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).Bastion_healing_meter != 100;
    }
    actions {
        Create Progress Bar In-World Text(Event Player, (Event Player).Bastion_healing_meter, Custom String("({0}) Repair", Input Binding String(Button(Ability 2))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(-0.600000000000000, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 0.9, Do Not Clip, Color(Yellow), Color(White), Visible To Position Values and Color, Default Visibility);
        Set Player Variable(Event Player, Bastion_healing_meter_hud, Last Text ID);
    }
}

rule ("[bastion/selfrepair.opy] Destroy hud") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        (Event Player).Bastion_healing_meter == 100;
    }
    actions {
        Destroy Progress Bar In-World Text((Event Player).Bastion_healing_meter_hud);
    }
}

rule ("[bastion/selfrepair.opy] Bug prevention") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is Button Held(Event Player, Button(Ability 2)) == True;
        Has Status(Event Player, Knocked Down) == False;
        Has Status(Event Player, Asleep) == False;
        Has Status(Event Player, Frozen) == False;
        Has Status(Event Player, Stunned) == False;
    }
    actions {
        If(Compare((Event Player).Bastion_healing_meter, >=, 5));
            Wait Until(Not(Is Button Held(Event Player, Button(Ability 2))), 99999);
            Set Player Variable(Event Player, BastionHealingSpamProtection, True);
            Wait(0.25, Ignore Condition);
            Set Player Variable(Event Player, BastionHealingSpamProtection, False);
    }
}

rule ("[bastion/reconfigure.opy]: Reduce assault form damage and movement speed") {
    event {
        Ongoing - Each Player;
        All;
        Bastion;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Damage Received(Event Player, 112.5);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 15);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait(0.95, Ignore Condition);
        Start Heal Over Time(Event Player, Event Player, 8, 15);
        Set Player Variable(Event Player, sentry_healing_id, Last Heal Over Time ID);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999986991104);
        Set Damage Received(Event Player, 100);
        Modify Player Variable(Event Player, MoveSpeed, Add, 15);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Stop Heal Over Time((Event Player).sentry_healing_id);
        Set Player Variable(Event Player, sentry_healing_id, Null);
    }
}

rule ("[bastion/reconfigure.opy]: Increase movement allowed by self-damage grenade") {
    event {
        Player Dealt Damage;
        All;
        Bastion;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Attacker == Victim;
    }
    actions {
        Modify Player Variable(Event Player, MoveSpeed, Add, 25);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        "Grace period to make sure the player receives this benefit"
        Wait(0.1, Ignore Condition);
        Wait Until(Is On Ground(Event Player), 999999986991104);
        "if not ruleCondition:\nreturn"
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 25);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

rule ("[bastion/init.opy]: Reduce grenade self-damage") {
    event {
        Player Dealt Damage;
        All;
        Bastion;
    }
    conditions {
        Attacker == Victim;
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Multiply(Event Damage, 0.5)));
    }
}

rule ("[bastion/init.opy]: Clean up Bastion") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Bastion);
    }
    actions {
        Destroy Progress Bar In-World Text((Event Player).Bastion_healing_meter_hud);
        Stop Heal Over Time((Event Player).Bastion_healing_id);
        Destroy Effect((Event Player).Bastion_healing_effect);
        Destroy Effect((Event Player).Bastion_healing_sound);
    }
}

rule ("[brigitte/init.opy]: initBrigitte()") {
    event {
        Subroutine;
        initBrigitte;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 150);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 50);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2625);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.778);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 1, 0.8);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[brigitte/bash.opy]: Correct Shield Bash damage") {
    event {
        Player Dealt Damage;
        All;
        Brigitte;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[brigitte/bash.opy]: Track Bash cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        Is Firing Primary(Event Player) == True;
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, bash_cooldown, 5.3);
        Chase Player Variable At Rate(Event Player, bash_cooldown, 0, 1, None);
    }
}

rule ("[brigitte/bash.opy]: Force cooldown for Bash in Rally") {
    event {
        Ongoing - Each Player;
        All;
        Brigitte;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Primary Fire), (Event Player).bash_cooldown);
    }
}

rule ("[brigitte/inspire.opy]: Increase Inspire self healing") {
    event {
        Player Dealt Healing;
        All;
        Brigitte;
    }
    conditions {
        Healee == Healer;
    }
    actions {
        Heal(Healee, Null, Subtract(Multiply(Event Healing, 1.25), Event Healing));
    }
}

rule ("[brigitte/repair_pack.opy]: Increase Repair Pack healing") {
    event {
        Player Dealt Healing;
        All;
        Brigitte;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Heal(Healee, Healer, Subtract(Multiply(Event Healing, 1.25), Event Healing));
    }
}

rule ("[brigitte/repair_pack.opy]: Extra Repair Pack burst healing") {
    event {
        Player Dealt Healing;
        All;
        Brigitte;
    }
    conditions {
        Event Ability == Button(Ability 2);
        Event Healing >= 19;
    }
    actions {
        Heal(Healee, Healer, 5);
    }
}

rule ("[brigitte/init.opy]: Correct Whipshot damage") {
    event {
        Player Dealt Damage;
        All;
        Brigitte;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[doomfist/init.opy]: initDoomfist()") {
    event {
        Subroutine;
        initDoomfist;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 450);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1750);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.8);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, max_health_scaler, 0.625);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[doomfist/meteor_strike.opy]: Correct Meteor Strike and Doomfist melee damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Ultimate)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[doomfist/punch.opy]: Initialize rocket punch") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
    }
    actions {
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.5);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, punched_victims, Empty Array);
        Set Player Variable(Event Player, wall_impacted_victims, Empty Array);
        Wait Until(Not(Is Firing Secondary(Event Player)), 4);
        Wait(0.2, Ignore Condition);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.8);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[doomfist/punch.opy]: Find wall impacted victims") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Array Contains((Attacker).punched_victims, Victim) == True;
        Array Contains((Attacker).wall_impacted_victims, Victim) == False;
    }
    actions {
        Modify Player Variable(Attacker, wall_impacted_victims, Append To Array, Victim);
        Clear Status(Victim, Stunned);
        "OW1 single punch victim"
        If(Compare(Count Of((Attacker).punched_victims), ==, 1));
            Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
        Else;
    }
}

rule ("[doomfist/punch.opy]: Find punched victims") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
        Array Contains((Attacker).punched_victims, Victim) == False;
    }
    actions {
        Modify Player Variable(Attacker, punched_victims, Append To Array, Victim);
        "OW1 single punch victim"
        If(Compare(Count Of((Attacker).punched_victims), ==, 1));
            Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
        Else;
    }
}

rule ("[doomfist/init.opy]: Correct Seismic Slam damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.8), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[doomfist/powerblock.opy]: Reduce Power Block active duration") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait(1.75, Ignore Condition);
        Press Button(Event Player, Button(Ability 2));
    }
}

rule ("[doomfist/init.opy]: Correct Hand Cannon damage") {
    event {
        Player Dealt Damage;
        All;
        Doomfist;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.909), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[doomfist/meteorstrike.opy] Doomfist ult remove self healing") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Healing Dealt(Event Player, 0);
        Wait Until(Not(Is Using Ultimate(Event Player)), 99999);
        Set Healing Dealt(Event Player, 100);
    }
}

rule ("[dva/init.opy]: initDva()") {
    event {
        Subroutine;
        initDva;
    }
    actions {
        "setCustomHp(\nADJ_DVA_HEALTH_DUPLICATE if eventPlayer.isDuplicatingAHero() or SETTING_ECHO_TANK_HP else ADJ_DVA_HEALTH,\nADJ_DVA_ARMOR_DUPLICATE if eventPlayer.isDuplicatingAHero() or SETTING_ECHO_TANK_HP else ADJ_DVA_ARMOR,\n0)"
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1540);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.955);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, self_destruct_charge, 0);
        Set Player Variable(Event Player, max_health_scaler, 0.857);
        Wait Until(Not(Is In Alternate Form(Event Player)), 999999986991104);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 325);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 225);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[dva/boosters.opy]: Reduce Boosters damage") {
    event {
        Player Dealt Damage;
        All;
        D.Va;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Divide(Multiply(0.8, Event Damage), First Of((Event Player).macro_pvar))));
    }
}

rule ("[dva/defense_matrix.opy]: Increase Defense Matrix cooldown") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        "Defense Matrix still goes on cooldown visually even when the ability is disabled, so a faux cooldown was not implemented"
        Wait Until(Not(Is Firing Secondary(Event Player)), 999999986991104);
        Set Secondary Fire Enabled(Event Player, False);
        Wait(1.5, Ignore Condition);
        Set Secondary Fire Enabled(Event Player, True);
    }
}

rule ("[dva/hp.opy]: Correct DVa mech health") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup == Hero(D.Va);
        Is In Alternate Form(Event Player) == False;
        (Event Player).hero_initialized != False;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 325);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 225);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
    }
}

rule ("[dva/hp.opy]: Correct DVa pilot health") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup == Hero(D.Va);
        Is In Alternate Form(Event Player) == True;
        Max Health Of Type(Event Player, Health) != 150;
        (Event Player).hero_initialized != False;
    }
    actions {
        Call Subroutine(clearCustomHp);
    }
}

rule ("[dva/init.opy]: Reduce Micro Missiles damage") {
    event {
        Player Dealt Damage;
        All;
        D.Va;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        "heal(victim, null, eventDamage - eventDamage / eventPlayer.macro_pvar[0])"
        Heal(Event Player, Null, Multiply(3, Subtract(Event Damage, Divide(Event Damage, First Of((Event Player).macro_pvar)))));
    }
}

rule ("[dva/init.opy]: Increase D.va other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        D.Va;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Ultimate)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[dva/init.opy]: Force reset ult charge when DVa exits Mech") {
    event {
        Ongoing - Each Player;
        All;
        D.Va;
    }
    conditions {
        Is In Alternate Form(Event Player) == True;
    }
    actions {
        Abort If(Is Using Ultimate(Event Player));
        Set Ultimate Charge(Event Player, 0);
    }
}

rule ("[echo/init.opy]: initEcho()") {
    event {
        Subroutine;
        initEcho;
    }
    actions {
        Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
        Set Ability Cooldown(Event Player, Button(Ability 2), 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1880);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.833);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Start Scaling Player(Event Player, 0.94, True);
        Disallow Button(Event Player, Button(Ultimate));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[echo/init.opy]: Correct Echo Tri-Shot damage") {
    event {
        Player Dealt Damage;
        All;
        Echo;
    }
    conditions {
        Is Duplicating(Event Player) == False;
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.971), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[echo/init.opy]: Correct Echo other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        Echo;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Ability 2)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[genji/init.opy]: initGenji()") {
    event {
        Subroutine;
        initGenji;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1150);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[genji/dragonblade.opy]: Genji Damage in Ultimate 100") {
    event {
        Player Dealt Damage;
        All;
        Genji;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Event Ability == Button(Ultimate);
    }
    actions {
        Heal(Victim, Null, 10);
    }
}

rule ("[genji/init.opy]: Reduce Deflect duration") {
    event {
        Ongoing - Each Player;
        All;
        Genji;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait(1.5, Ignore Condition);
        Press Button(Event Player, Button(Ability 2));
    }
}

rule ("[hanzo/init.opy]: initHanzo()") {
    event {
        Subroutine;
        initHanzo;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1680);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.933);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[hanzo/weapon.opy]: Hanzo draw aura") {
    event {
        Ongoing - Each Player;
        All;
        Hanzo;
    }
    conditions {
        Is Firing Primary(Event Player) == True;
    }
    actions {
        "max draw time"
        Wait(0.8, Abort When False);
        Create Effect(Filtered Array(All Players(Opposite Team Of(Team Of(Event Player))), And(Compare(Distance Between(Event Player, Current Array Element), >=, 1), Is In View Angle(Event Player, Eye Position(Current Array Element), 30))), Good Aura, Custom Color(239, 47, 60, 125), Eye Position(Event Player), 0.475, Visible To Position and Radius);
        Set Player Variable(Event Player, HanzoDrawAura, Last Created Entity);
        Wait Until(Not(Is Firing Primary(Event Player)), 100000000);
        Destroy Effect((Event Player).HanzoDrawAura);
    }
}

rule ("[hanzo/init.opy]: Correct Hanzo other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        Hanzo;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Primary Fire), Button(Ability 1), Button(Ultimate)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[hazard/init.opy]: initHazard()") {
    event {
        Subroutine;
        initHazard;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 300);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 150);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2000);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.8);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[hazard/init.opy]: Increase Hazard melee, wall, ultimate damage") {
    event {
        Player Dealt Damage;
        All;
        Hazard;
    }
    conditions {
        Array Contains(Array(Button(Ability 2), Button(Ultimate), Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[hazard/spike_guard.opy] Increase damage on block to 230") {
    event {
        Player Dealt Damage;
        All;
        Hazard;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.94, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[hazard/violent_leap.opy] Increase damage violant leap to 70") {
    event {
        Player Dealt Damage;
        All;
        Hazard;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.813, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[illari/init.opy]: initIllari()") {
    event {
        Subroutine;
        initIllari;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2450);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.75);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 1, 0.75);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Player Variable(Event Player, max_health_scaler, 0.8);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[illari/solar_rifle.opy]: Correct Solar Rifle damage") {
    event {
        Player Dealt Damage;
        All;
        Illari;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        If(Event Was Critical Hit);
            Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 1.143), Event Damage), First Of((Event Player).macro_pvar)));
        Else;
            Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[illari/solar_rifle.opy]: Correct Solar Rifle healing") {
    event {
        Ongoing - Each Player;
        All;
        Illari;
    }
    conditions {
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
    }
    actions {
        Set Healing Dealt(Event Player, 100);
        Wait Until(Not(Is Button Held(Event Player, Button(Secondary Fire))), 999999986991104);
        Set Healing Dealt(Event Player, 75);
    }
}

rule ("[illari/init.opy]: Correct Outburst and melee damage") {
    event {
        Player Dealt Damage;
        All;
        Illari;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Ability 1)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[illari/init.opy]: Correct Pylon self healing") {
    event {
        Player Dealt Healing;
        All;
        Illari;
    }
    conditions {
        Healee == Healer;
    }
    actions {
        Heal(Healer, Null, Event Healing);
    }
}

rule ("[junkerqueen/init.opy]: initJunkerQueen()") {
    event {
        Subroutine;
        initJunkerQueen;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 425);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2300);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.875);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Healing Dealt(Event Player, 73.563);
        Set Knockback Dealt(Event Player, 64);
        Start Scaling Player(Event Player, 0.96, True);
        Set Max Ammo(Event Player, 0, 8);
        Set Ammo(Event Player, 0, 8);
        Set Player Variable(Event Player, overhealth_check, False);
        Set Player Variable(Event Player, max_health_scaler, 0.714);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[junkerqueen/carnage.opy]: Reduce Carnage damage") {
    event {
        Ongoing - Each Player;
        All;
        Junker Queen;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 85.714);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[junkerqueen/commanding_shout.opy]: Prepare Commanding Shout ally tracking") {
    event {
        Ongoing - Each Player;
        All;
        Junker Queen;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Remove From Array(Players Within Radius(Event Player, 15.5, Team Of(Event Player), Surfaces), Event Player), within_shout_radius, True);
        Set Move Speed(Event Player, Multiply(Multiply(100, Value In Array((Event Player).macro_pvar, 2)), 1.038));
        Wait(4.9, Ignore Condition);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 2)));
    }
}

rule ("[junkerqueen/commanding_shout.opy]: Reduce Commanding Shout overhealth for allies") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).within_shout_radius == True;
    }
    actions {
        "damage(eventPlayer, null, ((OW2_JUNKERQUEEN_SHOUT_ALLY_OVERHEALTH - ADJ_JUNKERQUEEN_SHOUT_ALLY_OVERHEALTH) + (OW2_JUNKERQUEEN_SHOUT_ALLY_OVERHEALTH * eventPlayer.max_health_scaler - OW2_JUNKERQUEEN_SHOUT_ALLY_OVERHEALTH)))\nheal(eventPlayer, null, 0.01)"
        Set Move Speed(Event Player, Multiply(Multiply(100, Value In Array((Event Player).macro_pvar, 2)), 1.038));
        Wait(2.9, Ignore Condition);
        Set Move Speed(Event Player, Multiply(Multiply(100, Value In Array((Event Player).macro_pvar, 2)), 1.35));
        Wait(0.9, Ignore Condition);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 2)));
        Set Player Variable(Event Player, within_shout_radius, False);
    }
}

rule ("[junkerqueen/jagged_blade.opy]: Correct Jagged Blade impact damage") {
    event {
        Player Dealt Damage;
        All;
        Junker Queen;
    }
    conditions {
        Event Damage == Multiply(65, First Of((Event Player).macro_pvar));
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[junkerqueen/jagged_blade.opy]: Increase Jagged Blade pull distance on squishies") {
    event {
        Player Dealt Knockback;
        All;
        Junker Queen;
    }
    conditions {
        Is Meleeing(Event Player) == False;
        Array Contains(All Tank Heroes, Hero Of(Victim)) == False;
    }
    actions {
        Apply Impulse(Victim, Vector(X Component Of(Normalize(Subtract(Position Of(Event Player), Position Of(Victim)))), 0, Z Component Of(Normalize(Subtract(Position Of(Event Player), Victim)))), 7.5, To World, Incorporate Contrary Motion);
    }
}

rule ("[junkerqueen/rampage.opy]: Reduce Rampage damage") {
    event {
        Ongoing - Each Player;
        All;
        Junker Queen;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 83.333);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[junkrat/init.opy]: initJunkrat()") {
    event {
        Subroutine;
        initJunkrat;
    }
    actions {
        "Version or the \"resetHealth\" subroutine that keeps tire at 100 hp"
        Remove All Health Pools From Player(Event Player);
        Wait(0.016, Ignore Condition);
        "DO NOT REMOVE THIS LINE"
        Set Max Health(Event Player, 100.001);
        "DO NOT REMOVE THIS LINE"
        Wait(0.016, Ignore Condition);
        Set Max Health(Event Player, 80);
        "eventPlayer.addHealthPool(Health.ARMOR, 1, true, true)\neventPlayer.addHealthPool(Health.SHIELDS, 1, true, true)\neventPlayer.removeAllHealthPools()\n#eventPlayer.addHealthPool(Health.NORMAL, 199, true, true)\nheal(eventPlayer, null, 1)"
        Call Subroutine(resetStats);
        Call Subroutine(resetStatuses);
        Call Subroutine(enableAllAbilities);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1925);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.875);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        "check mayhem.opy"
        Disallow Button(Event Player, Button(Ultimate));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[junkrat/mayhem.opy]: Correct Frag Launcher damage") {
    event {
        Player Dealt Damage;
        All;
        Junkrat;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        "damage(victim, attacker, ((eventDamage/eventPlayer._base_damage_scalar)*(ADJ_JUNKRAT_FRAG_DAMAGE/OW2_JUNKRAT_FRAG_DAMAGE) - eventDamage)/eventPlayer._base_damage_scalar)"
        Heal(Victim, Null, Multiply(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.8), Event Damage), -1));
    }
}

rule ("[junkrat/mayhem.opy]: Correct Junkrat Melee damage") {
    event {
        Player Dealt Damage;
        All;
        Junkrat;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[junkrat/mayhem.opy]: Correct Junkrat Trap damage") {
    event {
        Player Dealt Damage;
        All;
        Junkrat;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.9), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[junkrat/mayhem.opy]: Reset damage for Rip-Tire") {
    event {
        Ongoing - Each Player;
        All;
        Junkrat;
    }
    conditions {
        Is Button Held(Event Player, Button(Ultimate)) == True;
        Is On Ground(Event Player) == True;
        Ultimate Charge Percent(Event Player) >= 100;
    }
    actions {
        Set Damage Dealt(Event Player, 100);
        Allow Button(Event Player, Button(Ultimate));
        Press Button(Event Player, Button(Ultimate));
        Disallow Button(Event Player, Button(Ultimate));
        Wait(1, Ignore Condition);
        "revert damage back after Rip-Tire is deployed"
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[junkrat/init.opy]: Correct Junkrat invalid health") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup == Hero(Junkrat);
        Max Health Of Type(Event Player, Health) != 200;
        (Event Player).hero_initialized != False;
    }
    actions {
        Call Subroutine(initJunkrat);
    }
}

rule ("[juno/init.opy]: initJuno()") {
    event {
        Subroutine;
        initJuno;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 125);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 75);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2850);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.867);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 1, 1);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        "eventPlayer.disallowButton(Button.ULTIMATE)\nif eventPlayer.isDummy():\neventPlayer.setHealingDealt(percent(ADJ_JUNO_ORBITAL_RAY_HPS/OW2_JUNO_ORBITAL_RAY_HPS))\neventPlayer.setHealingDealt(5)"
        Set Move Speed(Event Player, 109.091);
        Set Ammo(Event Player, 0, 120);
        Set Max Ammo(Event Player, 0, 120);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[juno/init.opy]: Correct Pulsar Torpedo healing and damage") {
    event {
        Ongoing - Each Player;
        All;
        Juno;
    }
    conditions {
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
        Ability Cooldown(Event Player, Button(Secondary Fire)) < 0.1;
        Is Meleeing(Event Player) == False;
        Is Reloading(Event Player) == False;
    }
    actions {
        Set Healing Dealt(Event Player, 58.824);
        Set Damage Dealt(Event Player, 58.824);
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Secondary Fire)), >, 0), 4);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[juno/orbital_ray.opy]: Adjust Orbital Ray Healing") {
    event {
        Ongoing - Each Player;
        All;
        Juno;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Is Alive(Event Player) == True;
        Has Status(Event Player, Asleep) == False;
        Has Status(Event Player, Frozen) == False;
        Has Status(Event Player, Knocked Down) == False;
        Has Status(Event Player, Stunned) == False;
    }
    actions {
        Wait(0.469, Ignore Condition);
        Set Player Variable(Event Player, orbital_ray_x, X Component Of(Add(Position Of(Event Player), Multiply(1.625, Direction From Angles(Horizontal Facing Angle Of(Event Player), 0)))));
        Set Player Variable(Event Player, orbital_ray_z, Z Component Of(Add(Position Of(Event Player), Multiply(1.625, Direction From Angles(Horizontal Facing Angle Of(Event Player), 0)))));
        Set Player Variable(Event Player, orbital_ray_final_x, X Component Of(Add(Position Of(Event Player), Multiply(24.125, Direction From Angles(Horizontal Facing Angle Of(Event Player), 0)))));
        Set Player Variable(Event Player, orbital_ray_final_z, Z Component Of(Add(Position Of(Event Player), Multiply(24.125, Direction From Angles(Horizontal Facing Angle Of(Event Player), 0)))));
        Chase Player Variable Over Time(Event Player, orbital_ray_x, (Event Player).orbital_ray_final_x, 10, None);
        Chase Player Variable Over Time(Event Player, orbital_ray_z, (Event Player).orbital_ray_final_z, 10, None);
        "createBeam(eventPlayer, Beam.GOOD, vect(eventPlayer.orbital_ray_x, 0.0, eventPlayer.orbital_ray_z), vect(eventPlayer.orbital_ray_x, 100.0, eventPlayer.orbital_ray_z), Color.WHITE, EffectReeval.POSITION_AND_RADIUS)"
        While(Is Using Ultimate(Event Player));
            Start Damage Over Time(Filtered Array(All Living Players(Team Of(Event Player)), And(And(Compare(Distance Between(Vector((Event Player).orbital_ray_x, 0, (Event Player).orbital_ray_z), Vector(X Component Of(Position Of(Current Array Element)), 0, Z Component Of(Position Of(Current Array Element)))), <, 8), Compare(Health(Current Array Element), <, Max Health(Current Array Element))), Compare((Current Array Element).remainingAntiDuration, <=, 0))), Null, 0.098, 65);
            Wait(0.098, Ignore Condition);
        End;
    }
}

rule ("[juno/init.opy]: Correct Juno Melee damage") {
    event {
        Player Dealt Damage;
        All;
        Juno;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[kiriko/init.opy]: initKiriko()") {
    event {
        Subroutine;
        initKiriko;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2400);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.917);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 2, 1.091);
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 2)));
        Set Ability Cooldown(Event Player, Button(Ability 1), 5);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[kiriko/swift_step.opy]: Force swift step cooldown after spawning") {
    event {
        Player Died;
        All;
        Kiriko;
    }
    actions {
        Wait Until(And(Is Alive(Event Player), Is In Spawn Room(Event Player)), 999999986991104);
        Set Ability Cooldown(Event Player, Button(Ability 1), 5);
    }
}

rule ("[kiriko/swift_step.opy]: Heal when using Swift Step") {
    event {
        Ongoing - Each Player;
        All;
        Kiriko;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        "grace period to allow SS to cleanse anti-heal effects"
        Wait(0.1, Ignore Condition);
        Start Heal Over Time(Event Player, Null, 0.25, 140);
    }
}

rule ("[kiriko/init.opy]: Correct Kiriko melee damage") {
    event {
        Player Dealt Damage;
        All;
        Kiriko;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[lifeweaver/init.opy]: Initialize Lifeweaver") {
    event {
        Subroutine;
        initLifeweaver;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 100);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 100);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2000);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 1.25);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Projectile Speed(Event Player, 130);
        Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).Lifeweaver_petal_charges, Up)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(1.92, World Vector Of(Right, Event Player, Rotation)), Multiply(-2.05, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, Lifeweaver_petal_hud, Last Text ID);
        Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).Lifeweaver_dash_charges, Up)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(2.535, World Vector Of(Right, Event Player, Rotation)), Multiply(-2.05, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, Lifeweaver_dash_hud, Last Text ID);
        Create In-World Text(Event Player, Custom String("{0} {1}", Round To Integer((Event Player).Lifeweaver_petal_charges, Up), Ability Icon String(Hero(Lifeweaver), Button(Ability 1))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(-0.22, World Vector Of(Right, Event Player, Rotation)), Multiply(-0.6, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 1.3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, Lifeweaver_petal_centre_hud, Last Text ID);
        Create In-World Text(Event Player, Custom String("{0} {1}", Round To Integer((Event Player).Lifeweaver_dash_charges, Up), Ability Icon String(Hero(Lifeweaver), Button(Jump))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(0.22, World Vector Of(Right, Event Player, Rotation)), Multiply(-0.6, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 1.3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, Lifeweaver_leap_centre_target, Last Text ID);
        Set Player Variable(Event Player, Lifeweaver_petal_charges, 2);
        Set Player Variable(Event Player, Lifeweaver_dash_charges, 2);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[lifeweaver/init.opy]: Reduce Lifeweaver melee damage") {
    event {
        Player Dealt Damage;
        All;
        Lifeweaver;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Divide(Event Damage, First Of((Event Player).macro_pvar))));
    }
}

rule ("[lifeweaver/init.opy]: Reduce Tree of Life duration") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Wait(11, Ignore Condition);
        Press Button(Event Player, Button(Ultimate));
    }
}

rule ("[lifeweaver/healing.opy]: Correct Healing ammount") {
    event {
        Player Dealt Healing;
        All;
        Lifeweaver;
    }
    conditions {
        Event Ability != Button(Ultimate);
        Event Ability != Button(Ability 2);
        Event Player != Healee;
        (Event Player).Lifeweaver_healing_cd != True;
    }
    actions {
        Start Heal Over Time(Healee, Null, 4, 25);
        Set Player Variable(Healee, Lifeweaver_healing_cd, True);
    }
}

rule ("[lifeweaver/petalplatform.opy]: Lose charges and reset cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        (Event Player).Lifeweaver_petal_charges != 0;
        Is Button Held(Event Player, Button(Ability 1)) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions {
        Modify Player Variable(Event Player, Lifeweaver_petal_charges, Subtract, 1);
        If(Compare((Event Player).Lifeweaver_petal_charges, !=, 0));
            "waitUntil(eventPlayer.isUsingAbility1(), 99999)"
            Wait(0.25, Ignore Condition);
            Set Ability Cooldown(Event Player, Button(Ability 1), 0);
    }
}

rule ("[lifeweaver/petalplatform.opy]: recharge petal") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        (Event Player).Lifeweaver_petal_charges != 2;
    }
    actions {
        Wait(12, Abort When False);
        Modify Player Variable(Event Player, Lifeweaver_petal_charges, Add, 1);
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
        Loop If Condition Is True;
    }
}

rule ("[lifeweaver/dash.opy]: Lose charges") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        Vertical Speed Of(Event Player) == False;
        Is On Ground(Event Player) == False;
    }
    actions {
        Wait(0.032, Abort When False);
        If(Compare(Distance Between(Event Player, Add(Event Player, Velocity Of(Event Player))), >=, 8));
            Modify Player Variable(Event Player, Lifeweaver_dash_charges, Subtract, 1);
        Else;
            If(Compare(Distance Between(Event Player, Ray Cast Hit Position(Event Player, Add(Event Player, Velocity Of(Event Player)), Null, Null, True)), <=, 5));
                Modify Player Variable(Event Player, Lifeweaver_dash_charges, Subtract, 1);
    }
}

rule ("[lifeweaver/dash.opy]: Gain charges") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        (Event Player).Lifeweaver_dash_charges != 2;
    }
    actions {
        Wait(6, Ignore Condition);
        Modify Player Variable(Event Player, Lifeweaver_dash_charges, Add, 1);
        Loop If Condition Is True;
    }
}

rule ("[lifeweaver/dash.opy]: Disable Dash") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        (Event Player).Lifeweaver_dash_charges == 0;
        Is In Air(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Jump));
        Wait Until(Or(Is On Ground(Event Player), Compare((Event Player).Lifeweaver_dash_charges, !=, 0)), 99999);
        Allow Button(Event Player, Button(Jump));
    }
}

rule ("[lifeweaver/dash.opy]: Silly charge Bug fix") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        (Event Player).Lifeweaver_dash_charges > 2;
    }
    actions {
        Set Player Variable(Event Player, Lifeweaver_dash_charges, 2);
    }
}

rule ("[lifeweaver/grasp.opy] Set grasp cooldown to 10s when target is above 75%hp") {
    event {
        Ongoing - Each Player;
        All;
        Lifeweaver;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        If(Compare(Health(First Of(Sorted Array(Filtered Array(All Living Players(Team Of(Event Player)), And(And(And(And(Compare(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)), <=, 50), Has Spawned(Current Array Element)), Compare(Distance Between(Event Player, Current Array Element), <=, 30)), Compare(Current Array Element, !=, Event Player)), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element))))), >=, Multiply(Max Health(First Of(Sorted Array(Filtered Array(All Living Players(Team Of(Event Player)), And(And(And(And(Compare(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)), <=, 50), Has Spawned(Current Array Element)), Compare(Distance Between(Event Player, Current Array Element), <=, 30)), Compare(Current Array Element, !=, Event Player)), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element))))), 0.75)));
            Wait Until(Not(Is Using Ability 2(Event Player)), 99999);
            Set Ability Cooldown(Event Player, Button(Ability 2), 10);
    }
}

rule ("[lifeweaver/init.opy]: Clean up lifeweaver") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Lifeweaver);
    }
    actions {
        Destroy In-World Text((Event Player).Lifeweaver_petal_hud);
        Destroy In-World Text((Event Player).Lifeweaver_dash_hud);
        Destroy In-World Text((Event Player).Lifeweaver_healing_hud);
        Destroy In-World Text((Event Player).Lifeweaver_petal_centre_hud);
        Destroy In-World Text((Event Player).Lifeweaver_leap_centre_target);
    }
}

rule ("[lucio/init.opy]: initLucio()") {
    event {
        Subroutine;
        initLucio;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2940);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.444);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Start Scaling Player(Event Player, 0.96, True);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[lucio/init.opy]: Correct Lucio melee damage") {
    event {
        Player Dealt Damage;
        All;
        Lúcio;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[lucio/init.opy]: Correct Sonic Amplifier damage") {
    event {
        Player Dealt Damage;
        All;
        Lúcio;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.909), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[mauga/init.opy]: initMauga()") {
    event {
        Subroutine;
        initMauga;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 300);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 150);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2650);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.75);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, balance_change_check, False);
        Set Player Variable(Event Player, MaugaOverHP, 200);
        Create Progress Bar In-World Text(Event Player, Divide((Event Player).MaugaOverHP, 2), Custom String(""), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(0.3, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 0.7, Do Not Clip, Color(White), Color(White), Visible To Position Values and Color, Default Visibility);
        Set Player Variable(Event Player, MaugaShieldBarHUD, Last Text ID);
        Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).MaugaOverHP, Up)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(0.6, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 1.6, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, MaugaShieldNumberHUD, Last Text ID);
        Wait(1, Ignore Condition);
        Set Ability 1 Enabled(Event Player, True);
        Set Ability Cooldown(Event Player, Button(Ability 1), 0);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[mauga/cardiac.opy]: Cardiac Use Ability") {
    event {
        Ongoing - Each Player;
        All;
        Mauga;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Add Health Pool To Player(Event Player, Health, 150, False, True);
        Set Player Variable(Event Player, Mauga_Overdrive_Health, Last Created Health Pool);
        Modify Player Variable(Event Player, DamageRecieved, Add, 40);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Wait(3, Ignore Condition);
        Remove Health Pool From Player((Event Player).Mauga_Overdrive_Health);
        Modify Player Variable(Event Player, DamageRecieved, Subtract, 40);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
    }
}

rule ("[mauga/cardiac.opy]: Mauga Heal Others") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Using Ability 2(Players On Hero(Hero(Mauga), Team Of(Event Player))) == True;
        Distance Between(Event Player, Players On Hero(Hero(Mauga), Team Of(Event Player))) <= 10.5;
    }
    actions {
        Start Heal Over Time(Event Player, Players On Hero(Hero(Mauga), Team Of(Event Player)), 3, 50);
        Set Player Variable(Event Player, Cardiac_overdrive_active, Last Heal Over Time ID);
        Wait Until(Not(Is Using Ability 2(Players On Hero(Hero(Mauga), Team Of(Event Player)))), 3);
        Stop Heal Over Time((Event Player).Cardiac_overdrive_active);
    }
}

rule ("[mauga/cage.opy]: Reduce Cage Fight duration") {
    event {
        Ongoing - Each Player;
        All;
        Mauga;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Wait(6, Ignore Condition);
        Press Button(Event Player, Button(Ultimate));
    }
}

rule ("[mauga/init.opy]: Increase Mauga melee damage") {
    event {
        Player Dealt Damage;
        All;
        Mauga;
    }
    conditions {
        Array Contains(Array(Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[mauga/overrun.opy]: Reduce Mauga stomp damage") {
    event {
        Player Dealt Damage;
        All;
        Mauga;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Divide(Multiply(0.667, Event Damage), First Of((Event Player).macro_pvar))));
    }
}

rule ("[mauga/init.opy]: Clean up Mauga") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Mauga);
    }
    actions {
        Destroy Progress Bar In-World Text((Event Player).MaugaShieldBarHUD);
        Destroy In-World Text((Event Player).MaugaShieldNumberHUD);
    }
}

rule ("[mccree/init.opy]: initMccree()") {
    event {
        Subroutine;
        initMccree;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 225);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1680);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.667);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[mccree/deadeye.opy]: Set damage during deadeye") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 100);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[mccree/init.opy]: Correct Cassidy melee damage and gun damage") {
    event {
        Player Dealt Damage;
        All;
        Cassidy;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Primary Fire)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[mccree/flashbang.opy] Flashbang stun target for 0.4s") {
    event {
        Player Dealt Damage;
        All;
        Cassidy;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Set Status(Victim, Event Player, Stunned, 0.4);
    }
}

rule ("[mei/init.opy]: Increase Mei melee damage") {
    event {
        Player Dealt Damage;
        All;
        Mei;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[mei/wall.opy]: Wall cooldown seconds Mei") {
    event {
        Ongoing - Each Player;
        All;
        Mei;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait Until(Or(Is Button Held(Event Player, Button(Primary Fire)), Is Button Held(Event Player, Button(Secondary Fire))), 99999);
        If(Is Button Held(Event Player, Button(Primary Fire)));
            Wait Until(Not(Is Using Ability 2(Event Player)), 99999);
            Set Ability Cooldown(Event Player, Button(Ability 2), 10);
    }
}

rule ("[mei/cryo_freeze.opy]: OW1 Cryo-Freeze healing") {
    event {
        Ongoing - Each Player;
        All;
        Mei;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Healing Received(Event Player, 80);
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999986991104);
        Set Healing Received(Event Player, 100);
    }
}

rule ("[mei/init.opy]: Increase Mei other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        Mei;
    }
    conditions {
        Array Contains(Array(Button(Primary Fire), Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[mercy/init.opy]: initMercy()") {
    event {
        Subroutine;
        initMercy;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1400);
        Set Player Variable At Index(Event Player, macro_pvar, 1, 0.917);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Ammo(Event Player, 0, 20);
        Set Max Ammo(Event Player, 0, 20);
        Disallow Button(Event Player, Button(Ultimate));
        Set Ability 2 Enabled(Event Player, False);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[mercy/init.opy]: Reduce Valkyrie healing and force self-healing") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Stop All Heal Over Time(Event Player);
        Start Heal Over Time(Event Player, Null, 15, 20);
        Heal(Event Player, Null, 50);
        Set Healing Dealt(Event Player, 138.462);
        Wait(2, Ignore Condition);
        Set Healing Dealt(Event Player, 92.308);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
    }
}

rule ("[moira/init.opy]: initMoira()") {
    event {
        Subroutine;
        initMoira;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2800);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.923);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[moira/coalescence.opy]: Prevent fading during Coalescence") {
    event {
        Ongoing - Each Player;
        All;
        Moira;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Ability 1 Enabled(Event Player, False);
        Set Damage Dealt(Event Player, 82.353);
        Set Move Speed(Event Player, 107.143);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Move Speed(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 2)));
        Set Ability 1 Enabled(Event Player, True);
    }
}

rule ("[moira/init.opy]: Increase Moira other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        Moira;
    }
    conditions {
        Is Using Ultimate(Event Player) == False;
        Array Contains(Array(Button(Melee), Button(Ability 2)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[orisa/init.opy]: initOrisa()") {
    event {
        Subroutine;
        initOrisa;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 225);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 225);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1814);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.924);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        "if not eventPlayer.isDuplicatingAHero():\nsetBaseDamage(eventPlayer, ADJ_ORISA_JAVELIN_DIRECT_DAMAGE / OW2_ORISA_JAVELIN_DIRECT_DAMAGE)"
        Set Player Variable(Event Player, balance_change_check, True);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[orisa/terra_surge.opy]: Reduce Terra Surge base damage and add bonus overhealth") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Add Health Pool To Player(Event Player, Health, 150, False, True);
        Set Player Variable(Event Player, terra_overhealth_id, Last Created Health Pool);
        Set Damage Dealt(Event Player, 80);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Remove Health Pool From Player((Event Player).terra_overhealth_id);
    }
}

rule ("[orisa/terra_surge.opy]: Increase Terra Surge overhealth") {
    event {
        Player Dealt Damage;
        All;
        Orisa;
    }
    conditions {
        Event Ability == Button(Ultimate);
        "do not include wind-up damage"
        Event Damage >= 50;
    }
    actions {
        Damage(Victim, Attacker, Subtract(100, Event Damage));
    }
}

rule ("[orisa/fortify.opy]: -10% damage reduction and shorter cooldown = 10s") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        "I don't know where this value comes from or how to calculate it"
        Damage(Event Player, Null, 181.8);
        Modify Player Variable(Event Player, MoveSpeed, Add, 10);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Modify Player Variable(Event Player, DamageRecieved, Add, 20);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), Event Player, 8);
        Create Effect(All Players(All Teams), Ring, Color(Orange), Event Player, 8, Visible To Position and Radius);
        Set Player Variable(Event Player, Orisa_ring_effect, Last Created Entity);
        Wait Until(Not(Is Using Ability 1(Event Player)), 99999);
        Set Ability Cooldown(Event Player, Button(Ability 1), 10);
        Modify Player Variable(Event Player, DamageRecieved, Subtract, 20);
        Destroy Effect((Event Player).Orisa_ring_effect);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 10);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

rule ("[orisa/fortify.opy]: Orisa Fortify others by 10%") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Using Ability 1(Players On Hero(Hero(Orisa), Team Of(Event Player))) == True;
        Distance Between(Event Player, Players On Hero(Hero(Orisa), Team Of(Event Player))) < 8;
    }
    actions {
        Modify Player Variable(Event Player, DamageRecieved, Subtract, 10);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Wait Until(Or(Compare(Distance Between(Event Player, Players On Hero(Hero(Orisa), Team Of(Event Player))), >, 8), Not(Is Using Ability 1(Players On Hero(Hero(Orisa), Team Of(Event Player))))), 99999);
        Modify Player Variable(Event Player, DamageRecieved, Add, 10);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
    }
}

rule ("[orisa/fortify.opy]: Orisa damage enemys around her") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Start Damage Over Time(Players Within Radius(Add(Event Player, Up), 8, Opposite Team Of(Team Of(Event Player)), Surfaces), Event Player, 1, 25);
        Set Status(Players Within Radius(Event Player, 8, Opposite Team Of(Team Of(Event Player)), Surfaces), Event Player, Burning, 1);
        Wait(1, Abort When False);
        Loop If Condition Is True;
    }
}

rule ("[orisa/fortify.opy]: Orisa cancel fortify after 3s") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait(3, Ignore Condition);
        Press Button(Event Player, Button(Ability 1));
    }
}

rule ("[orisa/fortify.opy]: Orisa cancel spin after 1s") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait(1, Ignore Condition);
        Press Button(Event Player, Button(Ability 2));
    }
}

rule ("[orisa/spin.opy]: Movementspeed increase during Spin") {
    event {
        Ongoing - Each Player;
        All;
        Orisa;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Modify Player Variable(Event Player, MoveSpeed, Add, 50);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait Until(Not(Is Using Ability 2(Event Player)), 99999);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 50);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

rule ("[orisa/init.opy]: Clean up Orisa") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Orisa);
    }
    actions {
        Destroy Effect((Event Player).Orisa_ring_effect);
    }
}

rule ("[pharah/init.opy]: initPharah()") {
    event {
        Subroutine;
        initPharah;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2100);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[ramattra/init.opy]: initRamattra()") {
    event {
        Subroutine;
        initRamattra;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 400);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2016);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 1.1);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, max_health_scaler, 0.632);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[ramattra/nemesis_form.opy]: Correct Nemesis Form armor and movement speed") {
    event {
        Ongoing - Each Player;
        All;
        Ramattra;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Start Scaling Player(Event Player, 0.97, True);
        Set Damage Dealt(Event Player, 92.308);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 20);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        "for some reason the addHealthPool function doesn't read constants as usable numbers"
        Add Health Pool To Player(Event Player, Armor, 10, True, True);
        Wait Until(Compare(Max Health Of Type(Event Player, Armor), <, 11), 999999986991104);
        Modify Player Variable(Event Player, MoveSpeed, Add, 20);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Stop Scaling Player(Event Player);
        Remove Health Pool From Player(Last Created Health Pool);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[ramattra/nemesis_form.opy]: Increase other forms of damage (in nemesis)") {
    event {
        Player Dealt Damage;
        All;
        Ramattra;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        "This condition stops pummel from applying the damage increase"
        Event Damage < 60;
    }
    actions {
        Damage(Victim, Null, Divide(Subtract(Divide(Event Damage, 0.923), Event Damage), 0.923));
    }
}

rule ("[ramattra/init.opy]: Reduce Ramattra melee damage and vortex damage") {
    event {
        Player Dealt Damage;
        All;
        Ramattra;
    }
    conditions {
        Max Health Of Type(Event Player, Armor) == False;
        Array Contains(Array(Button(Ability 2), Button(Melee)), Event Ability) == True;
    }
    actions {
        Heal(Victim, Null, Subtract(Event Damage, Divide(Event Damage, First Of((Event Player).macro_pvar))));
    }
}

rule ("[reaper/init.opy]: initReaper()") {
    event {
        Subroutine;
        initReaper;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 225);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1900);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.981);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable At Index(Event Player, macro_pvar, 1, 1.2);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[reaper/init.opy]: Increase Reaper melee damage") {
    event {
        Player Dealt Damage;
        All;
        Reaper;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[reaper/init.opy]: Reduce Death Blossom damage") {
    event {
        Ongoing - Each Player;
        All;
        Reaper;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 91.892);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, 98.148);
    }
}

rule ("[reinhardt/init.opy]: initReinhardt()") {
    event {
        Subroutine;
        initReinhardt;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 275);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 275);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1460);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.85);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Knockback Received(Event Player, 93.333);
        Stop Forcing Throttle(Event Player);
        Set Player Variable(Event Player, max_health_scaler, 1.067);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[reinhardt/pin.opy]: Slow Reinhardt after pin") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 1(Event Player)), 99999);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 50);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait(1, Ignore Condition);
        Modify Player Variable(Event Player, MoveSpeed, Add, 50);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

rule ("[reinhardt/firestrike.opy]: Force single firestrike") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait Until(Not(Is Using Ability 2(Event Player)), 0.9);
        "Every time rein uses firestrike, reset the resource to 0"
        Set Ability Charge(Event Player, Button(Ability 2), 0);
        Wait(6, Ignore Condition);
        Set Ability Charge(Event Player, Button(Ability 2), 2);
    }
}

rule ("[reinhardt/firestrike.opy]: decrease Firestrike damage (early animation)") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 83.333);
        Wait(1, Ignore Condition);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[reinhardt/charge.opy]: Correct Charge damage") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        "Checks for pin vs boop damage (+ 1 because apparently 50.0 > 50 == true for whatever reason)"
        If(Compare(Event Damage, >, 51));
            Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
        Else;
            Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[reinhardt/shatter.opy]: Correct Earthshatter damage") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Event Ability == Button(Ultimate);
        Event Was Critical Hit == False;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[reinhardt/shatter.opy]: Correct Earthshatter critical damage") {
    event {
        Player Dealt Damage;
        All;
        Reinhardt;
    }
    conditions {
        Event Ability == Button(Ultimate);
        Event Was Critical Hit == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[roadhog/init.opy]: initRoadhog()") {
    event {
        Subroutine;
        initRoadhog;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 600);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2380);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.831);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Ammo(Event Player, 0, 6);
        Set Max Ammo(Event Player, 0, 6);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[roadhog/pigpen.opy]: Cancel Pigpen Animation") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Wait(0.08, Ignore Condition);
        Cancel Primary Action(Event Player);
    }
}

rule ("[roadhog/pigpen.opy]: Target Teammate") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
    }
    actions {
        Set Player Variable(Event Player, Roadhog_vape_target, First Of(Sorted Array(Filtered Array(All Living Players(Team Of(Event Player)), And(And(And(And(Compare(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)), <=, 30), Has Spawned(Current Array Element)), Compare(Distance Between(Event Player, Current Array Element), <=, 20)), Compare(Current Array Element, !=, Event Player)), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)))));
        Wait(0.16, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[roadhog/pigpen.opy]: Target Teammate HUD and allow Vape") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        (Event Player).Roadhog_vape_target != Null;
    }
    actions {
        "targeting hud"
        Create In-World Text(If-Then-Else(And(Compare((Event Player).Roadhog_vape_target, !=, Null), Compare(Ability Cooldown(Event Player, Button(Ability 2)), ==, 0)), Event Player, Null), Custom String(" \n\n\n\n\n\n     ︿\n〈      〉\n     ﹀ "), Add((Event Player).Roadhog_vape_target, Vector(0, 0.7, 0)), 2, Do Not Clip, Visible To Position and String, Custom Color(55, 230, 255, 210), Default Visibility);
        Set Player Variable(Event Player, Roadhog_targeting_hud, Last Text ID);
        Allow Button(Event Player, Button(Ability 2));
    }
}

rule ("[roadhog/pigpen.opy]: Disallow Vape") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        (Event Player).Roadhog_vape_target == Null;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 2));
        Destroy In-World Text((Event Player).Roadhog_targeting_hud);
    }
}

rule ("[roadhog/pigpen.opy]: Confirm Target") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Player Variable((Event Player).Roadhog_vape_target, Roadhog_vape_confirmed, True);
    }
}

rule ("[roadhog/pigpen.opy]: Buff Teammate and play effects") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).Roadhog_vape_confirmed == True;
    }
    actions {
        Set Player Variable(Event Player, Roadhog_vape_confirmed, False);
        Create Effect(All Players(All Teams), Cloud, Color(Yellow), Event Player, 0.9, Visible To Position and Radius);
        Set Player Variable(Event Player, Roadhog_vape_effect, Last Created Entity);
        Set Player Variable(Players On Hero(Hero(Roadhog), Team Of(Event Player)), Roadhog_vape_target, Null);
        Set Player Variable(Event Player, Roadhog_vape_hud_icon, True);
        Big Message(Event Player, Custom String("VAPED"));
        Play Effect(All Players(All Teams), Buff Explosion Sound, Color(White), Event Player, 80);
        Start Heal Over Time(Event Player, Players On Hero(Hero(Roadhog), Team Of(Event Player)), 3, 60);
        Modify Player Variable(Event Player, DamageRecieved, Subtract, 30);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Wait(3, Ignore Condition);
        Modify Player Variable(Event Player, DamageRecieved, Add, 30);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Destroy Effect((Event Player).Roadhog_vape_effect);
        Set Player Variable(Event Player, Roadhog_vape_hud_icon, False);
    }
}

rule ("[roadhog/breather.opy]: Adjust Breather efficacy") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Healing Dealt(Event Player, 222.222);
        Wait(0.8, Ignore Condition);
        Set Healing Dealt(Event Player, 48.387);
        Wait Until(Not(Is Firing Secondary(Event Player)), 999999986991104);
        Set Healing Dealt(Event Player, 100);
    }
}

rule ("[roadhog/wholehog.opy]: Disable abilities during wholehog") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Melee Enabled(Event Player, False);
        Set Secondary Fire Enabled(Event Player, False);
        Set Ability 1 Enabled(Event Player, False);
        Set Ability 2 Enabled(Event Player, False);
        Set Damage Dealt(Event Player, 100);
        Set Knockback Dealt(Event Player, 100);
    }
}

rule ("[roadhog/wholehog.opy]: Enable abilities after wholehog") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == False;
    }
    actions {
        Set Melee Enabled(Event Player, True);
        Set Secondary Fire Enabled(Event Player, True);
        Set Ability 1 Enabled(Event Player, True);
        Set Ability 2 Enabled(Event Player, True);
        Stop Holding Button(Event Player, Button(Primary Fire));
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Knockback Dealt(Event Player, 35);
    }
}

rule ("[roadhog/wholehog.opy]: Force autofire while in wholehog") {
    event {
        Ongoing - Each Player;
        All;
        Roadhog;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Is Button Held(Event Player, Button(Primary Fire)) == False;
    }
    actions {
        Start Holding Button(Event Player, Button(Primary Fire));
    }
}

rule ("[roadhog/init.opy]: Correct melee damage") {
    event {
        Player Dealt Damage;
        All;
        Roadhog;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[roadhog/init.opy]: Correct Chain Hook damage") {
    event {
        Player Dealt Damage;
        All;
        Roadhog;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[roadhog/init.opy]: Clean up Roadhog") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Roadhog);
    }
    actions {
        Set Player Variable(Event Player, Roadhog_vape_target, Null);
        Destroy In-World Text((Event Player).Roadhog_targeting_hud);
        Destroy HUD Text(First Of((Event Player).Explaination_Hud));
    }
}

rule ("[sigma/init.opy]: initSigma()") {
    event {
        Subroutine;
        initSigma;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 300);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 100);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2275);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.75);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, balance_change_check, 0);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[sigma/init.opy]: Reduce Accretion stun duration") {
    event {
        Player Dealt Damage;
        All;
        Sigma;
    }
    conditions {
        Has Status(Victim, Knocked Down) == True;
    }
    actions {
        Wait(0.5, Ignore Condition);
        Clear Status(Victim, Knocked Down);
    }
}

rule ("[sigma/kinetic_grasp.opy]: Reduce Kinetic Grasp overhealth") {
    event {
        Ongoing - Each Player;
        All;
        Sigma;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait(1.2, Abort When False);
        Set Player Variable(Event Player, hp_exiting_grasp, Health(Event Player));
        Wait Until(Not(Is Using Ability 1(Event Player)), 999999986991104);
        Damage(Event Player, Null, Multiply(0.3, Subtract(Health(Event Player), (Event Player).hp_exiting_grasp)));
    }
}

rule ("[sigma/init.opy]: Increase Sigma other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        Sigma;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Primary Fire)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[sigma/init.opy]: Increase Gravitic Flux damage") {
    event {
        Ongoing - Each Player;
        All;
        Sigma;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 100);
        "waitUntil(not eventPlayer.isUsingUltimate(), 999999986991104)"
        Wait Until(Or(Is Button Held(Event Player, Button(Primary Fire)), Not(Is Using Ultimate(Event Player))), 10);
        Wait(1.7, Ignore Condition);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[sojourn/init.opy]: initSojourn()") {
    event {
        Subroutine;
        initSojourn;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2100);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.834);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[sojourn/primary.opy] Increased primary damage") {
    event {
        Player Dealt Damage;
        All;
        Sojourn;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        If(Event Was Critical Hit);
            Damage(Victim, Event Player, 3);
        Else;
            Damage(Victim, Event Player, 1.5);
    }
}

rule ("[sojourn/orb.opy] Increased disruptor shot damage") {
    event {
        Player Dealt Damage;
        All;
        Sojourn;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Damage(Victim, Event Player, 5.2);
    }
}

rule ("[sojourn/ultimate.opy] 200 damage in ult") {
    event {
        Player Dealt Damage;
        All;
        Sojourn;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Event Ability == Button(Ultimate);
    }
    actions {
        If(Event Was Critical Hit);
            Damage(Victim, Event Player, Multiply(Event Damage, 0.4));
    }
}

rule ("[soldier/init.opy]: initSoldier()") {
    event {
        Subroutine;
        initSoldier;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2310);
        Set Player Variable At Index(Event Player, macro_pvar, 1, 0.875);
        Set Healing Dealt(Event Player, Multiply(100, Value In Array((Event Player).macro_pvar, 1)));
        Set Ammo(Event Player, 0, 30);
        Set Max Ammo(Event Player, 0, 30);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[sombra/init.opy]: initSombra()") {
    event {
        Subroutine;
        initSombra;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, Null);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, Null);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 3000);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.875);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, Sombra_invisible, False);
        Create In-World Text(Event Player, Custom String("{0} {1}", Count Of(Filtered Array(All Living Players(Team Of(Event Player)), And(And(Compare(Distance Between(Event Player, Current Array Element), <=, 15), Is In Line of Sight(Event Player, Current Array Element, Enemy Barriers Block LOS)), Compare(Hero Of(Current Array Element), !=, Hero(Sombra))))), Icon String(Plus)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(-0.3, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 1.8, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, Sombra_hud, Last Text ID);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[sombra/init.opy]: Increase Sombra melee damage") {
    event {
        Player Dealt Damage;
        All;
        Sombra;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[sombra/virus.opy]: Sombra Virus Cancel") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait(0.04, Ignore Condition);
        Cancel Primary Action(Event Player);
    }
}

rule ("[sombra/virus.opy]: Target Teammate") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions {
        Set Player Variable(Event Player, Sombra_virus_target, First Of(Sorted Array(Filtered Array(All Living Players(Team Of(Event Player)), And(And(And(And(Compare(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)), <=, 30), Has Spawned(Current Array Element)), Compare(Distance Between(Event Player, Current Array Element), <=, 20)), Compare(Current Array Element, !=, Event Player)), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)))));
        Wait(0.16, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[sombra/virus.opy]: Target Teammate HUD and allow Virus") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        (Event Player).Sombra_virus_target != Null;
    }
    actions {
        "targeting hud"
        Create In-World Text(If-Then-Else(And(Compare((Event Player).Sombra_virus_target, !=, Null), Compare(Ability Cooldown(Event Player, Button(Ability 1)), ==, 0)), Event Player, Null), Custom String(" \n\n\n\n\n\n     ︿\n〈      〉\n     ﹀ "), Add((Event Player).Sombra_virus_target, Vector(0, 0.7, 0)), 2, Do Not Clip, Visible To Position and String, Custom Color(55, 230, 255, 210), Default Visibility);
        Set Player Variable(Event Player, Sombra_targeting_hud, Last Text ID);
        Allow Button(Event Player, Button(Ability 1));
    }
}

rule ("[sombra/virus.opy]: Disallow Virus") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        (Event Player).Sombra_virus_target == Null;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 1));
        Destroy In-World Text((Event Player).Sombra_targeting_hud);
    }
}

rule ("[sombra/virus.opy]: Confirm Target") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable((Event Player).Sombra_virus_target, Sombra_virus_confirmed, True);
    }
}

rule ("[sombra/virus.opy]: Buff Teammate and play effects") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).Sombra_virus_confirmed == True;
    }
    actions {
        Set Player Variable(Event Player, Sombra_virus_confirmed, False);
        Big Message(Event Player, Custom String("HACKED"));
        Set Player Variable(Players On Hero(Hero(Sombra), Team Of(Event Player)), Sombra_virus_target, Null);
        Create In-World Text(All Players(All Teams), Ability Icon String(Hero(Sombra), Button(Ultimate)), Add(Event Player, Vector(0, 2.5, 0)), 2, Clip Against Surfaces, Visible To Position and String, Color(Purple), Default Visibility);
        Set Player Variable(Event Player, Sombra_hack_effect, Last Text ID);
        Set Player Variable(Event Player, Sombra_hack_icon, True);
        Start Heal Over Time(Event Player, Players On Hero(Hero(Sombra), Team Of(Event Player)), 5, 35);
        Play Effect(All Players(All Teams), Good Pickup Effect, Color(Purple), Event Player, 90);
        Play Effect(All Players(All Teams), Ring Explosion, Color(Purple), Add(Event Player, Up), 4);
        Play Effect(All Players(All Teams), Buff Explosion Sound, Color(White), Event Player, 80);
        Modify Player Variable(Event Player, MoveSpeed, Add, 30);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait(5, Ignore Condition);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 30);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Destroy In-World Text((Event Player).Sombra_hack_effect);
        Set Player Variable(Event Player, Sombra_hack_icon, False);
    }
}

rule ("[sombra/heal.opy]: If visiable heal 15m 40 - players *6") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        (Event Player).Sombra_invisible == False;
    }
    actions {
        Start Heal Over Time(Filtered Array(All Living Players(Team Of(Event Player)), And(And(Compare(Distance Between(Event Player, Current Array Element), <=, 15), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS)), Compare(Hero Of(Current Array Element), !=, Hero(Sombra)))), Event Player, 1, Subtract(38, Multiply(Count Of(Filtered Array(All Living Players(Team Of(Event Player)), And(And(Compare(Distance Between(Event Player, Current Array Element), <=, 15), Is In Line of Sight(Event Player, Current Array Element, Enemy Barriers Block LOS)), Compare(Hero Of(Current Array Element), !=, Hero(Sombra))))), 6)));
        Start Heal Over Time(Event Player, Null, 1, Subtract(18, Multiply(Count Of(Filtered Array(All Living Players(Team Of(Event Player)), And(And(Compare(Distance Between(Event Player, Current Array Element), <=, 15), Is In Line of Sight(Event Player, Current Array Element, Enemy Barriers Block LOS)), Compare(Hero Of(Current Array Element), !=, Hero(Sombra))))), 6)));
        Wait(1, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule ("[sombra/heal.opy]: Healing Ring sombra") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        (Event Player).Sombra_invisible == False;
    }
    actions {
        Create Effect(All Players(Team Of(Event Player)), Ring, Color(Purple), Event Player, 15, Visible To Position and Radius);
        Set Player Variable(Event Player, Sombra_healing_ring, Last Created Entity);
        Wait Until(Or(Compare((Event Player).Sombra_invisible, ==, True), Compare(Hero Of(Event Player), !=, Hero(Sombra))), 99999);
        Destroy Effect((Event Player).Sombra_healing_ring);
    }
}

rule ("[sombra/translocator.opy]: Sombra Invis Increase move Speed") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        (Event Player).Sombra_invisible == True;
    }
    actions {
        Modify Player Variable(Event Player, MoveSpeed, Add, 10);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait Until(Compare((Event Player).Sombra_invisible, ==, False), 99999);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 10);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

rule ("[sombra/translocator.opy] Sombra stealth damage cancel count damage") {
    event {
        Player Took Damage;
        All;
        Sombra;
    }
    conditions {
        (Event Player).stealth_timer > 0;
        (Event Player).stealth_timer <= 5;
    }
    actions {
        "eventPlayer.Sombra_invis_damage += eventDamage\nif eventPlayer.Sombra_invis_damage >= 40:"
        Set Status(Event Player, Null, Rooted, 0.001);
        Set Player Variable(Event Player, stealth_timer, 0);
        Set Player Variable(Event Player, Sombra_invisible, False);
    }
}

rule ("[sombra/translocator_cooldown_reset.opy]: When Translocator is used, begin tracking how long Sombra is in stealth") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Sombra);
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        "eventPlayer.Sombra_invis_damage = 0"
        Set Player Variable(Event Player, stealth_timer, 5.5);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999986991104);
        Set Player Variable(Event Player, Sombra_invisible, True);
        Chase Player Variable At Rate(Event Player, stealth_timer, 0, 1, None);
        "Sombra can't break stealth during the cast time of stealth"
        Wait(0.5, Restart When True);
        "Wait until Sombra exits Stealth"
        Wait Until(Or(Or(Or(Or(Or(Or(Or(Or(Is True For Any(Array(Has Status(Event Player, Asleep), Has Status(Event Player, Frozen), Has Status(Event Player, Hacked), Has Status(Event Player, Knocked Down), Has Status(Event Player, Stunned), Has Status(Event Player, Rooted)), Current Array Element), Compare((Event Player).Sombra_invisible, ==, False)), Is Firing Primary(Event Player)), And(Is Button Held(Event Player, Button(Primary Fire)), Not(Is Firing Secondary(Event Player)))), And(Compare(Ability Cooldown(Event Player, Button(Ability 1)), ==, 0), Is Button Held(Event Player, Button(Ability 1)))), Is Button Held(Event Player, Button(Melee))), Is Meleeing(Event Player)), Is Using Ultimate(Event Player)), And(Compare(Value In Array((Event Player).stealth_pvar, 1), ==, 100), Is Button Held(Event Player, Button(Ultimate)))), 5);
        Set Player Variable(Event Player, Sombra_invisible, False);
        Stop Chasing Player Variable(Event Player, stealth_timer);
        Abort If(Compare((Event Player).stealth_timer, <=, 0));
        If(Global.NEGATIVE_STATUS_PREVENTS_REFUND);
            Abort If(Is True For Any(Array(Has Status(Event Player, Asleep), Has Status(Event Player, Frozen), Has Status(Event Player, Hacked), Has Status(Event Player, Knocked Down), Has Status(Event Player, Stunned), Has Status(Event Player, Rooted)), Current Array Element));
        End;
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Ability 2)), >, 0), 1);
        "printLog(\"Current Translocator Cooldown: {0} | Target Translocator Cooldown: {1}\".format(eventPlayer.getAbilityCooldown(Button.ABILITY_2), eventPlayer._stealth_max_cooldown - 5 + (eventPlayer.stealth_timer * (1 - STEALTH_REFUND_FRACTION))))"
        Set Ability Cooldown(Event Player, Button(Ability 2), Add(Subtract(First Of((Event Player).stealth_pvar), 5), Multiply((Event Player).stealth_timer, Subtract(1, Global.STEALTH_REFUND_FRACTION))));
    }
}

rule ("[sombra/translocator_cooldown_reset.opy]: Sombra stealth refund variables") {
    event {
        Ongoing - Global;
    }
    actions {
        Set Global Variable(STEALTH_REFUND_FRACTION, Divide(Workshop Setting Integer(Custom String("Gameplay Settings"), Custom String("Percent of Stealth Timer Remaining Refunded Towards Translocator Cooldown"), 40, 0, 100, 0), 100));
        Set Global Variable(NEGATIVE_STATUS_PREVENTS_REFUND, Workshop Setting Toggle(Custom String("Gameplay Settings"), Custom String("Negative Status Effects Cancelling Stealth Prevents Translocator Cooldown Refund"), True, 1));
        Set Global Variable(MINIMUM_TRANSLOCATOR_COOLDOWN, 4);
    }
}

rule ("[sombra/translocator_cooldown_reset.opy]: Set max stealth cooldown observed") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) == Hero(Sombra);
        Ability Cooldown(Event Player, Button(Ability 2)) > First Of((Event Player).stealth_pvar);
    }
    actions {
        Set Player Variable At Index(Event Player, stealth_pvar, 0, Round To Integer(Ability Cooldown(Event Player, Button(Ability 2)), To Nearest));
    }
}

rule ("[sombra/hack.opy] Hacked healpack bonus speed") {
    event {
        Player Received Healing;
        All;
        All;
    }
    conditions {
        Event Was Health Pack == True;
    }
    actions {
        If(Compare(Hero Of(Healer), ==, Hero(Sombra)));
            Modify Player Variable(Event Player, MoveSpeed, Add, 25);
            Set Move Speed(Event Player, (Event Player).MoveSpeed);
            Wait(2, Ignore Condition);
            Modify Player Variable(Event Player, MoveSpeed, Subtract, 25);
            Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

rule ("[sombra/opportunist.opy] Remove 20% damage increase") {
    event {
        Player Dealt Damage;
        All;
        Sombra;
    }
    conditions {
        Has Status(Victim, Hacked) == True;
    }
    actions {
        Heal(Victim, Null, Divide(Event Damage, 6));
    }
}

rule ("[sombra/hack.opy] Hack target for 2s") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Has Status(Event Player, Hacked) == True;
        Ability Cooldown(Players On Hero(Hero(Sombra), Opposite Team Of(Team Of(Event Player))), Button(Secondary Fire)) != 0;
    }
    actions {
        Set Status(Event Player, Players On Hero(Hero(Sombra), Opposite Team Of(Team Of(Event Player))), Hacked, 2);
    }
}

rule ("[sombra/init.opy]: Clean up Sombra") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Sombra);
    }
    actions {
        Set Player Variable(Event Player, Sombra_virus_target, Null);
        Destroy In-World Text((Event Player).Sombra_targeting_hud);
        Destroy Effect((Event Player).Sombra_healing_ring);
        Destroy In-World Text((Event Player).Sombra_hud);
        Destroy HUD Text(Value In Array((Event Player).Explaination_Hud, 3));
    }
}

rule ("[symmetra/init.opy]: initSymmetra()") {
    event {
        Subroutine;
        initSymmetra;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 125);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 100);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1680);
        Set Player Variable(Event Player, max_health_scaler, 0.75);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[symmetra/init.opy]: Correct Photon projector damage") {
    event {
        Player Dealt Damage;
        All;
        Symmetra;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Subtract(Multiply(Event Damage, 1.05), Event Damage));
    }
}

rule ("[torbjorn/init.opy]: initTorbjorn()") {
    event {
        Subroutine;
        initTorbjorn;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 50);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2142);
        Set Ammo(Event Player, 0, 18);
        Set Max Ammo(Event Player, 0, 18);
        Set Player Variable(Event Player, overhealth_check, False);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[torbjorn/init.opy]: Increase Rivet Gun alternate fire ammo cost") {
    event {
        Ongoing - Each Player;
        All;
        Torbjörn;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Ammo(Event Player, 0, Subtract(Ammo(Event Player, 0), 1));
    }
}

rule ("[torbjorn/init.opy]: Increase Overload overhealth") {
    event {
        Ongoing - Each Player;
        All;
        Torbjörn;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Add Health Pool To Player(Event Player, Health, 11.111, False, True);
        Set Player Variable(Event Player, overload_overhealth, Last Created Health Pool);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999986991104);
        Remove Health Pool From Player((Event Player).overload_overhealth);
    }
}

rule ("[tracer/init.opy]: initTracer()") {
    event {
        Subroutine;
        initTracer;
    }
    actions {
        If(Is Duplicating(Event Player));
            Remove All Health Pools From Player(Event Player);
            Wait(0.15, Ignore Condition);
            "DO NOT REMOVE THIS LINE"
            Set Max Health(Event Player, 100.001);
            "DO NOT REMOVE THIS LINE"
            Wait(0.15, Ignore Condition);
            Set Max Health(Event Player, 100);
            Set Healing Received(Event Player, 0);
            Add Health Pool To Player(Event Player, Health, 1, True, True);
            Add Health Pool To Player(Event Player, Armor, 1, True, True);
            Add Health Pool To Player(Event Player, Shields, 1, True, True);
            Remove All Health Pools From Player(Event Player);
        End;
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1250);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.964);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Start Scaling Player(Event Player, 0.96, True);
        Set Player Variable(Event Player, max_health_scaler, 0.857);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[tracer/init.opy]: Correct melee and Pulse Bomb damage") {
    event {
        Player Dealt Damage;
        All;
        Tracer;
    }
    conditions {
        Array Contains(Array(Button(Melee), Button(Ultimate)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[venture/init.opy]: initVenture()") {
    event {
        Subroutine;
        initVenture;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 300);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 50);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1550);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.429);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Knockback Dealt(Event Player, 80);
        Set Ammo(Event Player, 0, 6);
        Set Max Ammo(Event Player, 0, 6);
        Set Player Variable(Event Player, max_health_scaler, 0.833);
        Start Scaling Player(Event Player, 1.18, True);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[venture/init.opy]: Reduce Headshot damage taken Venture") {
    event {
        Player Took Damage;
        All;
        Venture;
    }
    conditions {
        Event Was Critical Hit == True;
    }
    actions {
        Heal(Event Player, Null, Multiply(Event Damage, 0.3));
    }
}

rule ("[venture/excavator.opy]: Prepare Smart Excavator damage increase") {
    event {
        Ongoing - Each Player;
        All;
        Venture;
    }
    conditions {
        Is Firing Primary(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, is_firing_excavator, True);
        Wait(0.3, Ignore Condition);
        Set Player Variable(Event Player, is_firing_excavator, False);
    }
}

rule ("[venture/excavator.opy]: Correct Smart Excavator damage") {
    event {
        Player Dealt Damage;
        All;
        Venture;
    }
    conditions {
        (Event Player).is_firing_excavator != False;
        Is Using Ability 1(Event Player) == False;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.8), Event Damage), First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, is_firing_excavator, False);
    }
}

rule ("[venture/drill_dash.opy]: Correct Drill Dash damage") {
    event {
        Player Dealt Damage;
        All;
        Venture;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.444), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[venture/clobber.opy]: Correct Venture melee damage") {
    event {
        Player Dealt Damage;
        All;
        Venture;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        "damage(victim, attacker, ((eventDamage/eventPlayer._base_damage_scalar) * (ADJ_VENTURE_CLOBBER_DAMAGE / OW2_VENTURE_CLOBBER_DAMAGE) - eventDamage)/eventPlayer._base_damage_scalar)"
        Set Player Variable(Event Player, clobber_cooldown_accelerator, Ability Cooldown(Event Player, Button(Ability 1)));
        Set Ability Cooldown(Event Player, Button(Ability 1), Subtract((Event Player).clobber_cooldown_accelerator, 0.5));
    }
}

rule ("[venture/burrow.opy]: Burrow speed decrease and dash cooldown 0") {
    event {
        Ongoing - Each Player;
        All;
        Venture;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait Until(Is On Ground(Event Player), 7);
        Wait(0.6, Abort When False);
        If(And(Compare(Ability Cooldown(Event Player, Button(Secondary Fire)), !=, 0), Not(Is Firing Secondary(Event Player))));
            Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
        End;
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 70);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait Until(Not(Is Using Ability 1(Event Player)), 99999);
        Modify Player Variable(Event Player, MoveSpeed, Add, 70);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        If(And(Compare(Ability Cooldown(Event Player, Button(Secondary Fire)), !=, 0), Not(Is Firing Secondary(Event Player))));
            Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
    }
}

rule ("[venture/burrow.opy]: Burrow speed increase when dashing") {
    event {
        Ongoing - Each Player;
        All;
        Venture;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Modify Player Variable(Event Player, MoveSpeed, Add, 110);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait Until(Not(Is Firing Secondary(Event Player)), 99999);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 110);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
    }
}

rule ("[venture/burrow.opy]: Correct Burrow damage") {
    event {
        Player Dealt Damage;
        All;
        Venture;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.55), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[venture/burrow.opy]: Burrow Knockup") {
    event {
        Player Dealt Damage;
        All;
        Venture;
    }
    conditions {
        Event Ability == Button(Ability 1);
    }
    actions {
        Apply Impulse(Victim, Up, 10, To World, Cancel Contrary Motion);
        Set Status(Event Player, Null, Rooted, 0.3);
    }
}

rule ("[venture/tectonic_shock.opy]: Tectonic Shock logic") {
    event {
        Player Dealt Damage;
        All;
        Venture;
    }
    conditions {
        Event Ability == Button(Ultimate);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.73), Event Damage), First Of((Event Player).macro_pvar)));
        Apply Impulse(Victim, Up, 8, To World, Cancel Contrary Motion);
        Set Status(Event Player, Null, Rooted, 0.3);
    }
}

rule ("[widowmaker/init.opy]: initWidowmaker()") {
    event {
        Subroutine;
        initWidowmaker;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 165);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1540);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[widowmaker/init.opy]: Reduce Scoped Shot damage") {
    event {
        Ongoing - Each Player;
        All;
        Widowmaker;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 87.5);
        Wait Until(Not(Is Firing Secondary(Event Player)), 999999986991104);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[widowmaker/weapon.opy] Widowmaker scope glint") {
    event {
        Ongoing - Each Player;
        All;
        Widowmaker;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        "Without aiming at widow check"
        Create Effect(Filtered Array(All Players(Opposite Team Of(Team Of(Event Player))), And(Compare(Distance Between(Event Player, Current Array Element), >=, 3), Is In View Angle(Event Player, Eye Position(Current Array Element), 15))), Good Aura, Color(White), Eye Position(Event Player), 0.45, Visible To Position and Radius);
        Set Player Variable(Event Player, WidowScopeGlint_effect, Last Created Entity);
        Wait Until(Not(Is Firing Secondary(Event Player)), 100000000);
        Destroy Effect((Event Player).WidowScopeGlint_effect);
    }
}

rule ("[winston/init.opy]: initWinston()") {
    event {
        Subroutine;
        initWinston;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 253.846);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 100);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Add Health Pool To Player(Event Player, Health, 146.154, True, True);
        Set Player Variable At Index(Event Player, primal_pvar, 2, Last Created Health Pool);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1650);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.821);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, max_health_scaler, 0.923);
        Set Max Ammo(Event Player, 0, 100);
        Set Ammo(Event Player, 0, 100);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[winston/primal.opy]: Remove bonus Primal Rage health") {
    event {
        Ongoing - Each Player;
        All;
        Winston;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Remove Health Pool From Player(Value In Array((Event Player).primal_pvar, 2));
        Wait(9.904, Ignore Condition);
        Set Player Variable At Index(Event Player, primal_pvar, 0, Health Of Type(Event Player, Health));
        Set Player Variable At Index(Event Player, primal_pvar, 1, Health Of Type(Event Player, Armor));
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        Add Health Pool To Player(Event Player, Health, 146.154, True, True);
        Set Player Variable At Index(Event Player, primal_pvar, 2, Last Created Health Pool);
        Set Player Health(Event Player, Add(Min(400, First Of((Event Player).primal_pvar)), Value In Array((Event Player).primal_pvar, 1)));
    }
}

rule ("[winston/primal.opy]: Reduce Primal Rage damage") {
    event {
        Ongoing - Each Player;
        All;
        Winston;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
    }
    actions {
        Set Damage Dealt(Event Player, 80);
        Wait Until(Not(Is Using Ultimate(Event Player)), 999999986991104);
        "revert damage back after Primal Rage concludes"
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
    }
}

rule ("[winston/primal.opy]: Correct Jump Pack damage during Primal Rage") {
    event {
        Player Dealt Damage;
        All;
        Winston;
    }
    conditions {
        Is Using Ultimate(Event Player) == True;
        Event Ability == Button(Ability 1);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, 0.8), Event Damage), 0.8));
    }
}

rule ("[winston/init.opy]: Correct Jump Pack, Melee, Primal Rage damage") {
    event {
        Player Dealt Damage;
        All;
        Winston;
    }
    conditions {
        Is Using Ultimate(Event Player) == False;
        Array Contains(Array(Button(Ability 1), Button(Melee), Button(Secondary Fire)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[wreckingball/init.opy]: initWreckingBall()") {
    event {
        Subroutine;
        initWreckingBall;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 475);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 75);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1540);
        Call Subroutine(removeTankPassive);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.788);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Ammo(Event Player, 0, 80);
        Set Max Ammo(Event Player, 0, 80);
        Set Player Variable(Event Player, max_health_scaler, 0.5);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[wreckingball/grapple.opy]: Force Grappling Hook cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Wrecking Ball;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Secondary Fire)), >, 0), 999999986991104);
        If(Compare(Ability Cooldown(Event Player, Button(Secondary Fire)), <=, 1));
            Set Ability Cooldown(Event Player, Button(Secondary Fire), 1.92);
    }
}

rule ("[wreckingball/grapple.opy]: Increase Fireball impact damage") {
    event {
        Player Dealt Damage;
        All;
        Wrecking Ball;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.833, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[wreckingball/shields.opy]: Remove Adaptive Shields overhealth transfer") {
    event {
        Ongoing - Each Player;
        All;
        Wrecking Ball;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 2));
        Set Ability 2 Enabled(Event Player, False);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999986991104);
        Call Subroutine(enableAllAbilities);
        Allow Button(Event Player, Button(Ability 2));
    }
}

rule ("[wreckingball/shields.opy]: Increase Adaptive Shield base overhealth gain") {
    event {
        Ongoing - Each Player;
        All;
        Wrecking Ball;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Add Health Pool To Player(Event Player, Health, 100, False, True);
        Set Player Variable(Event Player, adaptive_overhealth_id, Last Created Health Pool);
        Wait Until(Not(Is Using Ability 2(Event Player)), 999999986991104);
        Remove Health Pool From Player((Event Player).adaptive_overhealth_id);
        Set Player Variable(Event Player, adaptive_overhealth_id, Null);
    }
}

rule ("[wreckingball/piledriver.opy]: Increase Piledriver / Quadcannon damage") {
    event {
        Player Dealt Damage;
        All;
        Wrecking Ball;
    }
    conditions {
        Array Contains(Array(Button(Primary Fire), Button(Crouch)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.8, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[wreckingball/init.opy]: Correct fireball, melee damage") {
    event {
        Player Dealt Damage;
        All;
        Wrecking Ball;
    }
    conditions {
        Array Contains(Array(Button(Ability 1), Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[zarya/init.opy]: initZarya()") {
    event {
        Subroutine;
        initZarya;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 200);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2100);
        Call Subroutine(removeTankPassive);
        Set Player Variable(Event Player, self_bubble_cooldown, 0);
        Set Player Variable(Event Player, ally_bubble_cooldown, 0);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.895);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, max_health_scaler, 1);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[zarya/self_bubble.opy]: showSelfBubbleCD()") {
    event {
        Subroutine;
        showSelfBubbleCD;
    }
    actions {
        If(Compare((Event Player).self_bubble_cd_text, ==, Null));
            Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).self_bubble_cooldown, Up)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(1.99, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.9, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
            Set Player Variable(Event Player, self_bubble_cd_text, Last Text ID);
            Create In-World Text(Event Player, Custom String("{0} {1}", Round To Integer((Event Player).self_bubble_cooldown, Up), Ability Icon String(Hero(Zarya), Button(Ability 1))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(0.2, World Vector Of(Right, Event Player, Rotation)), Multiply(-0.36, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 1.3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
            Set Player Variable(Event Player, zarya_self_bubble_centre_hud, Last Text ID);
        End;
    }
}

rule ("[zarya/self_bubble.opy]: hideSelfBubbleCD()") {
    event {
        Subroutine;
        hideSelfBubbleCD;
    }
    actions {
        Destroy In-World Text((Event Player).self_bubble_cd_text);
        Set Player Variable(Event Player, self_bubble_cd_text, Null);
        Destroy In-World Text((Event Player).zarya_self_bubble_centre_hud);
        Set Player Variable(Event Player, zarya_self_bubble_centre_hud, Null);
    }
}

rule ("[zarya/self_bubble.opy]: OW1 zarya self bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
        (Event Player).HeroCoreActive == Null;
    }
    actions {
        Disallow Button(Event Player, Button(Ability 1));
        Set Ability Charge(Event Player, Button(Ability 1), 2);
        "wait bubble duration"
        Wait Until(Not(Is Using Ability 1(Event Player)), 2);
        Set Ability 1 Enabled(Event Player, False);
        Set Player Variable(Event Player, self_bubble_cooldown, 9);
        Allow Button(Event Player, Button(Ability 1));
        Chase Player Variable At Rate(Event Player, self_bubble_cooldown, 0, 1, None);
    }
}

rule ("[zarya/self_bubble.opy]: Disable self bubble if on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).self_bubble_cooldown > 0;
        (Event Player).HeroCoreActive == Null;
    }
    actions {
        Set Ability 1 Enabled(Event Player, False);
        Call Subroutine(showSelfBubbleCD);
    }
}

rule ("[zarya/self_bubble.opy]: Enable self bubble if not on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).hero_setup == Hero(Zarya);
        (Event Player).self_bubble_cooldown <= 0;
        (Event Player).HeroCoreActive == Null;
    }
    actions {
        Set Ability 1 Enabled(Event Player, True);
        Call Subroutine(hideSelfBubbleCD);
    }
}

rule ("[zarya/ally_bubble.opy]: showAllyBubbleCD()") {
    event {
        Subroutine;
        showAllyBubbleCD;
    }
    actions {
        If(Compare((Event Player).ally_bubble_cd_text, ==, Null));
            Create In-World Text(Event Player, Custom String("{0}", Round To Integer((Event Player).ally_bubble_cooldown, Up)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(2.3, World Vector Of(Right, Event Player, Rotation)), Multiply(-1.9, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
            Set Player Variable(Event Player, ally_bubble_cd_text, Last Text ID);
            Create In-World Text(Event Player, Custom String("{0} {1}", Round To Integer((Event Player).ally_bubble_cooldown, Up), Ability Icon String(Hero(Zarya), Button(Ability 2))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(0.2, World Vector Of(Right, Event Player, Rotation)), Multiply(-0.48, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 1.3, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
            Set Player Variable(Event Player, zarya_ally_bubble_centre_hud, Last Text ID);
        End;
    }
}

rule ("[zarya/ally_bubble.opy]: hideAllyBubbleCD()") {
    event {
        Subroutine;
        hideAllyBubbleCD;
    }
    actions {
        Destroy In-World Text((Event Player).ally_bubble_cd_text);
        Set Player Variable(Event Player, ally_bubble_cd_text, Null);
        Destroy In-World Text((Event Player).zarya_ally_bubble_centre_hud);
        Set Player Variable(Event Player, zarya_ally_bubble_centre_hud, Null);
    }
}

rule ("[zarya/ally_bubble.opy]: OW1 zarya ally bubble cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        Is Using Ability 2(Event Player) == True;
    }
    actions {
        Set Ability Charge(Event Player, Button(Ability 2), 2);
        Set Ability 2 Enabled(Event Player, False);
        "waitUntil(not eventPlayer.isUsingAbility2(), ADJ_ZARYA_BUBBLE_DURATION) # wait bubble duration\nwait bubble duration"
        Wait(2, Ignore Condition);
        Set Player Variable(Event Player, ally_bubble_cooldown, 7);
        Chase Player Variable At Rate(Event Player, ally_bubble_cooldown, 0, 1, None);
    }
}

rule ("[zarya/ally_bubble.opy]: Disable ally bubble if on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).ally_bubble_cooldown > 0;
    }
    actions {
        Set Ability 2 Enabled(Event Player, False);
        Call Subroutine(showAllyBubbleCD);
    }
}

rule ("[zarya/ally_bubble.opy]: Enable ally bubble if not on cooldown") {
    event {
        Ongoing - Each Player;
        All;
        Zarya;
    }
    conditions {
        (Event Player).ally_bubble_cooldown <= 0;
    }
    actions {
        Set Ability 2 Enabled(Event Player, True);
        Call Subroutine(hideAllyBubbleCD);
    }
}

rule ("[zarya/init.opy]: Clean up Zarya") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Zarya);
    }
    actions {
        Call Subroutine(hideSelfBubbleCD);
        Call Subroutine(hideAllyBubbleCD);
    }
}

rule ("[zarya/init.opy]: Increase Particle Cannon alternate fire damage") {
    event {
        Player Dealt Damage;
        All;
        Zarya;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 0.909), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[zarya/init.opy]: Correct Zarya Melee damage") {
    event {
        Player Dealt Damage;
        All;
        Zarya;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[zenyatta/init.opy]: initZenyatta()") {
    event {
        Subroutine;
        initZenyatta;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 50);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 150);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2200);
        Set Ammo(Event Player, 0, 20);
        Set Max Ammo(Event Player, 0, 20);
        Set Knockback Dealt(Event Player, 4);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[echo/copy.opy] Echo new ultimate") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Button Held(Event Player, Button(Ultimate)) == True;
        (Event Player).hero_setup == Hero(Echo);
    }
    actions {
        If(And(Is Alive(Event Player), Compare(Ultimate Charge Percent(Event Player), ==, 100)));
            Set Player Variable(All Players(Team Of(Event Player)), Echo_Copy, True);
            Start Forcing Player To Be Hero(Event Player, Hero Of(First Of(Sorted Array(Filtered Array(All Living Players(Opposite Team Of(Team Of(Event Player))), And(And(And(And(Compare(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element)), <=, 19), Has Spawned(Current Array Element)), Compare(Distance Between(Event Player, Current Array Element), <=, 40)), Compare(Current Array Element, !=, Players On Hero(Hero(Echo), All Teams))), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Current Array Element))))));
            If(Compare(Hero Of(Event Player), !=, Hero(Echo)));
                Set Status(Event Player, Null, Frozen, 1);
                Set Status(Event Player, Null, Phased Out, 1);
                Wait(1, Ignore Condition);
                Set Ultimate Charge(Event Player, 95);
                Call Subroutine(EchoCopy);
                Wait Until(Is Dead(Event Player), 16);
                Destroy Progress Bar In-World Text((Event Player).EchoHUD);
                Stop Chasing Player Variable(Event Player, EchoUltSeconds);
                Start Forcing Player To Be Hero(Event Player, Hero(Echo));
                Stop Forcing Player To Be Hero(Event Player);
                Set Player Variable(All Players(Team Of(Event Player)), Echo_Copy, False);
    }
}

rule ("[sombra/emp.opy]: Heal damage EMP does and prevent extra hack time from triggering") {
    event {
        Player Dealt Damage;
        All;
        Sombra;
    }
    conditions {
        Event Ability == Button(Ultimate);
    }
    actions {
        Heal(Victim, Null, Event Damage);
        Wait(3, Ignore Condition);
        Clear Status(Victim, Hacked);
    }
}

rule ("[mcree/combat_roll.opy]: remove 30% damage reducion from roll") {
    event {
        Ongoing - Each Player;
        All;
        Cassidy;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Modify Player Variable(Event Player, DamageRecieved, Add, 30);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
        Wait Until(Not(Is Using Ability 1(Event Player)), 3);
        Modify Player Variable(Event Player, DamageRecieved, Subtract, 30);
        Set Damage Received(Event Player, (Event Player).DamageRecieved);
    }
}

disabled rule ("[mei/init.opy]: initMei()") {
    event {
        Subroutine;
        initMei;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 250);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1610);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.882);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Set Player Variable(Event Player, max_health_scaler, 1.1);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

rule ("[echo/ultimate.opy]: Sub for HUD") {
    event {
        Subroutine;
        EchoCopy;
    }
    actions {
        Set Player Variable(Event Player, EchoUltSeconds, 100);
        Chase Player Variable At Rate(Event Player, EchoUltSeconds, 0, 6.25, Destination and Rate);
        Create Progress Bar In-World Text(Event Player, (Event Player).EchoUltSeconds, Custom String("{0} {1}", Ability Icon String(Hero(Echo), Button(Ultimate)), Round To Integer(Divide((Event Player).EchoUltSeconds, 6.25), Up)), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Add(Multiply(-1, World Vector Of(Right, Event Player, Rotation)), Multiply(-0.25, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90)))), Multiply(3, Facing Direction Of(Event Player)))))), 0.75, Do Not Clip, Color(White), Color(White), Visible To Position Values and Color, Default Visibility);
        Set Player Variable(Event Player, EchoHUD, Last Text ID);
    }
}

rule ("[echo/init.opy]: Clean up Echo") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Echo);
    }
    actions {
        Destroy Progress Bar In-World Text((Event Player).EchoHUD);
        Stop Chasing Player Variable(Event Player, EchoUltSeconds);
        Set Player Variable(All Players(Team Of(Event Player)), Echo_Copy, False);
        Set Player Variable(Event Player, EchoHUD, Null);
        Set Player Variable(Event Player, EchoUltSeconds, Null);
    }
}

rule ("[ana/nade.opy]: Increase Biotic Grenade damage") {
    event {
        Player Dealt Damage;
        All;
        Ana;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.8, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[soldier/init.opy]: Increase Heavy Pulse Rifle damage") {
    event {
        Player Dealt Damage;
        All;
        Soldier: 76;
    }
    conditions {
        Event Ability == Button(Primary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(Divide(Event Damage, First Of((Event Player).macro_pvar)), 1.053), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

disabled rule ("Mercy track ult charge that would have been gained from custom abilities") {
    event {
        Player Dealt Healing;
        All;
        Mercy;
    }
    conditions {
        Event Ability != Button(Primary Fire);
        Healee != Event Player;
        Is Game In Progress == True;
        Ultimate Charge Percent(Event Player) < 100;
    }
    actions {
        Modify Player Variable(Event Player, MercyUltTrack, Add, Event Healing);
    }
}

disabled rule ("Mercy ult add") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).MercyUltTrack >= Divide(Value In Array((Event Player).ult_charge_pvar, 1), 100);
    }
    actions {
        Set Ultimate Charge(Event Player, Add(Ultimate Charge Percent(Event Player), Round To Integer(Divide((Event Player).MercyUltTrack, Divide(Value In Array((Event Player).ult_charge_pvar, 1), 100)), Down)));
        Modify Player Variable(Event Player, MercyUltTrack, Subtract, Multiply(Round To Integer(Divide((Event Player).MercyUltTrack, Divide(Value In Array((Event Player).ult_charge_pvar, 1), 100)), Down), Divide(Value In Array((Event Player).ult_charge_pvar, 1), 100)));
        Wait(0.2, Ignore Condition);
    }
}

rule ("Mercy rez HUD") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Ultimate Charge Percent(Event Player) >= 100;
        (Event Player).RezHUD == Null;
    }
    actions {
        Create HUD Text(If-Then-Else(And(Is Alive(Event Player), Compare(Count Of(Remove From Array(Players Within Radius(Event Player, 5.5, Team Of(Event Player), Surfaces), All Living Players(All Teams))), >, 0)), Event Player, Null), Custom String("Resurrect {0}", Hero Icon String(Hero Of(First Of(Sorted Array(Remove From Array(Players Within Radius(Event Player, 5.5, Team Of(Event Player), Surfaces), All Living Players(Team Of(Event Player))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Event Player, Current Array Element))))))), Null, Null, Top, 0, Color(Yellow), Null, Null, Visible To and String, Default Visibility);
        Set Player Variable(Event Player, RezHUD, Last Text ID);
    }
}

rule ("Mercy imbue target icon") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        (Event Player).ImbueTargetIcon == Null;
    }
    actions {
        Create In-World Text(If-Then-Else(And(Compare(First Of(Sorted Array(Filtered Array(Players Within Radius(Event Player, 20.5, Team Of(Event Player), Surfaces And Enemy Barriers), And(And(Is In View Angle(Event Player, Position Of(Current Array Element), Add(2, Divide(60, Distance Between(Event Player, Current Array Element)))), Compare(Current Array Element, !=, Event Player)), Is Alive(Current Array Element))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element))))), !=, Null), Not(Is In Alternate Form(Event Player))), Event Player, Null), Custom String("+"), Add(Eye Position(First Of(Sorted Array(Filtered Array(Players Within Radius(Event Player, 20.5, Team Of(Event Player), Surfaces And Enemy Barriers), And(And(Is In View Angle(Event Player, Position Of(Current Array Element), Add(2.5, Divide(60, Distance Between(Event Player, Current Array Element)))), Compare(Current Array Element, !=, Event Player)), Is Alive(Current Array Element))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element)))))), Vector(0, 1, 0)), 2, Do Not Clip, Visible To Position String and Color, If-Then-Else(Is Firing Secondary(Event Player), Color(Blue), Color(Yellow)), Default Visibility);
        Set Player Variable(Event Player, ImbueTargetIcon, Last Text ID);
    }
}

rule ("Mercy imbue") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Is In Alternate Form(Event Player) == False;
        Is Button Held(Event Player, Button(Ability 2)) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        First Of(Sorted Array(Filtered Array(Remove From Array(Remove From Array(Players Within Radius(Event Player, 20.5, Team Of(Event Player), Surfaces And Enemy Barriers), Event Player), All Dead Players(Team Of(Event Player))), Is In View Angle(Event Player, Position Of(Current Array Element), Add(2.5, Divide(60, Distance Between(Event Player, Current Array Element))))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element))))) != Null;
    }
    actions {
        "Vanilla rez cd hero setting needs to be changed if cooldown is changed so icon matches"
        Set Ability Cooldown(Event Player, Button(Ability 2), 15);
        Set Ability 2 Enabled(Event Player, True);
        Destroy In-World Text((Event Player).ImbueTargetIcon);
        Set Player Variable(Event Player, ImbueTargetIcon, Null);
        Set Player Variable(Event Player, ImbueSecondary, If-Then-Else(Is Firing Secondary(Event Player), True, False));
        "Set target"
        Set Player Variable(Event Player, ImbueTarget, First Of(Sorted Array(Filtered Array(Players Within Radius(Event Player, 20.5, Team Of(Event Player), Surfaces And Enemy Barriers), And(And(Is In View Angle(Event Player, Position Of(Current Array Element), Add(2.5, Divide(60, Distance Between(Event Player, Current Array Element)))), Compare(Current Array Element, !=, Event Player)), Is Alive(Current Array Element))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Position Of(Event Player), Position Of(Current Array Element))))));
        "Duration"
        Set Player Variable(Event Player, ImbueDuration, 5);
        Chase Player Variable At Rate(Event Player, ImbueDuration, 0, 1, Destination and Rate);
        Play Effect(All Players(All Teams), Ring Explosion Sound, Color(White), Event Player, 80);
        Create Beam Effect(If-Then-Else(Compare((Event Player).ImbueTarget, !=, Null), All Players(All Teams), Null), Bad Beam, Event Player, (Event Player).ImbueTarget, If-Then-Else(Is Firing Secondary(Event Player), Color(Blue), Color(Yellow)), Visible To Position and Radius);
        Set Player Variable(Event Player, ImbueBeam, Last Created Entity);
        Play Effect(All Players(All Teams), Ring Explosion, If-Then-Else((Event Player).ImbueSecondary, If-Then-Else(Compare(Team Of(Event Player), ==, Team 1), Color(Team 1), Color(Team 2)), Color(Yellow)), (Event Player).ImbueTarget, 8);
        "Destroy beam and sparkle"
        Wait(0.2, Ignore Condition);
        Destroy Effect((Event Player).ImbueBeam);
        "Wait = cooldown - 0.3 (stops vanilla rez being usable the frame cooldown ends); rez cooldown needs to be changed in hero settings if cooldown is changed so icon matches"
        Wait Until(Or(Or(Is Dead(Event Player), Compare(Ability Cooldown(Event Player, Button(Ability 2)), <=, 0.3)), Compare(Hero Of(Event Player), !=, Hero(Mercy))), 14.7);
        Abort If(Compare(Hero Of(Event Player), !=, Hero(Mercy)));
        Set Ability 2 Enabled(Event Player, False);
    }
}

rule ("Mercy imbue AOE") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        (Event Player).ImbueDuration > 0;
        (Event Player).ImbueTarget != Null;
    }
    actions {
        "Aura visuals"
        Create Effect(All Players(If-Then-Else((Event Player).ImbueSecondary, All Teams, Team Of(Event Player))), Ring, If-Then-Else((Event Player).ImbueSecondary, If-Then-Else(Compare(Team Of(Event Player), ==, Team 1), Color(Team 1), Color(Team 2)), Color(Yellow)), (Event Player).ImbueTarget, If-Then-Else((Event Player).ImbueSecondary, 8, 10), Visible To Position and Radius);
        Set Player Variable(Event Player, ImbueAOERing, Last Created Entity);
        If((Event Player).ImbueSecondary);
            Create Effect(All Players(Team Of(Event Player)), Energy Sound, Color(White), (Event Player).ImbueTarget, 80, Visible To Position and Radius);
        Else;
            Create Effect(All Players(Team Of(Event Player)), Sparkles Sound, Color(White), (Event Player).ImbueTarget, 90, Visible To Position and Radius);
        End;
        Set Player Variable(Event Player, ImbueAOESound, Last Created Entity);
        "AoE"
        While(And(Is Alive((Event Player).ImbueTarget), Compare((Event Player).ImbueDuration, >, 0)));
            "20 dps for 3 seconds"
            If((Event Player).ImbueSecondary);
                Start Damage Over Time(Players Within Radius((Event Player).ImbueTarget, 8, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers), Event Player, 0.5, 20);
            Else;
                Heal(Players Within Radius((Event Player).ImbueTarget, 10, Team Of(Event Player), Surfaces And Enemy Barriers), Event Player, 7.5);
            End;
            Wait Until(Or(Is Dead((Event Player).ImbueTarget), Compare((Event Player).ImbueDuration, ==, 0)), 0.5);
        End;
        Destroy Effect((Event Player).ImbueAOERing);
        Destroy Effect((Event Player).ImbueAOESound);
        Stop Chasing Player Variable(Event Player, ImbueDuration);
        Set Player Variable(Event Player, ImbueTarget, Null);
    }
}

rule ("Mercy rez") {
    event {
        Ongoing - Each Player;
        All;
        Mercy;
    }
    conditions {
        Ultimate Charge Percent(Event Player) == 100;
        Is Button Held(Event Player, Button(Ultimate)) == True;
        Is Alive(Event Player) == True;
        Count Of(Remove From Array(Players Within Radius(Event Player, 5.5, Team Of(Event Player), Surfaces), All Living Players(All Teams))) > 0;
    }
    actions {
        Set Player Variable(Event Player, MercyUltTrack, 0);
        Set Ultimate Charge(Event Player, 0);
        Destroy HUD Text((Event Player).RezHUD);
        Set Player Variable(Event Player, RezHUD, Null);
        Communicate(Event Player, Hello);
        "Set rez target"
        Set Player Variable(Event Player, RezTarget, First Of(Sorted Array(Remove From Array(Players Within Radius(Event Player, 5.5, Team Of(Event Player), Surfaces), All Living Players(Team Of(Event Player))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Event Player, Current Array Element)))));
        "Show rez in killfeed (skews mercy's elims and target's deaths by 1, but whatever)"
        Resurrect((Event Player).RezTarget);
        Set Status((Event Player).RezTarget, Null, Phased Out, 0.1);
        Set Player Health((Event Player).RezTarget, 0.01);
        Kill((Event Player).RezTarget, Event Player);
        Wait(0.016, Ignore Condition);
        "Real rez"
        Resurrect((Event Player).RezTarget);
        Set Status((Event Player).RezTarget, Null, Phased Out, 2.25);
        Set Status((Event Player).RezTarget, Null, Frozen, 1.5);
        Set Player Health((Event Player).RezTarget, Max Health((Event Player).RezTarget));
        Play Effect(All Players(All Teams), Good Pickup Effect, Color(Yellow), (Event Player).RezTarget, 5);
        Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), (Event Player).RezTarget, 110);
        "0.75s recovery"
        Disallow Button(Event Player, Button(Primary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Disallow Button(Event Player, Button(Melee));
        Disallow Button(Event Player, Button(Ability 2));
        "Disable target abilities for 0.75s movement window in invuln"
        Disallow Button((Event Player).RezTarget, Button(Ability 1));
        Disallow Button((Event Player).RezTarget, Button(Ability 2));
        Disallow Button((Event Player).RezTarget, Button(Primary Fire));
        Disallow Button((Event Player).RezTarget, Button(Secondary Fire));
        Disallow Button((Event Player).RezTarget, Button(Ultimate));
        Disallow Button((Event Player).RezTarget, Button(Melee));
        "End recovery"
        Wait(0.5, Ignore Condition);
        Allow Button(Event Player, Button(Primary Fire));
        Allow Button(Event Player, Button(Secondary Fire));
        Allow Button(Event Player, Button(Melee));
        Allow Button(Event Player, Button(Ability 2));
        "End of target invuln, enable abilities"
        Wait(1.75, Ignore Condition);
        Allow Button((Event Player).RezTarget, Button(Ability 1));
        Allow Button((Event Player).RezTarget, Button(Ability 2));
        Allow Button((Event Player).RezTarget, Button(Primary Fire));
        Allow Button((Event Player).RezTarget, Button(Secondary Fire));
        Allow Button((Event Player).RezTarget, Button(Ultimate));
        Allow Button((Event Player).RezTarget, Button(Melee));
        Set Player Variable(Event Player, RezTarget, Null);
    }
}

rule ("Mercy swap hero") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Hero Of(Event Player) != Hero(Mercy);
        Has Spawned(Event Player) == True;
    }
    actions {
        Allow Button(Event Player, Button(Ultimate));
        Destroy HUD Text((Event Player).RezHUD);
        Destroy In-World Text((Event Player).ImbueTargetIcon);
        Set Player Variable(Event Player, MercyUltTrack, 0);
        Destroy Effect((Event Player).ImbueAOERing);
        Destroy Effect((Event Player).ImbueAOESound);
        Destroy Effect((Event Player).ImbueBeam);
        Destroy Effect((Event Player).ImbueSparkle);
        Set Player Variable(Event Player, ImbueTargetIcon, Null);
        Set Player Variable(Event Player, RezHUD, Null);
        Set Player Variable(Event Player, ImbueTarget, Null);
    }
}

rule ("Overrun logic") {
    event {
        Ongoing - Each Player;
        All;
        Mauga;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Stop Chasing Player Variable(Event Player, MaugaOverHP);
        Modify Player Variable(Event Player, MoveSpeed, Subtract, 15);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        Wait(0.32, Ignore Condition);
        Wait Until(Or(Or(Not(Is Using Ability 1(Event Player)), Is Button Held(Event Player, Button(Primary Fire))), Is Button Held(Event Player, Button(Jump))), 99999);
        Modify Player Variable(Event Player, MoveSpeed, Add, 15);
        Set Move Speed(Event Player, (Event Player).MoveSpeed);
        If(Or(Is Button Held(Event Player, Button(Primary Fire)), Is Button Held(Event Player, Button(Jump))));
            Wait Until(Not(Is Using Ability 1(Event Player)), 2.6);
            Set Ability Cooldown(Event Player, Button(Ability 1), 6);
    }
}

rule ("Overrun subtract damage taken") {
    event {
        Player Took Damage;
        All;
        Mauga;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Modify Player Variable(Event Player, MaugaOverHP, Subtract, Multiply(Event Damage, 2));
        If(Is Using Ability 2(Event Player));
            Modify Player Variable(Event Player, MaugaOverHP, Subtract, Multiply(Event Damage, 1.4));
    }
}

rule ("Overrun break shield") {
    event {
        Ongoing - Each Player;
        All;
        Mauga;
    }
    conditions {
        (Event Player).MaugaOverHP <= 0;
    }
    actions {
        If(Is Using Ability 1(Event Player));
            Press Button(Event Player, Button(Ability 1));
        End;
        Set Status(Event Player, Null, Stunned, 0.2);
        Wait(0.5, Ignore Condition);
        Set Ability 1 Enabled(Event Player, False);
        Set Ability Cooldown(Event Player, Button(Ability 1), 8);
        Set Player Variable(Event Player, MaugaOverHP, 0);
        Wait Until(Compare(Ability Cooldown(Event Player, Button(Ability 1)), ==, 0), 8);
        Set Ability 1 Enabled(Event Player, True);
    }
}

rule ("Overrun recharge shield") {
    event {
        Ongoing - Each Player;
        All;
        Mauga;
    }
    conditions {
        (Event Player).MaugaOverHP != 200;
        Is Using Ability 1(Event Player) == False;
    }
    actions {
        If(Not(Is Using Ability 1(Event Player)));
            Wait(2, Abort When False);
            Chase Player Variable At Rate(Event Player, MaugaOverHP, 200, 50, Destination and Rate);
    }
}

rule ("Overrun check for stomp") {
    event {
        Ongoing - Each Player;
        All;
        Mauga;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Wait(3, Abort When False);
        Wait Until(Not(Is Using Ability 1(Event Player)), 1);
        Set Ability Cooldown(Event Player, Button(Ability 1), 6);
    }
}

rule ("[sombra/translocator.opy] Sombra stealth self cancel") {
    event {
        Ongoing - Each Player;
        All;
        Sombra;
    }
    conditions {
        (Event Player).stealth_timer <= 5;
        (Event Player).stealth_timer > 0;
        Is Button Held(Event Player, Button(Ability 2)) == True;
        (Event Player).Sombra_invisible == True;
    }
    actions {
        Set Status(Event Player, Null, Rooted, 0.001);
        Set Player Variable(Event Player, Sombra_invisible, False);
        "printLog(\"Current Translocator Cooldown: {0} | Target Translocator Cooldown: {1}\".format(eventPlayer.getAbilityCooldown(Button.ABILITY_2), eventPlayer._stealth_max_cooldown - 5 + (eventPlayer.stealth_timer * (1 - STEALTH_REFUND_FRACTION))))"
        Set Ability Cooldown(Event Player, Button(Ability 2), Add(Subtract(First Of((Event Player).stealth_pvar), 5), Multiply((Event Player).stealth_timer, Subtract(1, Global.STEALTH_REFUND_FRACTION))));
        Set Player Variable(Event Player, stealth_timer, 0);
    }
}

rule ("destroy all huds and effects between rounds") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Is Between Rounds == True;
    }
    actions {
        Destroy All Progress Bar In-World Text;
        Destroy All In-World Text;
        Destroy All Effects;
        Destroy All Progress Bar HUD Text;
        Destroy All HUD Text;
    }
}

rule ("Doomfist punch track") {
    event {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions {
        Is Firing Secondary(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, DoomPunchTrack, False);
        Wait Until(Or(Not(Is Button Held(Event Player, Button(Secondary Fire))), Not(Is Firing Secondary(Event Player))), 1.6);
        Set Player Variable(Event Player, DoomPunchTrack, True);
    }
}

rule ("Reinhardt charge track") {
    event {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions {
        Is Using Ability 1(Event Player) == True;
    }
    actions {
        Set Player Variable(Event Player, ReinChargeTrack, True);
        Wait Until(Not(Is Using Ability 1(Event Player)), 5);
        Set Player Variable(Event Player, ReinChargeTrack, False);
    }
}

rule ("Mauga overrun knockdown") {
    event {
        Player Dealt Damage;
        All;
        Mauga;
    }
    conditions {
        Event Ability == Button(Ability 1);
        Or(Or(And(Compare(Hero Of(Victim), ==, Hero(Reinhardt)), (Victim).ReinChargeTrack), And(And(Compare(Hero Of(Victim), ==, Hero(Doomfist)), Is Firing Secondary(Victim)), (Victim).DoomPunchTrack)), And(And(Compare(Hero Of(Victim), ==, Hero(Brigitte)), Is Firing Secondary(Victim)), Is Firing Primary(Victim))) == True;
        Absolute Value(Angle Difference(Horizontal Facing Angle Of(Event Player), Multiply(Horizontal Facing Angle Of(Victim), -1))) <= 90;
    }
    actions {
        Cancel Primary Action(Event Player);
        Set Status(Event Player, Victim, Knocked Down, 1.7);
        Set Status(Victim, Event Player, Knocked Down, 1.7);
        Wait(0.09, Ignore Condition);
        Apply Impulse(Victim, Multiply(Velocity Of(Victim), -1), 0.001, To World, Cancel Contrary Motion);
    }
}

rule ("[orisa/init.opy]: Correct Orisa Spin, Melee damage") {
    event {
        Player Dealt Damage;
        All;
        Orisa;
    }
    conditions {
        Array Contains(Array(Button(Ability 1), Button(Ability 2), Button(Melee)), Event Ability) == True;
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[orisa/init.opy]: Correct Orisa Javelin damage") {
    event {
        Player Dealt Damage;
        All;
        Orisa;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.929, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[status/hud.opy]: Display buffs from Roadhog and Sombra") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        Or((Event Player).Roadhog_vape_hud_icon, (Event Player).Sombra_hack_icon) == True;
    }
    actions {
        Create HUD Text(Event Player, Null, Null, Custom String(" \r\n\r\n\r\n\r"), Left, 1, Null, Null, Color(White), Visible To and String, Visible Never);
        Set Player Variable(Event Player, Status_Effect_Spectator_HUD, Last Text ID);
        Create HUD Text(Event Player, Null, Null, Custom String(" \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                                                           {0} {1}", If-Then-Else(Compare((Event Player).Roadhog_vape_hud_icon, ==, True), Ability Icon String(Hero(Roadhog), Button(Secondary Fire)), Custom String(" ")), If-Then-Else(Compare((Event Player).Sombra_hack_icon, ==, True), Ability Icon String(Hero(Sombra), Button(Ultimate)), Custom String(" "))), Left, 2, Null, Null, Color(White), Visible To and String, Default Visibility);
        Set Player Variable(Event Player, Status_effect_hud, Last Text ID);
        Wait(5, Ignore Condition);
        Destroy HUD Text((Event Player).Status_effect_hud);
        Destroy HUD Text((Event Player).Status_Effect_Spectator_HUD);
    }
}

rule ("[ana/sleep.opy]: Cleanse the sleep on tanks on damage") {
    event {
        Player Took Damage;
        All;
        All;
    }
    conditions {
        Has Status(Event Player, Knocked Down) == True;
        (Event Player).Ana_Sleepdart_Target == True;
    }
    actions {
        If(Compare(Ability Cooldown(Players On Hero(Hero(Ana), Opposite Team Of(Team Of(Event Player))), Button(Ability 1)), !=, 0));
            Clear Status(Event Player, Knocked Down);
            Set Player Variable(Event Player, Ana_Sleepdart_Target, Null);
    }
}

rule ("[lifeweaver/healing.opy]: Lifeweaver Healing cooldown") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).Lifeweaver_healing_cd == True;
    }
    actions {
        Wait(4, Abort When False);
        Set Player Variable(Event Player, Lifeweaver_healing_cd, Null);
    }
}

rule ("[juno/init.opy]: Correct Pulsar Torpedo healing over time") {
    event {
        Player Dealt Healing;
        All;
        Juno;
    }
    conditions {
        Event Healing > 69;
    }
    actions {
        Start Damage Over Time(Healee, Null, 2.4, 10);
    }
}

rule ("[mei/init.opy]: Initialize Mei TANK") {
    event {
        Subroutine;
        initMei;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 400);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 2800);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.66);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Start Scaling Player(Event Player, 1.15, True);
        Set Player Variable(Event Player, hero_initialized, True);
        Set Player Variable(Event Player, max_health_scaler, 1.1);
    }
}

rule ("[mei/init.opy]: Reduce Headshot damage taken Mei") {
    event {
        Player Took Damage;
        All;
        Mei;
    }
    conditions {
        Event Was Critical Hit == True;
    }
    actions {
        Heal(Event Player, Null, Multiply(Event Damage, 0.3));
    }
}

rule ("[mei/endothermic.opy]: AOE Damage Mei") {
    event {
        Player Dealt Damage;
        All;
        Mei;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Play Effect(All Players(All Teams), Bad Explosion, Color(Sky Blue), Victim, 2);
        Play Effect(All Players(All Teams), Ring Explosion, Color(Aqua), Victim, 5);
        Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Sky Blue), Event Player, 40);
        Damage(Players Within Radius(Victim, 5, Opposite Team Of(Team Of(Event Player)), Surfaces And Enemy Barriers), Attacker, 25);
    }
}

rule ("[junkerqueen/init.opy]: Shout indicator") {
    event {
        Ongoing - Each Player;
        All;
        Junker Queen;
    }
    conditions {
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Between Rounds == False;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0} {1}", Count Of(Filtered Array(All Living Players(Team Of(Event Player)), And(And(Compare(Distance Between(Event Player, Current Array Element), <=, 15), Is In Line of Sight(Event Player, Current Array Element, Barriers Do Not Block LOS)), Compare(Hero Of(Current Array Element), !=, Hero(Junker Queen))))), Ability Icon String(Hero(Junker Queen), Button(Ability 1))), Update Every Frame(Add(Eye Position(Event Player), Multiply(100, Add(Multiply(-0.5, Direction From Angles(Horizontal Angle From Direction(Facing Direction Of(Event Player)), Subtract(Vertical Angle From Direction(Facing Direction Of(Event Player)), 90))), Multiply(3, Facing Direction Of(Event Player)))))), 2, Do Not Clip, Visible To Position String and Color, Color(White), Default Visibility);
        Set Player Variable(Event Player, JQ_Shout_Hud, Last Text ID);
        Wait Until(Is Using Ability 1(Event Player), 99999);
        Destroy In-World Text((Event Player).JQ_Shout_Hud);
        Set Player Variable(Event Player, JQ_Shout_Hud, Null);
    }
}

rule ("[junkerqueen/init.opy]: Clean up JQ") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).hero_setup != Hero(Junker Queen);
    }
    actions {
        Destroy In-World Text((Event Player).JQ_Shout_Hud);
    }
}

rule ("hazard reveal enemies") {
    event {
        Player Dealt Damage;
        All;
        Hazard;
    }
    conditions {
        Has Status(Victim, Rooted) == True;
        Event Ability == Button(Ultimate);
        (Victim).Hazard_Downpour_Target == Null;
    }
    actions {
        Create In-World Text(Event Player, Custom String("{0} {1}m", Ability Icon String(Hero(Hazard), Button(Ultimate)), Round To Integer(Distance Between(Event Player, Victim), Up)), Add(Victim, Vector(0, 2.5, 0)), 1.5, Do Not Clip, Visible To Position and String, Color(White), Default Visibility);
        Set Player Variable(Victim, Hazard_Downpour_effect, Last Text ID);
        Set Player Variable(Victim, Hazard_Downpour_Target, True);
    }
}

rule ("hazard reset reveal enemies") {
    event {
        Ongoing - Each Player;
        All;
        All;
    }
    conditions {
        (Event Player).Hazard_Downpour_Target == True;
    }
    actions {
        Wait(2.5, Ignore Condition);
        Destroy In-World Text((Event Player).Hazard_Downpour_effect);
        Set Player Variable(Event Player, Hazard_Downpour_Target, Null);
        Set Player Variable(Event Player, Hazard_Downpour_effect, Null);
    }
}

disabled rule ("[freja/init.opy]: initFreja()") {
    event {
        Subroutine;
        initFreja;
    }
    actions {
        Set Player Variable At Index(Event Player, custom_hp_pvar, 0, 200);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 1, 0);
        Set Player Variable At Index(Event Player, custom_hp_pvar, 2, 0);
        Call Subroutine(applyCustomHp);
        Set Player Variable At Index(Event Player, ult_charge_pvar, 1, 1900);
        Set Player Variable At Index(Event Player, macro_pvar, 0, 0.667);
        Set Damage Dealt(Event Player, Multiply(100, First Of((Event Player).macro_pvar)));
        Start Scaling Player(Event Player, 0.96, True);
        Set Player Variable(Event Player, hero_initialized, True);
    }
}

disabled rule ("[freja/init.opy]: Correct Freja other forms of damage") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Event Ability == Button(Melee);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

disabled rule ("[freja/init.opy]: Correct Freja secondary impact damage") {
    event {
        Player Dealt Damage;
        All;
        All;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Divide(Event Damage, First Of((Event Player).macro_pvar)), Event Damage), First Of((Event Player).macro_pvar)));
        Wait(3, Ignore Condition);
    }
}

rule ("[mccree/fanthehammer.opy]: Increase Fan the hammer damage to 40") {
    event {
        Player Dealt Damage;
        All;
        Cassidy;
    }
    conditions {
        Event Ability == Button(Secondary Fire);
    }
    actions {
        Damage(Victim, Attacker, Divide(Subtract(Multiply(0.8, Divide(Event Damage, First Of((Event Player).macro_pvar))), Event Damage), First Of((Event Player).macro_pvar)));
    }
}

rule ("[ashe/dynamite.opy]: Decreased dynamite damage by healing until timeout or cleansed = 85 damage") {
    event {
        Player Dealt Damage;
        All;
        Ashe;
    }
    conditions {
        Event Ability == Button(Ability 2);
    }
    actions {
        Start Heal Over Time(Victim, Null, 5, 2);
        Set Player Variable(Victim, Ashe_Dynamite_Healing_ID, Last Healing Modification ID);
        Wait Until(Has Status(Victim, Phased Out), 5);
        Stop Heal Over Time((Victim).Ashe_Dynamite_Healing_ID);
        Set Player Variable(Victim, Ashe_Dynamite_Healing_ID, Null);
    }
}

settings {
    "main": {
        "modeName": "6v6 Adjustments + Realth 1.16.9"
    },
    "lobby": {
        "mapRotation": "afterGame",
        "spectatorSlots": 12,
        "team1Slots": 6,
        "team2Slots": 6,
        "pauseGameOnDisconnect": true,
        "returnToLobby": "afterGame"
    },
    "gamemodes": {
        "assault": {
            "enabledMaps": [],
            "captureSpeed%": 120,
            "enableCompetitiveRules": true,
            "enablePerks": false
        },
        "clash": {
            "enabled": false,
            "captureSpeed%": 45
        },
        "control": {
            "enabledMaps": [],
            "enableCompetitiveRules": true,
            "enablePerks": false
        },
        "escort": {
            "enabledMaps": [],
            "enableCompetitiveRules": true,
            "enablePerks": false
        },
        "flashpoint": {
            "enabledMaps": [],
            "enableCompetitiveRules": true,
            "enablePerks": false,
            "scoringSpeed%": 85
        },
        "hybrid": {
            "enabledMaps": [],
            "enableCompetitiveRules": true,
            "enablePerks": false
        },
        "push": {
            "enabledMaps": [],
            "enableCompetitiveRules": true,
            "enablePerks": false,
            "ts1PushSpeedModifier%": 100
        },
        "general": {
            "gamemodeStartTrigger": "immediately",
            "healthPackRespawnTime%": 120,
            "randomHeroRoleLimitPerTeam": 2,
            "spawnHealthPacks": "enabled",
            "tankPassiveHealthBonus": "disabled"
        }
    },
    "heroes": {
        "allTeams": {
            "ana": {
                "ammoClipSize%": 80,
                "ability2Cooldown%": 86,
                "health%": 80,
                "ability1Cooldown%": 86,
                "ultGen%": 100
            },
            "ashe": {
                "health%": 80,
                "ultGen%": 109
            },
            "baptiste": {
                "ammoClipSize%": 130,
                "health%": 80,
                "ultGen%": 105
            },
            "bastion": {
                "health%": 70,
                "ability1Cooldown%": 100,
                "ultGen%": 96
            },
            "brigitte": {
                "health%": 80,
                "ability2Cooldown%": 100,
                "ultGen%": 103
            },
            "cassidy": {
                "health%": 72,
                "ultGen%": 107
            },
            "dva": {
                "ability1Cooldown%": 114,
                "secondaryFireMaximumTime%": 67,
                "secondaryFireRechargeRate%": 90,
                "health%": 69,
                "ultGen%": 110
            },
            "doomfist": {
                "health%": 63,
                "ability2Cooldown%": 100,
                "ultGen%": 113
            },
            "echo": {
                "ability2Cooldown%": 125,
                "health%": 33,
                "ultGen%": 98
            },
            "freja": {
                "health%": 89
            },
            "genji": {
                "ammoClipSize%": 125,
                "health%": 80,
                "ultDuration%": 50,
                "ultGen%": 145
            },
            "hanzo": {
                "health%": 80,
                "ability2Quantity%": 4,
                "ultGen%": 110
            },
            "hazard": {
                "health%": 67,
                "ability1Cooldown%": 116
            },
            "illari": {
                "ammoClipSize%": 85,
                "ability2Cooldown%": 114,
                "health%": 80,
                "solarEnergyMax%": 86,
                "ultGen%": 121
            },
            "junkerQueen": {
                "ability2Cooldown%": 88,
                "ability1Cooldown%": 108,
                "health%": 71,
                "ultGen%": 117
            },
            "junkrat": {
                "ability1Cooldown%": 100,
                "health%": 80,
                "ultGen%": 109
            },
            "juno": {
                "ability1Cooldown%": 133,
                "health%": 50,
                "ability2Cooldown%": 136,
                "secondaryFireCooldown%": 100,
                "ultGen%": 110
            },
            "kiriko": {
                "health%": 89,
                "ability2Cooldown%": 93,
                "ability1Cooldown%": 100,
                "ultGen%": 117
            },
            "lifeweaver": {
                "ammoClipSize%": 80,
                "health%": 50,
                "secondaryFireCooldown%": 100,
                "secondaryFireHealth%": 133,
                "ability1Cooldown%": 0,
                "ability1Health%": 45,
                "ultHealth%": 150,
                "ultGen%": 110
            },
            "lucio": {
                "health%": 89,
                "secondaryFireCooldown%": 105,
                "secondaryFireKb%": 100,
                "ultGen%": 90
            },
            "mauga": {
                "ammoClipSize%": 100,
                "ability2Cooldown%": 84,
                "ability2Healing%": 0,
                "health%": 83,
                "primaryFireIgniteDamage": 223,
                "primaryFireIgniteDuration": 75,
                "ability1Cooldown%": 120,
                "ultGen%": 108
            },
            "mei": {
                "health%": 80,
                "ultGen%": 120,
                "primaryFireFreezeRate%": 130
            },
            "mercy": {
                "ability1Cooldown%": 73,
                "health%": 89,
                "ability2Cooldown%": 50,
                "enablePassive": false
            },
            "moira": {
                "health%": 89,
                "ultGen%": 104
            },
            "orisa": {
                "secondaryFireCooldown%": 117,
                "ability1Cooldown%": 79,
                "health%": 69,
                "ability2Cooldown%": 75,
                "enableInfiniteAmmo": true,
                "ultGen%": 119
            },
            "pharah": {
                "health%": 89,
                "ultGen%": 105
            },
            "ramattra": {
                "health%": 63,
                "ability1Cooldown%": 100,
                "ability2Cooldown%": 85,
                "ultDuration%": 100,
                "ultGen%": 114,
                "secondaryFireCooldown%": 81
            },
            "reaper": {
                "health%": 75,
                "ability2Cooldown%": 80,
                "ultGen%": 98
            },
            "reinhardt": {
                "secondaryFireRechargeRate%": 88,
                "ability1Cooldown%": 143,
                "projectileSpeed%": 83,
                "ultGen%": 123
            },
            "roadhog": {
                "ability1Cooldown%": 117,
                "health%": 92,
                "ability2Cooldown%": 75,
                "secondaryFireCooldown%": 480,
                "secondaryFireMaximumTime%": 89,
                "secondaryFireRechargeRate%": 500,
                "ultGen%": 110
            },
            "sigma": {
                "secondaryFireRechargeRate%": 94,
                "health%": 86,
                "ability1Cooldown%": 108,
                "ultGen%": 101
            },
            "sojourn": {
                "health%": 80,
                "ability1Cooldown%": 75,
                "ultGen%": 110
            },
            "soldier": {
                "health%": 80,
                "ultGen%": 119
            },
            "sombra": {
                "secondaryFireCooldown%": 134,
                "health%": 89,
                "ability2Cooldown%": 100,
                "ultGen%": 49,
                "ability1Cooldown%": 150
            },
            "symmetra": {
                "health%": 75,
                "ultGen%": 121
            },
            "torbjorn": {
                "ability1Cooldown%": 83,
                "health%": 78,
                "ultGen%": 110
            },
            "tracer": {
                "health%": 86,
                "ability2Cooldown%": 103,
                "ultGen%": 110
            },
            "venture": {
                "ability1Duration%": 50,
                "ultGen%": 137
            },
            "widowmaker": {
                "health%": 89,
                "ultGen%": 101,
                "ability2Cooldown%": 80
            },
            "winston": {
                "health%": 92,
                "ability1Cooldown%": 120,
                "ultGen%": 138
            },
            "wreckingBall": {
                "secondaryFireCooldown%": 120,
                "ability1Kb%": 85,
                "health%": 50,
                "ability3Cooldown%": 125,
                "ultGen%": 120
            },
            "zarya": {
                "ability1Cooldown%": 109,
                "ultGen%": 119
            },
            "zenyatta": {
                "health%": 67,
                "ultGen%": 104
            },
            "general": {
                "passiveHealthRegen": false
            }
        }
    },
    "workshop": {
        "Activation Hold Time": 5.5,
        "Calculate DPS over seconds": 10,
        "Damage Role Cap": 2,
        "debug mode": false,
        "Support Role Cap": 2,
        "Tank Role Cap": 2
    }
}